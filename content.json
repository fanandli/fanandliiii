{"pages":[{"title":"","text":"计算机小白，学生，男 追求自由，喜爱自然目前还没有找到自己感兴趣的东西，也还没有达到那个地步吧。。。总之加油吧， 远远还没有到能够输出的程度，只是找个地方整理自己的所学，也顺便写点关于生活的东西。 才学疏浅，正在努力~~ aisleep.xyz或fanandli.github.io所发布的内容采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。","link":"/about/index.html"}],"posts":[{"title":"array and string exercises","text":"1：Score(ACM/ICPC Seoul2007,UVa1586) 给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分 别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的 分子量为94.108g/mol. 分析：题目中所说的原子只有4种，可以用数组存储，建立起原子和原子量的关系。最基本的是要对数字和原子进行区别处理。分子式的计算需要注意到原子后面是否跟了数字，如果是数字就需要乘以数字前面的原子值。 代码：12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;char s[1024];int main()&#123; double a[128]; a['C']=12.01; a['H']=1.008; a['O']=16.00; a['N']=14.01; int testcase; scanf(\"%d\",&amp;testcase); while(testcase--)&#123; scanf(\"%s\",s);//notice int n=strlen(s); double result=0; for(int i=0;i&lt;n;)&#123; int ele=s[i]; int num=0; i++; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')&#123; num=num*10+s[i]-'0'; i++; &#125; if(num==0) num=1; result+=a[ele]*num; &#125; printf(\"%.3lf\\n\",result); &#125; return 0;&#125; 注意：数组的一些基本的操作。strlen()数组在不同的地方定义影响不同。在mian函数外和在main函数里定义的区别。for()循环语句的灵活使用。a[‘C’]中的C用的是ASCII码.","link":"/2019/04/15/array-and-string-exercises/"},{"title":"data structure 杂物间","text":"小插曲：写作风格想渐渐地由便于理解的语言向最精简的叙述方式转变。（严谨的风格保持不变且在努力提高中：）） 整理一下数据结构所涉及到的一些C或C++中的基础知识。 结构型 结构型的作用就是满足对数据类型的需求的补充，我们可以自己创造合适自己的数据类型，例如现有int,char等数据类型，我们可以：12345typedef struct &#123; int a ; char b ;&#125;typeA; 这样就定义了一个typeA类型的数据类型。 他的使用需要注意：typeA a[3]这句话是定义了一个typeA类型的数组a[]。这个数组是由a[0]，a[1]，a[2]组成，且a[0]中由2个分别为int，char组成。使用a[0].a调用。 所以，这里的a[]可以理解为是一个二维数组了。需要理解一下。 使用自己定义的结构型构造结点 构造一个链表结点，分为两步：第一步：构造出需要的结构型（链表结点的定义）： 12345typedef struct Node&#123; int a; struct Node *next; &#125;Node; 构造出一个Node型，里面是一个int型的数据域，一个是Node型的指针。 第二步：构造出结点（用一个指针指向他）：12Node *p;p=(Node*)malloc(sizeof(Node)); 定义了一个p指针指向了结点，结点构造成功。结点的名字为p，这里的第2句的意思自行google。如果我们想要取出这个结点的data赋给x，那么应该这样做：x=p-&gt;data，或者可以这样x=(*p).data这里主要是指针的使用注意点。注意，这里的p命名了两个东西：一个是结点，另一个是指向这个结点的指针。所以p既是指针名又是结点名。 #define和typedef的使用 请看实例：123456789101112#define error 1#define ok 0typedef bool statustypedef int elemtypestatus f(elemtype a)&#123; if (a&gt;0) return error; else return ok;&#125; 上面这个代码其实就是这个意思： 1234567bool f(int a )&#123; if (a&gt;0) return 1; else return 0;&#125; typedef是为变量起一个新名字，#define则是定义一个常量，也可以理解为为常量起一个新名字。这样的用法的意义是可以当你有多个地方的int型的变量想要修改为char型的时候，不要一个一个的去修改，直接将typedef int xx改成typedef int yy就可以一下子全部修改了。 还有需要补充的小知识点再补充。。","link":"/2018/04/06/data-structure-1/"},{"title":"Requests库详解","text":"真正危险的不是计算机开始像人那样去思考，而是人类开始像计算机一样思考。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——西德尼·哈里斯（Sydney Harris） python爬虫之旅之第二站~~ Requests库是经常用的库，比urllib更加方便。首先先领略一下使用Requests的方便之处：1234567import requestsresponse=requests.get('http://aisleep.xyz')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 这里的第6行和在urllib中使用read的作用是一样的，在urllib中还要使用.decode使得其变成字符串类型。在Requests中就很方便了，直接使用text就可以了。在最后一行中的cookies获取中也比在urllib中方便很多。 再看requests中还提供了很多比较方便的各种请求方式：123456import requestsrequests.post(\"http://httpbin.org/post\")requests.put(\"http://httpbin.org/put\")requests.delete(\"http://httpbin.org/delete\")requests.head(\"http://httpbin.org/get\")requests.options(\"http://htpbin.org/get\") 可见想要进行一个post请求，直接requests.post就好。 好，Requsets的方便之处你现在也稍微感受到一点了，现在在仔细的看一下他的使用。 get请求 123import requestsresponse=requests.get('http://aisleep.xyz')print(response.text) 这里就是一个最简单的一个get请求。那如果我们还要传一些自己的参数怎么设置呢：123import requestsresponse=requests.get(\"http://httpbin.org/get?name=lifan&amp;age=23\")print(response.text) 也可以这样：1234567import requestsdata=&#123; 'name':'lifan', 'age':23&#125;response=requests.get(\"http://httpbin.org/get\",params=data)print(response.text) 第一种方法比较繁琐一点，需要加一个?再在多个参数之间再加上&amp;就可以。第二种方法就是自己先构造一个字典，然后传给params就可以方便的构造一个get请求的url，不需要再手动输入了。 解析json 12345import requestsresponse=requests.get(\"http://httpbin.org/get\")print(type(response.text))print(response.json())print(type(response.json())) 这是直接提供的了个解析json格式的方式，其实第4行就相当于进行一个这样的调用：print(json.load(response.text))(在前面再加一句import json) 获取二进制数据 12345678import requestsresponse=requests.get(\"https://github.com/favicon.ico\")print(type(response.text),type(response.content))print(response.text)print(response.content)with open('favicon.ico','wb') as f: f.write(response.content) f.close() 这里使用content获取二进制数据，比如图片，视频等，第6行开始到结束做的是保存这个二进制文件的工作：打开一个文件，wb是说明对这个文件进行操作的方式为“以二进制格式打开一个文件只用于写入”，as f是帮这个文件起了一个别名，f.write是写入到打开的文件中，最后要关闭文件。 header添加 添加headers主要是模拟成你是浏览器要求的访问，防止被浏览网站所禁止。这里添加一个浏览器信息就好1234567import requestsheaders=&#123; 'User-Agent':'Mozilla/5.0 (Macintosh; intel Mac OS X 10_11_4) AppleWebKit/537.36(KHTML,like Gecko)Chrome/52.0.2743.116 Safari/537.36'&#125;response=requests.get('http://www.zhihu.com',headers=headers)print(response.text) 基本的post请求 1234import requestsdata=&#123;'name':'lifan','age':'23'&#125;response=requests.post(\"http://httpbin.org/post\",data=data)print(response.text) 这里就明显看出比urllib中的操作方便很多。 response属性 1234567import requestsresponse=requests.get('http://www.baidu.com')print(type(response.status_code),response.status_code)print(type(response.headers),response.headers)print(type(response.cookies),response.cookies)print(type(response.url),response.url)print(type(response.history),response.history) 运行结果为：12345&lt;class &apos;int&apos;&gt; 200&lt;class &apos;requests.structures.CaseInsensitiveDict&apos;&gt; &#123;&apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Date&apos;: &apos;Tue, 03 Apr 2018 07:59:03 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Last-Modified&apos;: &apos;Mon, 23 Jan 2017 13:27:36 GMT&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Set-Cookie&apos;: &apos;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;&#125;&lt;class &apos;requests.cookies.RequestsCookieJar&apos;&gt; &lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;&lt;class &apos;str&apos;&gt; http://www.baidu.com/&lt;class &apos;list&apos;&gt; [] 状态码判断 123import requestsresponse=requests.get('http://www.baidu.com')exit() if not response.status_code==requests.codes.ok else print('request successfully') 这个状态码的判断的意思是，在requests.codes里面他将很多的状态码对应了一些方便记忆的单词，比如，将200对应了ok这个词，404对应了not_found这个词，这样我们只要查表不需要记住这些状态码就行了，第3行的代码的意思是：如果response的状态码不等于ok就退出，如果等于，就打印request successfully。","link":"/2018/04/03/Requests-webscraping/"},{"title":"图——拓扑排序","text":"拓扑排序 AOV网，描述了一种有实际意义的过程，所以结点之间有了先后顺序，其次是结点之间是没有环的。如何导出正确的结点之间的顺序，就需要拓扑排序。三个步骤: 用邻接表来存储图，且修改顶点结构体为123456typedef struct&#123; int data; int count; //指示当前结点的入度 ArcNode* first;&#125;VNode; 拓扑排序的代码实现：123456789101112131415161718192021222324252627282930313233int TopSort(AGraph *G)&#123; int i ,j ,n=0; //n统计当前已经输出的顶点个数 int stack[maxSize],top=-1; //定义一个栈，保存所有入度为0的顶点 ArcNode* p; //遍历 for(i=0;i&lt;G-&gt;n;++i) if(G-&gt;adjList[i].count==0) stack[++top]=i; //将入度为0的压栈 while(top!=-1)//若栈不为0， &#123; i=stack[top--]; //取出顶点，等效于将这个顶点删除， ++n; //记录取出的点的个数， std::cout&lt;&lt;i&lt;&lt;\" \"; //输出这个顶点 p=G-&gt;adjList[i].first; //遍历刚才出栈顶点的所有边， while(p!=NULL) &#123; j=p-&gt;adjV; //通过这些边找到其相邻顶点， --(G-&gt;adjList[j].count); //修改其count if(G-&gt;adjList[j].count==0) //然后将count为0的点入栈，以待输出 stack[++top]=j; p=p-&gt;next; &#125; &#125; if(n==G-&gt;n) //输出的顶点个数是否为图中顶点的个数 return 1; //相等则拓扑排序完成 else return 0;&#125; 逆拓扑排序 如何用深度优先遍历实现逆拓扑排序深度优先遍历： 以此实现逆拓扑排序：","link":"/2018/05/15/data-structure-10/"},{"title":"图——关键路径","text":"关键路径AOE网，(activate on edge)1为源点，6为汇点。所谓关键路径，就是在AOE网中从源点开始到汇点结束的具有最大路径长度的那个路径就为关键路径。 首先由事件的拓扑排序和逆拓扑排序求出事件最早发生时间，规定第一个结点的最早发生时间为0，这里所谓的最早发生时间的最早，是指在这个事件可以发生的前提下最早发生的时间，例如结点6首先他要发生，得必须等到3,4结点都发生完了，才可以考虑发生，因为如在现实生活中是一样的，事件6可以在事件3,4完成的前提下发生，他只是有发生的条件了，并不是说就一定发生了，我可以先等一会，然后再发生，那样，只要事件6的发生时间大于等于6他都可以发生，所以，他最早发生时间为6，这里所谓的最早是指在这个结点能有发生的前提下，不再等待任何多余的时间，即最早。 事件最晚发生时间：这个概念，首先我们由上面可知事件6的发生时间只要大于等于6就可，可是在现实生活中，一个事件一直拖着毫无意义。所以我们人为规定最后一个事件的（这里为事件6）最晚发生时间就等于最早发生时间。在此前提下我们再去求之前事件的最晚发生时间。如果没有这个规定，事件6之前的事件都可以往后拖了。 活动的最早发生时间：活动的最早发生时间为引出这个活动的事件（ -&gt;活动）的最早发生时间。如活动a2，引出这个活动的事件只有事件1，那么这是事件1的最早发生时间就是活动a2的最早发生时间为0。 活动的最迟发生时间：活动的最迟发生时间为这个活动引出的事件（活动-&gt; ）的最迟发生时间减去这个活动持续的时长。 关键路径就是活动的最早发生时间等于活动的最晚发生时间的那些活动构成的路径，为关键路径。","link":"/2018/05/15/data-structure-11/"},{"title":"图——最小生成树","text":"由一个图按照某种规则导出的一个树，叫生成树。最小生成树：构成这个生成树的所有分支的权值和最小。 prime算法求最小生成树的代码：1234567891011121314151617181920212223242526272829void Prim(int n ,float MGraph[][n],int v0,float &amp;sum) //顶点个数，带权图，构造生成树的起始顶点，存储最小权值和（代价）&#123; int lowCost[n],vSet[n]; int v,k,min; for(int i=0;i&lt;n;++i) &#123; lowCost[i]=MGraph[v0][i]; //lowCost[]指向vo初始点的同一行的不同列的顶点 vSet[i]=0; &#125; v=v0; //v指向第一个结点， vSet[v]=1; //已经并入，所以标记设置为1 sum=0; //初始化 for(int i=0;i&lt;n-1;++i) &#123; min=INF; //min初始化为无穷大 for(int j=0;j&lt;n,++j) if(vSet[j]==0&amp;&amp;lowCost[j]&lt;min) &#123; min=lowCost[j]; k=j; &#125; vSet[k]=1; v=k; //v指向如今刚进入的结点 sum+=min; //min的值累加到sum for(int j=0;j&lt;n;++j) //更新lowCost数组 if(vSet[j]==0&amp;&amp;MGraph[v][j]&lt;lowCost[j]) lowCost[j]=MGraph[v][j]; &#125;&#125; lowCost[]数组是用来存储当前生成树到图中其余顶点的边的最小权值。vSet[i]为1时就说明已经被并入生成树中，为0就没有并入。v指向刚并入的顶点。 v0是最小生成树的初始结点，所以v=v0 kruskal算法 把当前未被并入的，且并入后不会产生环的最小边进行并入。如何检测并入后到底会不会产生环呢？就用到了“并查集”。所谓的并查集，就是通过这些图中的点构造出来的树，每一个结点在相连的时候，要一直查到根结点，如果根结点不相同，说明图中选取边之后不会产生环，所以可以选择这个这个结点的边。 相关的存储结构: 代码实现：","link":"/2018/05/01/data-structure-13/"},{"title":"希尔排序","text":"首先我们来先看一个过程， 对于这个我们首先取五为一个子序列，将13和49进行了交换，就这样一直移动到最后，将指到的两个数字进行排序，接着我们取5的一半，下取整，就是2.以此再对子序列中的值进行大小比较。也一直移动到最后，最后再以2的一半的下取整，为1，划分为子序列对其元素进行大小排序。 下面看一下代码事例：gap是增量，待排序的规模n是10，所以gap=n/2=5,i的范围是从gap到最后一个关键字，i是用来选出无序序列中的一个关键字，然后将其插入到有序序列中的合适的位置的。 外层的for循环是改变选出的子序列的长度大小，刚开始是5，后来是2，再后来是1。然后内层的for循环是对子序列中的变量进行大小比较排序，满足条件就将其进行互换位置。以第一次操作为例，将arr[5]与arr[j=0]比较大小，然后满足条件就转换他们的位置。以此类推。","link":"/2018/05/18/data-structure-14/"},{"title":"快速排序","text":"首先以几个图片大致说一下这个算法的思路是什么： 然后看以下代码事例：其中arr[]是装关键字的数组，low和high是处理关键字的范围，初始就为整个数组。if(low&lt;high)成立才递归，很明显是因为low&gt;high了，说明子序列就不存在了。 123456789101112131415161718192021222324252627void quickSort(int arr[],int low,int high)&#123; int temp; int i=low;j=high; if(low&lt;high) &#123; temp=arr[low]; while(i&lt;j) &#123; while(j&gt;i&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; quickSort(arr,low,i-1); quickSort(arr,i+1,high); &#125;&#125; 这里我说明一下这段代码的大致意思。首先先讲i,j指向low,high。temp先指定low处的关键字，然后第10行的while循环，这个循环的主要目的是找到一个arr[j]处的关键字比temp指的小，不然就一直往前移（–j），如果找到了，且满足if（i&lt;j），就将这个小的值，移到temp处，即往前移，然后让i往后移。同样的道理，在i处是找到比temp大的数就停下来，让这个大的数往后移，即与arr[j]交换，j往前再走一步。如此一直循环，直到不满足i&lt;j。然后退出第8行的循环，将此时的temp赋给arr[i]。 接着到了24行，进入递归，level1（0,3,7）是为了方便理解自己写出来的，指出范围为0到7，且i，j指向3。在第一次进入这个递归的时候，low=0，i-1=2；所以，如图所示。 i=0，j=2.temp暂存arr[0]=27。然后下面的while循环同上面的过程一样。一直走到第23行，循环完之后，i和j同时指向了1。所以我们可以记录为level2（0,1,2），代表这次是在0到2中循环且最后落在在了1这个位置。然后我们又来到了第24行，又进入了递归，此时i=j=0,进入递归，在第5行if（low&lt;high）处就不满足条件了，就直接跳出来了一直到代码底此时的记录应该为level3(0, ,0)1。然后，我们跳出来了，我们就得从递归函数那出来，此时我们的level还是上一个，即level2（0,1,2）,然后程序执行来到第25行，又得进入一个递归，此时i=2，high=2.不满足第5行的if。就跳出来，然后从这个递归入口函数又出来，此时为level3(0, ,0)2。然后回到上一个递归，即到了level3（0，，0）1。上面已经知道了，这一层也不满足条件直接跳过，所以我们来到了level1(0,3,7)。然后执行第25行，i=4，j=7。然后进入if判定进行循环，接着个判定大小移动的操作和上面的步骤一样。此时level(4,6,7)2。然后在 准备进入递归入口函数，然后循环，然后再出递归，。。。以此再操作。","link":"/2018/05/20/data-structure-15/"},{"title":"直接插入，简单选择和冒泡排序","text":"直接插入排序 insertSort[]数组用来存储我们要排的关键字，n为关键字的个数，temp用来暂时存储我们当前要插入的排序的关键字。第一个for循环是从i=1开始，是因为我们规定认为初始状态的第0个元素为有序序列，第0个元素之后的元素为无序序列。我们的思路是从无序序列中逐次扫描，与有序序列中的大小进行比较，从而将他们插入到合适的位置中去。因为箭头总是指向带插入位置的前一个位置，所以我们要arr[j+1]=temp 12345678910111213141516void insertSort(int arr[],int n) &#123; int temp,i,j; for(i=1;i&lt;n;++i) &#123; temp=arr[i]； j=i-1; //j指向有序序列中的最右边的一个元素 while(j&gt;=0&amp;&amp;temp&lt;arr[j]) &#123; arr[j+1]=arr[j]; --j; //j是从右往左扫描有序序列 &#125; arr[j+1]=temp; //将temp中的待排关键字插入 &#125;&#125; 简单选择排序 首先这个排序的思想是：首先初始状态是从这个所有元素中选择出最小的元素，将他与这个整体中的第一个元素互换，这样，这个元素就为有序序列，然后再从已经除去被排序好的那个元素的无序序列中再选择出一个最小的元素，将这个元素与当前无序序列的第一个元素交换位置，此时有序序列的长度变为2，以此循环，将其变为有序。 123456789101112131415void selectSort(int arr[],int n)&#123; int i,j,k; int temp; for(i=0;i&lt;n;++i) &#123; k=i; //循环取最值 for(j=i+1;j&lt;n;++j) if(arr[k]&gt;arr[j]) k=j;//只是用k来存储最小元素在数组中的下标 temp=arr[i]; //将当前元素的最小值与无序序列中的第一元素互换位置 arr[i]=arr[k]; arr[k]=temp; &#125;&#125; 冒泡排序 首先我们从一个序列中依次从左往右扫描，如果当前的元素，比当前元素的前一个元素小的话，那么就交换这两个元素，这样一直扫描到最后，这样一趟扫描下来，目前最大的元素就会被移动到最右边，此时，就将最右边设为有序序列。接着，如此循环，将前面的无序序列的元素扫描，将最大的元素又移动到最右边，并入有序序列。以此即可。不过我们为了提高效率，发现，如果我们在扫描的时候，如果没有发生元素的交换的话，就说明无序序列也变为有序了。所以我们可以设置一个标记去标记（flag）这种情况是否发生。 12345678910111213141516171819void bubleSort(int arr[],int n)&#123; int i,j,flag; int temp; for(i=n-1;i&gt;=1;--i) //无序序列逐渐缩小 &#123; flag=0; for(j=1;j&lt;=i;++j) if(arr[j-1]&gt;arr[j]]) &#123; temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; flag=1; &#125; if(flag==0) return; &#125;&#125;","link":"/2018/05/17/data-structure-12/"},{"title":"多路归并排序","text":"之前有讲过一个二路归并排序 置换-选择排序：","link":"/2018/05/23/data-structure-19/"},{"title":"堆排序","text":"逻辑结构是完全二叉树，其左右孩子结点都小于或者都大于父结点的结构叫做堆，一个叫小顶堆，还有一个叫大顶堆。 我们可以用一个数组来存储完全二叉树 建堆操作 插入结点 删除结点例如我们想要删除这个根结点，我们可以先将这个结点拿的丢在一边，然后将最后一个结点丢在这个删除的结点的位置，然后对这个堆做一个调整。 堆排序的实现，我们分为两个过程，第一个过程是我们首先要建堆，第二个过程是我们从中挑出一个最值，然后把他丢在末尾，然后对其做一次调整。这两个过程说到底都是对某个关键字进行调整的过程。所以实现这个堆排序也要两个函数，一个函数是对某个关键字进行调整的函数，还有一个函数是堆排序的主函数。1234567891011121314151617181920212223242526272829303132333435void sift(int arr[],int low,int high) //调整函数&#123; int i=low,j=2*i+1; int temp=arr[i]; while(j&lt;=high) &#123; if(j&lt;high&amp;&amp;arr[j]&lt;arr[j+1]) ++j; if(temp&lt;arr[j]) &#123; arr[i]=arr[j]; i=j; j=2*i+1; &#125; else break; &#125; arr[i]=temp;&#125;void heapSort(int arr[],int n) //主函数&#123; int i; int temp; for(i=n/2-1;i&gt;=0;--i) sift(arr,i,n-1); //生成了大顶堆 for(i=n-1;i&gt;0;--i) &#123; temp=arr[0]; arr[0]=arr[i]; arr[i]=temp; sift(arr,0,i-1); // 有序序列 &#125;&#125; 我们首先走一下这个函数，我们走到主函数中的for（i=n/2-1;i&gt;0;–i)，i=8/2-1=3,然后我们下一句，我们调用调整函数，sift（arr，i,n-1）作用arr数组里的数，范围是i到n-1，即3到7。我们到调整函数，i=low,然后j=2*i+1，这句是j指向i的左孩子（这个是完全二叉树中找其孩子结点的公式） 我们看第7行的if语句，这句话的意思就是，如果i的左右孩子结点都存在的话，那么就将j指向左右孩子中较大的那个结点。此时这里i=3,他这个结点只有左孩子没有右孩子，不满足这个条件，所以就跳过。第8行的if语句，如果temp所指结点小于arr[j]的话，那就将j位置的值赋给i位置上，然后让i指向j，j指向i的左孩子结点，如果不满足条件，直接break.执行完这个调整函数之后，我们就恢复现场，此时还在26行的for循环中，再一次循环,–i，之前的i是3，所以这一次循环的i=2，然后再进入调整函数。这样一直循环。 调整函数中两个for循环都是为了生成大顶堆，主函数中的for（i=n-1;i&gt;0;–i）就是生成有序序列。","link":"/2018/05/21/data-structure-16/"},{"title":"归并排序","text":"arr[]存储所有待排关键字的数组，low到high的关键字为一个子表，从mid+1到high为另一个关键字的子表。所以可以看出，归并排序可以对一个序列中任意一部分的元素进行排序，通过指定范围low-high就行。int n1=mid-low+1;显然n1为low到high范围里的关键字的个数。int n2=high-mid;显然n2是mid+1到high的关键字的个数。 12345678910111213141516171819202122232425262728293031323334353637void merge(int arr[],int low,int mid,int high)&#123; int i,j,k; int n1=mid-low+1; int n2=high-mid; int L[n1],R[n2]; for(i=0;i&lt;n1;i++) L[i]=arr[low+i]; //将arr[]中的low到mid的元素赋给L[]中 for(j=0;j&lt;n2;j++) R[j]=arr[mid+1+j]; //将arr[]中的mid+1到high的元素赋给R[]中 i=0; j=0; k=low; while(i&lt;n1&amp;&amp;j&lt;n2) &#123; if(L[i]&lt;=R[j]) //L数组和R数组中相对应的元素进行大小比较 arr[k]=L[i++]; //此时L数组的元素较小，赋给arr数组中，且i加一 else arr[k]=R[j++]; // R数组中的元素较小 k++; //k指向arr数组中的元素，被赋过值了，所以加一 &#125; while(i&lt;n1) //L数组中若是比较完之后有剩余就将他加到arr数组的后面 arr[k++]=L[i++]; while(j&lt;n2) //同理是R数组中若有剩余 arr[k++]=R[j++];&#125;void mergeSort(int arr[],int low,int high)&#123; if(low&lt;high) &#123; int mid=(low+high)/2; //计算出中间位置 mergeSort(arr,low,mid); mergeSort(arr,mid+1,high); merge(arr,low,mid,high); &#125;&#125;","link":"/2018/05/22/data-structure-17/"},{"title":"基数排序","text":"基数排序要求比较数字的位数要一直，所以8要写成008,83要写成083等。按照关键字的最低位进行分配得到如下图：分配过后，我们按照从左到右的循序将他们收集，在遇到有两个元素在一个桶中的时候，按照从下往上的顺序将他们收集出来。收集过后，然后再从左到右，按照关键字的第二位进行分配。然后再对其进行收集关键字。然后我们再对其按照关键字的第三位进行分配。然后再对其进行收集关键字。然后就得到了有序序列。 各个排序的稳定性问题：气泡排序是稳定的 基于交换的简单选择排序是不稳定的（默认），基于插入的简单选择排序是稳定的。 直接插入排序是稳定的 快速排序是不稳定的 希尔排序是不稳定的 归并排序是稳定的 堆排序是不稳定的 基数排序是稳定的","link":"/2018/05/22/data-structure-18/"},{"title":"排序算法习题","text":"1.设计一个算法指出在一个无序关键字序列中的某个关键字是该序列中的第几个关键字（从小到大数），序列中关键字均为整数类型，且各不相同，要求比较的次数尽可能的少。12345678910111213141516171819int getPos(int arr[],int n,int k)&#123; int i=0,j=n-1; int temp; while(i&lt;=j) &#123; while(i&lt;n&amp;&amp;arr[i]&lt;=k) ++i; //把比这个数小的放在左边 while(j&gt;=0&amp;&amp;arr[j]&gt;k) --j; //把比这个数大的放在右边 if(i&lt;j) &#123; temp=arr[i]; //逻辑上为啥就能找到这个数的位置的原因不知道。。 arr[i]=arr[j]; arr[j]=temp; ++i; --j; &#125; &#125; return j+1;&#125; 2.设计一个用二分查找法来找插入位置的改进的插入排序算法??。123456789101112131415161718192021void BSSort(int arr[],int n)&#123; int low,high,mid,place; for(int i=2;i&lt;=n;++i) &#123; low=1;high=i-1; arr[0]=arr[i]; while(low&lt;=high) // 二分查找 &#123; mid=(low+high)/2; if(arr[0]&lt;arr[mid]) high=mid+1; else low=mid+1; &#125; place=low; //插入arr[i]的位置？？ for(int j=i-1;j&gt;=place;--j) arr[j+1]=arr[j]; arr[place]=arr[0]; &#125;&#125; 3.设计快速排序的递归和非递归算法??1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void partition(int arr[],int low,int high,int &amp;i) //划分函数&#123; int i; //初始化 int temp; i=low; j=high; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp;&#125;void quickSort(int arr[],int low,int high) //递归&#123; int i; if(low&lt;high) &#123; partition(arr,low,high,i); quickSort(arr,low,i-1); quickSort(arr,i+1,high); &#125;&#125;void quickSortNonrecursion(int arr[],int n) //非递归？？&#123; int i,low,high; int stack[maxSize][2],top=-1; //自己申请栈空间 low0;high=n-1; ++top; //入栈 stack[top][0]=low; stack[top][1]=high; while(top&gt;=0) &#123; low=stack[top][0]; //出栈 high=stack[top][1]; --top; partition(arr,low,high,i) if(low&lt;high) &#123; ++top; //入栈 stack[top][0]=low; stack[top][1]=i-1; ++top; //出栈 stack[top][0]=i+1; stack[top][1]=high; &#125; &#125;&#125; 4.设有整数0~n-1存放在整形数组A[0,1,2,…n-1]中，请设计一个时间复杂度为O(n),空间复杂度为O(1)的算法来是实现对A的排序（要求从小到大）。123456void order(int A[],int n)&#123; int i; for(i=0;i&lt;n;++i) A[A[i]]=A[i]; //???&#125; 5.编写一个是实现在排序二叉树中将data域（整型）值小于x的结点全部删除的算法。树中存在data域为x的结点且不存在data域值相同的结点。12345678910111213141516171819202122232425void deleteBT(BTNode *&amp;t)&#123; if(t!=NULL) &#123; deleteBT(t-&gt;lChild); deleteBT(t-&gt;rChild); free(t); t=NULL; &#125;&#125;void findAndDeleteBT(BTNode *&amp;t,int x)&#123; while(t!=NULL) &#123; if(t-&gt;data==x) &#123; deleteBT(t-&gt;lChild); return; &#125; else if(t-&gt;data&lt;x) t=t-&gt;rChild; else t=t-&gt;lChild; &#125;&#125;","link":"/2018/05/23/data-structure-20/"},{"title":"data structure——串","text":"生存还是毁灭，这是一个值得思考的问题。 ——莎士比亚《哈姆雷特》 特点：串的逻辑结构和线性表类似，串是限定了元素为字符串的线性表，但是，两者在操作上有很大区别：线性表的操作主要是针对的表内的某一个元素，而串操作主要是对串内的一个子串。 定义：定长顺序存储定义：12345typedef struct&#123; char str[maxsize+1]; int length;&#125;Str; 定长存储结构不需要分配和释放空间，但是如果想要改变空间大小，需要重新定义结构体。变长分配存储定义：12345typedef struct&#123; char *ch; //用malloc函数分配一个类型为char的连续存储空间, int length; //后用ch指针指向这个空间的起始地址&#125;Str; 可以通过这样来使用变长结构体123Str S; //定义一个名为S的变量S.length=L; //将长度设置为LS.ch=(char*)malloc((L+1)*sizeof(char)); //为其分配空间，指针ch指向这个空间的首地址 操作：1.赋值操作1234567891011121314151617181920212223242526272829303132int strassign(Str&amp; str,char* ch) &#123; if(str.ch) //这个我们将要赋值的串，如果已经指向某个存储空间了， free(str.ch); //那就先将他的存储空间释放掉 int len=0; char *c=ch; //定义一个指针c内容为ch的地址 while(*c) //当指针c所指的元素的值不为0就执行该循环 &#123; ++len; //c指针不为空，长度加一 ++c; //指针向后移动，再看是否为空 &#125; //求这个我们拿来赋值的数组中的字符的个数 if(len==0) &#123; str.ch=NULL; str.length=0; return 1; &#125; else &#123; str.ch=(char*)malloc(sizeof(char)*(len+1)); if(str.ch==NULL) //防止分配不到内存 return 0; else &#123; c=ch; //让c指针指向ch for(int i=0;i&lt;=len;++i,++c) str.ch[i]=*c; str.length=len; return 1; &#125; &#125;&#125; 2.取串长度1234int strlength(Str str)&#123; return str.length;&#125; 3.串比较操作 (ASCII码和长度的“数值”比较)1234567int strcompare(Str s1,Str s2)&#123; for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length,++i) if(s1.ch[i]!=s2.ch[i]) return s1.ch[i]-s2.ch[i]; //s1大于s2就返回一个大于0的数，反之同理 return s1.length-s2.length; &#125; 4.串连接操作12345678910111213141516171819202122232425int concat(Str&amp; str,Str str1,str2)&#123; if(str.ch) //如果ch指针不为空就执行if语句 &#123; free(str.ch); str.ch=NULL; &#125; str.ch=(char* )malloc(sizeof(char)*(str1.length+str2.length+1)); if (str.ch==NULL) //如果存储空间分配失败就返回0 return 0; int i=0; while(i&lt;str1.length) &#123; str.ch[i]=str1.ch[i]; ++i; &#125; int j=0; while(j&lt;=str2.length) &#123; str.ch[i+j]=str2.ch[j]; ++j; &#125; str.length=str1.length+str2.length; return 1;&#125; 5.求子串操作(以下是实现了求str串从pos位置开始，len长度的子串，由substr返回)12345678910111213141516171819202122232425262728293031int substring(Str&amp; substr,Str str,int pos,int len)&#123; if(pos&lt;0||pos&gt;=str.length||len&lt;0||len&gt;str.length-pos) return 0; if(substr.ch) &#123; free(substr.ch); substr.ch=NULL; &#125; if(len==0) //如果是空串的情况的话 &#123; substr.ch=NULL; substr.length=0; return 1; &#125; else &#123; substr.ch=(char*)malloc(sizeof(char)*len+1); int i=pos; int j=0; while(i&lt;pos+len) &#123; substr.ch[j]=str.ch[i]; ++i; ++j; &#125; substr.ch[j]='\\0'; //这里j已经移到了一个空白位置，所以在这里加上\\0就好 substr.length=len; return 1; &#125;&#125; 6.串清空操作12345678910int cleanstring(Str &amp;str)&#123; if(str.ch) &#123; free(str.ch); str.ch=NULL; &#125; str.length=0; return 1;&#125; 7.字符串模式匹配：简单模式匹配算法123456789101112131415161718192021int naive(Str str,Str substr)&#123; int i=1,j=1,k=i; //从数组下标1开始存储，下标0不存储，k为主串中第一次匹配的位置 while(i&lt;str.length &amp;&amp; j&lt;=substr.length) &#123; if(str.ch[i]==substr.[j]) &#123; ++i; ++j; &#125; else &#123; j=1; i=++k; &#125; &#125; if(j&gt;substr.length) return k; else return 0;&#125; KMP算法 在模式串j出发生不匹配时，只需要将F前移，使得F_l与F_n重合即可。假如F串的左部和右部有不止一对F_l和F-n，我们取第一个满足条件的一对（即较长的一对）。 若想直接由s_k状态跳转到s_k+1，只需要移动指针j即可，i指针可以保持不变。 next数组是用来存储，当发生模式串与主串不匹配的时候，下一需要跳转到的位置。 模式串中第j个位置与主串中的第i个位置发生不匹配的时候，应从模式串中的第next[j]个位置与主串第i个位置重新比较。 KMP算法实现：123456789101112131415161718192021int KMP(Str str, Str substr ,int next[])&#123; int i=1,j=1; while(i&lt;str.length&amp;&amp;j&lt;=substr.length) &#123; if(j==0||str.ch[i]==substr.ch[j]) &#123; ++i; ++j; &#125; else &#123; j=next[j]; &#125; &#125; if(j&gt;substr.length) return i-substr.length; else return 0;&#125; next数组的计算：","link":"/2018/04/13/data-structure-4/"},{"title":"图——Dijkstra算法","text":"最短路径问题 迪杰斯特拉算法求某一个顶点到其余各顶点的最短路径，也为单元最短路径算法。 dict[]数组存储了当前起点到其余各顶点的最短路径长度（是长度，数值），path[]存储了当前起点到其余各顶点的最短路径（是上一个顶点的下标）。set[]标记哪些顶点被选入了最短路径（是标记）。 dict[]数组中，将与其顶点直接相连的顶点的值直接记录下来，与其顶点没有直接相连的点就设为无穷大，自身就设为0。然后通过循环不断的更新其中的值。（存储的是起点和当前未被并入的顶点之间的距离） path[]存储了顶点到其所在最短路径上前一个顶点的信息 。如果某一个顶点的的path[]数组的值为-1，则说明，在此顶点之前没有其他顶点了。图中1,2,3对应的path[]数组的值为0，则说明1,2,3定点的前一个顶点为0。而4,5,6顶底在path[]数组中的值也为-1，是因为他们现在和当前最短路径上的顶点（现在为初始状态，此时最短路径上只有一个顶点0）没有直接关系。 set[]数组中，当前只有顶点0已经被选为最短路径中的顶点，所以将他标记为1其他的顶点还没有选择，所以暂时都是标记为0。 其中在执行过程中，例如下面这个图中的情况，当前最短路径中一共有0,1,2,3四个顶点，现在要找4,5,6三个顶点中，哪一个距离他们最短。第一个先并的0，然后并入的是1，然后并入的是2，然后并入的是3，看dist[]数组的的长度就知道了，因为都是按照哪个最短就先并哪个顶点的。此时，这里重点讲的是在并入哪一个顶点的比较过程，现在以此举例：在看4顶点，1.从根结点0到4顶点的距离为4+7（0-&gt;1-&gt;4）为11，2.从上一个顶点到4顶点的距离为无穷大（0-&gt;3-&gt;??),所以更新4顶点的dist[]数组为11，path[]数组为1，因为前一个顶点为1。然后就是再找到5顶点的路径长度是多少，同样要进行上面所说的两个比较，然后再找到6顶点的路径长度是多少，同样比较两个过程，最后，在4,5,6三个结点的路径长度之间选择一个最短的路径，并入最短路径中，将其顶点对应的set[]数组设置为1，就标志为已并入其中。这里，比较的是1.和2.这两种情况，在以后所有的选择哪一个顶点进行并入的时候都是进行这两种情况的比较。 接着，这里还有一个注意点，就是如下面的图中的过程，选的是最后一个顶点6怎么并入的过程，第一个路径是从根节点通过中间结点然后到达顶点6，第二个是通过上一个并入的顶点然后到顶点6（对应于上面的1.和2.的过程）对比这两个过程哪个路径短就并入最短路径。但是，有没有想过，第一个路径不止一种路径啊，为什么不这样走呢：0-&gt;1-&gt;4-&gt;6走呢？1,4也都是中间结点啊？？这里就是要讲的注意点就是路径的选择，我们可以以path[]数组为指引，选择路径，我们看0顶点的path[]数组是-1，为根结点的意思，1顶点的path[]数组为0，说明1顶点的前一个顶点为0，所以我们选1，顶点2的path[]为1，所以我们再选2顶点，5顶点的path[]为2，所以我们再选择5顶点，顶点4的path[]为5，所以我们就选择4，最终，选择出0-&gt;1-&gt;2-&gt;5-&gt;4这一条路径。其实以path[]作为选择路径的原因是，本来path[]中存储了之前顶点之间最短的路径，你为了保证再接入顶点的路径足够的短，当然前面的路径也要保证是短的。 可以看出来，在这个算法中一个核心的步骤就是1.和2.的两个结果的比较。我们把直接从根结点到要并入的结点v的距离记为dist[v]通过从上一个已并入的结点到要并入的结点的距离记为dist[vpre]+MGraph[vpre][v]如果dist[v]&gt;dist[vpre]+MGraph[vpre][v]则更新dist[v]=dist[vpre]+MGraph[vpre][v]更新path[v]=vpre。 代码如下：参数n为图的顶点个数，MGraph[][]为图的边信息，v0为起始顶点,dist[]存最短路径长度，path[]存最短路径。1234567891011121314151617181920212223242526272829303132333435void Dijkstra(int n,float MGraph[][n],int v0,int dist[],int path[]) &#123; int set[maxSize]; //初始化操作 int min,v; for(int i=0;i&lt;n;++i) &#123; dist[i]=NGraph[v0][i]; set[i]=0; if(MGraph[v0][i]&lt;INF) path[i]=v0; else path[i]=-1; &#125; set[v0]=1;path[v0]=-1; for(int i=0;i&lt;n-1;++i) //在没有被并入的顶点中挑一个距离最短路径最近的一个点 &#123; min=INF; for(int j=0;j&lt;n;++j) if (set[j]==0&amp;&amp;dist[j]&lt;min) &#123; v=j; min=dist[j]; &#125; set[v]=1; //然后将其设置为1 for(int j=0;j&lt;n;++j) /此循环是对dist和path数组的更新 &#123; if(set[j]==0 &amp;&amp;dist[v]+MGraph[v][j]&lt;dist[j]) &#123; dist[j]=dist[v]+MGraph[v][j]; path[j]=v; &#125; &#125; &#125;&#125;","link":"/2018/05/11/data-structure-8/"},{"title":"图——Floyd算法","text":"最短路径：弗洛伊德算法我们先看一下我们举例的图，如下图中右边的图，其中左边的Av[]数组存储的任意两个顶点之间的当前最短路径长度，pathv[]数组存储了任意两个顶点他们所在最短路径之间的中间点(v为下标)。 执行思路：对于每个顶点v，和任意一顶点对（i,j）,i不等于j,v不等于i,v不等于j，如果A[i][j]&gt;A[i][v]+A[v][j],则将A[i][j]更新为A[i][v]+A[v][j]的值，并将path[i][j]改为v。 执行过程： 首先我们一共所有的情况为{0,1}，{0,2}……初始化后，第一次，即当v=0时，发现所有情况中的{0,1}，此时i=0,j=1,v=0,v=i了，不满足条件，所以这个点跳过。很好理解，因为此时：式子”A[0][1]&gt;A[0][0]+A[0][1]”明显不成立，所以这种类型跳过，同样的{0,2}，{0,3}，{0,4}，这几个点也跳过，这也是为什么上面有说i不等于j,v不等于i,v不等于j的原因。接着我们来到{1,2},此时对应的式子为“A[1][2]&gt;A[1][0]+A[0][2]”,我们需要去判断大小，A[1][3]在A数组中为4，A[1][0]值为无穷，A[0][2]值也为无穷，所以式子不成立，不需要更新path数组。接着再看下一个情况{1，3},i=V，所以跳过，再下一个{2,0},j=v所以也跳过。再下一个{2,1}，现在对应的式子为A[2][3]&gt;A[2][0]+A[0][3],对应的值分别为2,3,7，式子不成立，也不需要更新。再下一对{3,0}，j=v跳过。再下一对{3,1},A[3][1]值为无穷，式子一定不成立，所以也不需要更新。最后看{3，2}，A[3][0]也为无穷大，所以，对于v=0这一情况，path数组不需要更新。 第二次，当v1时，也这样一个一个去比较，我就不细说了，其中，当为{0,2}时，式子为A[0][2]&gt;A[0][1]+A[1][2],其中的值分别为无穷大，5,4。明显，式子成立，所以，此时将A[0][2]更新为9，将path[0][2]更新为1，表示其中间结点为1。然后再一次一个一个的对比，不再赘述。 第三次，v=2,第四次，v=3，就这样循环比较，重复做上面的事情，更新A[]数组和path[]数组。 接着我们再看一下如何通过更新过的path[]数组去查找任意两个点的最短路径。例如：如果我们要寻找从1到0的最短路径是什么：首先查path[1][0]=3,说明1和0之间的中间点为3，所以将3标出，然后查path[1][3]=-1，说明从1到3有直接的边（这里path数组的值为-1，都说明两个点之间有直接相连的点，算是一个标记）。然后查path[3][0]=2，说明3和0之间又有中间点2，所以将2标出，然后查path[3][2]=-1,说明3和2之间也有直接的线相连，然后再查path[2][0]=-1,说明也有直接相连的边。此时从1到0的最短路径已经找出来了，就是分别这些个-1的边，为1-&gt;3-&gt;2-&gt;0。 然后这个通过path数组查找是实现任意两个点之间的额最短路径的算法为（递归）：u,v分别是从顶点u到顶点v 然后我们再看一下弗洛伊德算法的实现代码：n为图中顶点的个数，MGraph[][]是图的邻接矩阵存储。 12345678910111213141516171819void Floyd(int n,float MGraph[][n],int Path[][n])&#123; int i,j,v; int A[n][n]; for(i=0;i&lt;n;++i)//初始化 for(j=0;j&lt;n;++j) &#123; A[i][j]=MGraph[i][j]; Path[i][j]=-1; &#125; for(v=0;v&lt;n;++v) for(i=0;i&lt;n;++i) for(j=0;j&lt;n;++j) if(A[i][j]&gt;A[i][v]+A[v][j]) &#123; A[i][j]=A[i][v]+A[v][j]; Path[i][j]=v; &#125;&#125;","link":"/2018/05/15/data-structure-9/"},{"title":"线索二叉树","text":"线索二叉树 线索二叉树的结点定义：1234567typedef struct TBTNode&#123; char data; int ltag,rtaghy; struct TBTNode *lchild; struct TBTNode *rchild;&#125;TBTNode; 通过中序遍历对二叉树线索化的递归算法：1234567891011121314151617181920void InThread(TBTNode *p,TBTNode *&amp;pre) //p指向根结点&#123; if(p!=NULL) &#123; InThread(p-&gt;lchild,pre); //pre指针一直指向p指针指向的结点的前驱结点 if(p-&gt;lchild==NULL) &#123; p-&gt;lchild=pre; //左指针指向前驱结点， p-&gt;ltag=1; //且将ltag设为1 &#125; if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL) &#123; pre-&gt;rchild=p; //右指针指向后继结点， pre-&gt;rtag=1; //且将rtag设为1 &#125; pre=p; //p结点的要指向后继结点了，所以要将pre指向p，让他跟上来，这一句话要重点注意 p=p-&gt;rchild; //左子树全部访问完，开始访问右子树 InThread(p,pre); //递归，右子树线索化 &#125;&#125; 通过中序遍历建立中序线索二叉树的主程序：12345678910void createInThread(TBTNode *root)&#123; TBTNode *pre=NULL; if(root!=NULL) &#123; InThread(root,pre); pre-&gt;rchild=NULL; pre-&gt;rtag=1; &#125;&#125; 以p为根的中序线索二叉树中，中序序列下的第一个结点的算法：123456TBTNode *First(TBTNode *p)&#123; while(p-&gt;ltag=0) p=p-&gt;lchild; return p;&#125; 在中序线索二叉树中，结点p在中序下的后继结点的算法：1234567TBTNode *Next(TBTNode *p)&#123; if(p-&gt;ltag==0) return First(p-&gt;rchild); else return p-&gt;rchild;&#125; 中序线索二叉树上执行中序遍历的算法：12345void Inorder(TBTNode *root)&#123; for(TBTNode *p=First(root);p!=NULL;p=Next(p)) Visit(p);&#125; 通过前序遍历的二叉树线索化递归算法：123456789101112131415161718192021void preThread(TBTNode *p,TBTNode *&amp;pre)&#123; if(p!=NULL) &#123; if(p-&gt;lChild==NULL) &#123; p-&gt;lChild=pre; p-&gt;pre=1; &#125; if(pre !=NULL&amp;&amp;pre-&gt;rChild ==NULL) &#123; pre-&gt;rChild=p; pre-&gt;rTag=1; &#125; pre=p; if(p-&gt;lTag==0) //注意 preThread(p-&gt;lChild,pre); if(p-&gt;rTag==0) preThread(p-&gt;rChild,pre); &#125;&#125; 在前序线索二叉树上的遍历操作：1234567891011121314151617void preOrder(TBTNode *tbt)&#123; if(tbt !=NULL) &#123; TBTNode *p=tbt; while(p!=NULL) &#123; while(p-&gt;lTag==0) &#123; Visit(p); p=p-&gt;lChild; &#125; Visit(p); p=p-&gt;rChild; &#125; &#125;&#125; 通过后序遍历的二叉树线索化递归算法：12345678910111213141516171819void postThread(TBTNode *p,TBTNode *&amp;pre)&#123; if(p!=NULL) &#123; postThread(p-&gt;lChild,pre); postThread(p-&gt;rChild,pre); if(p-&gt;lChild==NULL) &#123; p-&gt;lChild=pre; p-&gt;pre=1; &#125; if(pre !=NULL&amp;&amp;pre-&gt;rChild ==NULL) &#123; pre-&gt;rChild=p; pre-&gt;rTag=1; &#125; pre=p; &#125;&#125;","link":"/2018/09/10/data-structure-Threaded-binary-tree/"},{"title":"data-structure-huffman树及其编码","text":"二叉树的确定： 举例：如果我们知道了先序序列abdecfgh和中序序列dbeacgfh，求确定这个二叉树的结构12345678910111213141516BTNode *createBT(char pre[],char in[],int L1,int R1,int L2,int R2) &#123; if(L1&gt;R1) return NULL; //递归出口 BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=pre[L1]; //先序序列的第一个结点是根结点 int i; //找出根结点在中序序列中的位置 for(i=L2;i&lt;=R2;++i) if(in[i]==pre[L1]) break; s-&gt;lChild=createBT(pre,in,L1+1，L1+i-L2,L2,i-1); s-&gt;rChild=createBT(pre,in,L1+i-L2+1,R1,i+1,R2); return s;&#125; 其中pre[]是先序序列，in[]是中序序列，L1,R1是先序序列的范围，L2,R2是中序序列的范围这里就使用了一个递归，分别处理根结点下的左右子树，子树下的左右子树,如此递归下去。其中12和13行的理由见下面：1234567891011pre:———————————————————————————————————————————————————————————————————— a | b | d | e | c | f | g | h |———————————————————————————————————————————————————————————————————— L1 L1+1 L1+i-L2 R1in：———————————————————————————————————————————————————————————————————— d | b | e | a | c | g | f | h |———————————————————————————————————————————————————————————————————— L2 i-1 i R2 举例：如果我们知道了中序遍历序列debghfca和后序遍历序列dbeacgfh，请确定二叉树123456789101112131415BTNode *createBT2(char post[],char in[],int L1,int R1,int L2,int R2) &#123; if(L1&gt;R1) return NULL; //递归出口 BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=post[R1]; //后序序列的最后一个结点是根结点 int i; //找出根结点在中序序列中的位置 for(i=L2;i&lt;=R2;++i) if(in[i]==post[R1]) break; s-&gt;lChild=createBT2(post,in,L1，L1+i-L2-1,L2,i-1); s-&gt;rChild=createBT2(post,in,L1+i-L2,R1-1,i+1,R2); return s;&#125; 层次遍历序列和中序遍历序列确定二叉树：12345678910111213141516171819202122232425262728293031323334353637int search(char arr[],char key,int L,int R) //查找函数，传入一个数组arr，key是要查找的值,L,R是范围&#123; int idx; //下标 for(idx=L;idx&lt;=R;++idx) if(arr[idx]==key) return idx; //找到这个值就返回下标，找不到就返回-1 return -1;&#125;void getSubLevel(char subLevel[],char level[],char in[],int n,int L,int R) //&#123; int k=0; for(int i=0;i&lt;n;++i) if(search(in,level[i],L,R)!=-1) subLevel[k++]=level[i];&#125;BTNode *CreateBT3(char level[],char in[],int n,int L,int R)&#123; if(L&gt;R) return NULL; BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=level[0]; int i=search(in,level[0],L,R); //要在中序遍历序列in中查找level[0]这个结点的位置，在范围L,R中 int LN=i-L;char LLevel[LN]; //LN,RN是数组长度 int RN=R-i;char RLevel[RN]; getSubLevel(LLevel,level,in,n,L,i-1); getSubLevel(RLevel,level,in,n,i+1,R); s-&gt;lChild=createBT3(LLevel,in,LN,L,i-1); //递归处理 s-&gt;rChild=createBT3(RLevel,in,Rn,i+1,R); return s;&#125; 在先序和中序序列来确定儿二叉树的情况时，知道了根结点之后，就可以在中序序列中，划分出左右子树是什么，因为他们是连续的，而在层次遍历中，他们是分散开来的，所以就有了getsubLevel函数，去查找他们，然后放到LLevel和RLevel数组中。这个函数具体是怎么做的呢，如图： 首先i将in数组（中序遍历序列）分成了左右不同的两个部分，分别是左右子树，下面是左右部分的元素在level数组中的分布情况，互相交错。我们是这样做的：在in数组中的L-i-1范围，用关键字t在level中扫描，看有和在数组in中L到i-1相同的值，有就把他们存到LLevel中。 getsublevel中sublevel是存储结果的数组，n是代表level的长度，L,R是要取的元素的范围。k是辅助从sublevel中插入元素。","link":"/2018/10/15/data-structure-huffman/"},{"title":"html小笔记","text":"准备考试之余，看点html吧吧吧。。。这里写点小笔记。。。唤起沉睡中的记忆。。。 唤醒记忆三部曲——html(Hypertext Markup Language) &lt;html&gt;标签：这个标签是一张网页的最外层的标签，包含一个网页的所有内容。 &lt;html&gt; ... &lt;/html&gt; &lt;body&gt;标签：页面中所有可见元素都应该包含在其中。 &lt;html&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;head&gt;标签：存放一些关键字等给浏览器和搜索引擎所用，不显示出来，一个页面只能有一个head标签。 &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;keywords&quot; content=&quot;..&quot;&gt; &lt;/head&gt; &lt;/html&gt; &lt;title&gt;标签：用于指定页面的标题，不显示在页面里，显示在浏览器上面的页面一行里。 &lt;html&gt; &lt;head&gt; &lt;title&gt;..标题名..&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 标题标签：有&lt;h1&gt;,&lt;h2&gt;,&lt;h3&gt;,…&lt;h6&gt;六个标题，可以渲染，也有&lt;h7&gt;,&lt;h8&gt;,等，不过不渲染了。没有嵌套关系和并列关系，只是代表优先级不一样。 &lt;html&gt; &lt;body&gt; &lt;h1&gt;..标题..&lt;/h1&gt; &lt;h2&gt;..标题..&lt;/h2&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;p&gt;标签：段落标签，一对p标签可以分一个段落,你在html中键入一个换行键是不会换行的，需要用段落标签。 &lt;html&gt; &lt;body&gt; ...文字.. &lt;p&gt; ....接上的文字... &lt;/p&gt; .... &lt;/body&gt; &lt;/html&gt; &lt;div&gt;标签：division（区域）容纳其他的元素，很常用，常见，简单，区分容纳,可嵌套，可以看成目录这各功能。 &lt;html&gt; &lt;body&gt; &lt;div&gt; .. &lt;/div&gt; &lt;div&gt; .. &lt;/div&gt; .. &lt;/body&gt; &lt;/html&gt; &lt;a&gt;标签：用于指定网页中的链接，锚链接（anchor)。其中，target=self表示在当前页打开网址，target=blank表示新打开一网页显示链接网址。 &lt;html&gt; &lt;body&gt; &lt;a href=&quot;http:www....&quot; target=&quot;self&quot;&gt;替换的文字&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; &lt;img&gt;标签：图片标签（image）指定图片。没有结束标签&lt;/img&gt;，支持jpg，png，svg，gif等。 &lt;html&gt; &lt;body&gt; &lt;img src=&quot;要插入图片的本地地址或网络地址&quot; alt=&quot;图片加载失败显示的内容&quot;&gt; &lt;/body&gt; &lt;/html&gt; 表格类标签：&lt;table&gt;指创建表格,&lt;tr&gt;指行,&lt;td&gt;指单元格，&lt;th&gt;指定表格的属性。&lt;thead&gt;存放表格属性名，&lt;tbody&gt;存放表格中的值，这里的&lt;thead&gt;指的是存放表格属性的地方，表格属性指列如姓名，年龄这些。&lt;tbody&gt;指的是存放这些属性的值得地方，列如lifan，13这些。建议建表最好用css来完成。 &lt;html&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; name &lt;/th&gt; &lt;th&gt; age &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; lifan &lt;/td&gt; &lt;td&gt; 13 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;header&gt;标签，&lt;footer&gt;标签：指标题相关的内容，概括整个页面的内容,footer标签，指指定页脚的相关内容。例如联系方式，自我介绍，联系地址等。他们也是一个容器，和div的区别就在于里面的内容是有一定的语义的，方便搜索引擎等的收集，而div里可以放任何东西，且没有语义。 &lt;html&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;..hello world..&lt;/h1&gt; &lt;small&gt;... &lt;/header&gt; ....正文.... &lt;footer&gt; ...contact...privacy.. &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; &lt;link&gt;,&lt;script&gt;标签：既可以写在&lt;head&gt;里也可以写在&lt;body&gt;里。不能直接在浏览器中显示。&lt;link&gt;标签加载外部资源，列如样式表等，script标签主要用于加载脚本，列如javascript。 &lt;html&gt; &lt;head&gt; ... &lt;link href=&quot;..xx.css&quot;&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;script src=&quot;..yy.js&quot;&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;button&gt;标签：按钮标签，是一个触发机制，一般需要和其他东西共同使用，列如和表单使用和javascript使用。 &lt;html&gt; &lt;body&gt; ... &lt;buttom&gt;signup&lt;/button&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;abbr&gt;标签：缩写（abbrevitation）,用于显示缩写的内容的所有内容。 &lt;html&gt; &lt;body&gt; &lt;abbr tittle=&quot;hyper text markup language&quot;&gt;html&lt;/abbr&gt;is interesting &lt;/body&gt; &lt;/html&gt; &lt;code&gt;,&lt;pre&gt;标签：用于包含代码，显示代码。&lt;code&gt;标签是行内元素，一般都是镶嵌在所在行里的，适合小段代码；&lt;pre&gt;标签适合用于大段代码。还可以设置代码的属性等。 &lt;html&gt; &lt;head&gt; &lt;style media=&quot;..&quot;&gt; code{ background: rgba(0,0,0,0); border-radius: 11px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; .....&lt;code&gt;a==2&lt;/code&gt; ... &lt;pre&gt; ... ... &lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;input&gt;标签：用于接收用户输入。&lt;input&gt;标签类型比较多：有： &lt;input type=&quot;text&quot;&gt; 默认值 &lt;input type=&quot;password&quot;&gt; 密码输入 &lt;input type=&quot;radio&quot;&gt; 单选框输入 &lt;inout type=&quot;checkbox&quot;&gt; 多选框 &lt;input type=&quot;file&quot;&gt; 选择文件 &lt;input type=&quot;reset&quot;&gt; 重置表单 ... 嗯。。。暂时先整理在这里，有空在网上找点小例子，有补充的再补充。。。","link":"/2018/03/18/html-learning-1/"},{"title":"data structure——树的例题","text":"1.假设二叉树采用二叉链表存储结构，设计一个算法，计算一棵给定二叉树的所有结点数。1234567891011int n=0;void count(BTNode *p)&#123; if(p!=NULL) &#123; ++n; count(p-&gt;lChild); count(p-&gt;rChild); &#125;&#125; 2.假设二叉树采用二叉链表存储形式，设计一个算法，计算一棵给定二叉树的所有叶子结点数。123456789101112int n=0;void count(BTNode *p)&#123; if(p!=NULL) &#123; if(p-&gt;lChild&amp;&amp;p-&gt;rChild==NULL) ++n; count(p-&gt;lChild); count(p-&gt;rChild); &#125;&#125; 3.假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针rchild将一棵二叉树的叶子结点按照从左往右的顺序串成一个单链表（在题目中定义两个指针，head与tail，其中head指向第一个叶子结点，head初值为null,tail指向最后一个叶子结点）。1234567891011121314151617181920void link(BTNode *p,BTNode *&amp;head,BTNode *&amp;tail)&#123; if(p!=NULL) &#123; if(p-&gt;rchild==NULL&amp;&amp;p-&gt;lChild==NULL) if(head==NULL) //如果head=null,则说明当前是遇到的是第一个叶子结点 &#123; head=p; tail=p; &#125; else //接着再将其他的叶子结点串在其后面 &#123; tail-&gt;rchild=p; tail=p; &#125; link(p-&gt;lchild,head,tail); link(p-&gt;rchild,head,tail); &#125; &#125; 4.在二叉树的二叉链表存储结构中，增加一个指向双亲结点的parent指针，设计一个算法，给这个指针赋值，并输出所有结点到根结点的路径。1234567891011121314151617181920212223242526272829303132333435363738typedef struct BTNode //修改数据结构&#123; char data; struct BTNode *parent; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode;void triBtree(BTNode *p,BTNode *q) //将各个结点的parent赋值&#123; if(p!=NULL) &#123; p-&gt;parent=q; q=p; triBtree(p-&gt;lchild,q); triBtree(p-&gt;rchild,q); &#125;&#125;void printPath(BTNode *p) //打印一个结点到根结点的路径&#123; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;\" \"&lt;&lt;endl; p=p-&gt;parent; &#125;&#125;void allPath(BTNode *p) //打印所有结点到根结点的路径&#123; if(p!=NULL) &#123; printPath(p); allPath(p-&gt;lchild); allPath(p-&gt;rchild); &#125;&#125; 5.假设满二叉树b的先序遍历序列已经存放在于数组中（在解题过程中，此数组名称可以自己定义，长度为n），设计一个算法将其转化为后序遍历序列。123456789void change(char pre[],int L1,int R1,char post[],int L2,int R2)&#123; if(L1&lt;=R1) &#123; post[R2]=pre[L1]; //这里是将pre[]中的第一个放在post[]的最后一个 change(pre,L1+1,(L1+1+R1)/2,post,L2,(L2+R2-1)/2); //将pre[]中的前一半存在post[]中的前一半中，递归处理 change(pre,(L1+1+R1)/2+1,R1,post,(L2+R2-1)/2+1,R2-1); //将pre[]的后一半存在post[]中的后一半中 &#125;&#125; 7.假设二叉树采用二叉链表存储结构存储，设计一个算法，求二叉树b中值为x的结点的层号。12345678910111213141516int L=1;void leno(BTNode *p,char x)&#123; if(p!=NULL) &#123; if(p-&gt;data==x) &#123; cout&lt;&lt;L&lt;&lt;endl; &#125; ++L; leno(p-&gt;lchild,x); leno(p-&gt;rchild,x); --L; &#125;&#125; 这里用到了一个我们发现遍历序列时候的共性：在遍历结点的时候，总是由指针p从一层往下面一层去走，一直走到最底层，(++L)然后由下层往上层走（–L）,而且，第一次遇见一个结点，是往下走，此时是先序遍历，（第二次遇见也是往下走），第三次遇见是往上走，是后序遍历，所以，我们在第10行加入++L,在递归处理左右子树后，在第14行加入--L（这里说的比较个人化。。不好理解） 8.二叉树的双序遍历是指：对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树。试写出执行这种双序遍历的算法。12345678910void Double_order(BTNode *t)&#123; if(t!=NULL) &#123; Visit(t); Double_order(t-&gt;lchild); Visit(t); Double_order(t-&gt;rchild); &#125;&#125; 9.设中序线索二叉树的类型为TBTNode*InThree;设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点。设计算法，在一棵中序线索二叉树中寻找结点t的中序下的前驱。设计算法，在一棵中序线索二叉树中寻找结点t的前序下的后继。12345678910111213141516171819202122232425262728293031323334TBTNode* inLast(TBTNode *t) //一直往右子树链走下去即为最后一个结点&#123; TBTNode *p=t; while(p&amp;&amp;!p-&gt;rtag) p=p-&gt;rchild; return p;&#125;TBTNode inPrior(TBTNode *t)&#123; TBTNode *p=p-&gt;lchild; if(p&amp;&amp;!t-&gt;ltag) p=inLast(p); return p;&#125;TBTNode * treNext(TBTNode *t)&#123; TBTNode *p; if(!t-&gt;ltag) p=t-&gt;lchild; else if(!t-&gt;rtag) p=t-&gt;rchild; else &#123; p=t; while(p&amp;&amp;p-&gt;rtag) p=p-&gt;rchild; if(p) p=p-&gt;rchild; &#125;&#125; 10.假设二叉树采用二叉链存储结构，设计一个算法，输出根结点到每个结点的路径。12345678910111213141516171819int i ;int top=0;char pathstack[maxsize];void allPath(BTNode *p)&#123; if(p!=NULL) &#123; pathstack[top]=p-&gt;data; ++top; if(p-&gt;lchild=NULL&amp;&amp;p-&gt;rchild=NULL) //如果当前为叶子结点就打印路径 &#123; for(i=0;i&lt;top;++i) cout&lt;&lt;pathstack[i]; &#125; allPath(p-&gt;lchild); allPath(p-&gt;rchild); --top; &#125;&#125;","link":"/2018/04/28/data-sturcture-practise-1/"},{"title":"web scraping with python","text":"之前就有对网络爬虫很感兴趣，觉得这是一件比较有意思的事情，奈何前段时间有接触过，学到后面的时候有点吃力，总结了一下原因之后觉得最直接的原因就是在前端方面自己接触的还是太少了，现在在准备论文之余。。。（为何总对论文的内容不感兴趣呢-_-！）再来重新看一遍爬虫吧。。哈哈，突然觉得保持一整天学习的热情的秘诀就是:把每一天的早晨的时间都用在自己感兴趣的事情上。 好了，进入正题，直接来看代码： 1234567891011121314151617181920from urllib.request import urlopenfrom urllib.error import HTTPError,URLErrorfrom bs4 import BeautifulSoupdef getTitle(url): try : html=urlopen(url) except (HTTPError,URLError) as e: return None try: bsObj=BeautifulSoup(html.read()) title=bsObj.body.h1 except AttributeError as e: return None return title title=getTitle(\"http://aisleep.xyz\")if title ==None: print(\"Title could not be found\")else: print(title) 首先是引入几个需要用到的库，request中的urlopen，beautifulsoup，是爬虫经常需要用到的库（这里代码中的BeautifulSoup是BeautifulSoup库中的BeautifulSoup对象，不是指的BeautifulSoup库），前者是自带的，能够直接获取网页中的html代码，而后者是第三方库，需要自己安装，他是用来转换我们得到的html代码的结构，使其能够只要目标信息的旁边或附近有标记（这里说的标记是HTML中的标记）我们就能够提取出来。HTTPError和URLError则是对异常的处理所需要的。 我们这里首先定义了一个名为getTitle的函数。我们在进行这个语句的时候：html=urlopen(&quot;http://aisleep.xyz&quot;)这行代码可能会发生两种异常：1、网页不在服务器上；2、服务器不存在。发生第一种异常，程序会抛出HTTpError异常，发生第二种异常，程序会返回一个None对象。所以getTitle函数中的第一个异常处理针对于HTTPError，还增加了一个防止url地址输入错误引起的URLError。 然后，我们在使用BeautifulSoup去提取我们所需要的信息时也会出错：如果我们想要调用的标签不存在，BeautifulSoup会返回一个None对象；如果再去调用这个None对象下面的子标签，还会发生AttributeError错误。 所以第二个异常处理针对于：1、因为服务器不存在而返回一个None值，后再调用这个None值（通过html.read()调用）引起的AttributeError异常。2、因为我们使用BeautifulSoup调用一个不存在的标签的时候返回了一个None值，后再调用这个None值下面的子标签而造成的AttributeError异常。 针对于爬虫中比较常见的异常处理，这样一来就会很简单的使自己的代码更稳定一点。 上面的是采集一个页面中需要的信息，下面再看一个代码，实现随机的从一个页面跳转到另一个页面： 12345678910111213141516171819from urllib.request import urlopenfrom bs4 import BeautifulSoupimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(articleUrl)： html=urlopen(\"http://en.wikipedia.org\"+articleUrl) bsObj=BeautifulSoup(html) return bsObj.find(\"div\",&#123;\"id\":\"bodyContent\"&#125;).findAll(\"a\",href=re.compile(\"^(/wiki/)((?!:).)*$\"))links=getLinks(\"/wiki/Kevin_Bacon\")while len(links)&gt;0: newArticle=links[random.randint(0,len(links)-1)].attrs[\"href\"] print(newArticle) links=getLinks(newArticle) 首先这里导入了一些需要的库，datetime和random分别是为了生成一个随机数生成器。第7行中就是通过当前时间为值实现了一个随机数生成器。接着定义了一个函数getLitle我们传入的是以http://en.wikipedia.org为开头的url然后传入Beautifulsoup，最后返回在当前网页（用的是find）中的在div标签下的id是bodyContent的，且不包含:的以/wiki/开头的所有url链接（返回的是一个列表，这里用了正则表达式来匹配所要满足条件的链接）。 第14行写到以Kevin_Bacon为开始页面，调用getLinks函数。16行往下是指在返回的列表不为空的情况下，以随机数生成器生成的随机数作为列表的序号，去访问另一个链接，跳转到另一个页面，打印这个链接，最后又将此链接传给getLitle函数。 接下面再看一个代码： 1234567891011121314151617from urllib.request import urlopenfrom bs4 import BeautifulSoupimport repages=set()def getLinks(pageUrl): global pages html = urlopen(\"http://wikipedia.org\"+pageUrl) bsObj=BeautifulSoup(html) for link in bsObj.findAll(\"a\",href=re.compile(\"^(/wiki/)\")): if 'href' in link.attrs: if link.attrs['href'] not in pages: newPage=link.attrs['href'] print(newPage) pages.add(newPage) getLinks(newPage)getLinks(\"\") 由于链接之间很多都是重复的，所以自然就会有需要“链接去重”的功能。首先定义了一个set集合类型的变量pages，接着我们看getLinks函数，第7行是定义全局变量pages，然后找到以/wiki/开头的链接。第12行是判断这个链接是否在pages中，如果不在就说明是新链接，打印且将他增加到pages中，最后将这个newPage又传入getLinks函数,递归处理。 var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/03/23/scraping-with-python/"},{"title":"线性表问题总结","text":"逆置问题：例1：1、将一长度为n的数组的前端K（k&lt;n）个元素逆序后移动到数组后段，要求原数组总数据不丢失。2、将一长度为n的数组的前端K（k&lt;n）个元素保持原序后移动到数组后段，要求原数组总数据不丢失。3、将数组中的元素循环左移p（0&lt;p&lt;n）个位置。1234567891011void reverse(int a[],int left,int right,int k)&#123; int temp; for (int i=left,j=right;i&lt;left+k &amp;&amp; i&lt;j;++i,--j) //因为k的长度有可能超过数组长度的一半 &#123; //所以i&lt;j这个条件还是要加上去的 temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 12345void moveToEnd(int a [],int n ,int k)&#123; reverse(a,0,k-1,k); reverse(a,0,n-1,k);&#125; 123456void moveP(int a [],int n,int p)&#123; reverse(a,0,p-1,p); reverse(a,p,n-1,n-p); reverse(a,0,n-1,n);&#125; 最值问题：1：在线性表中找最值 12345678910int max=a[0]; int maxIdx=0;for(int i=0;i&lt;n;++i)&#123; if (max&lt;a[i]) &#123; max=a[i]; //max值 maxIdx=i; //最大值的位置 &#125;&#125; 这个是最大值，最小值同理。 2：在链表中找最小值： 123456789101112LNode *p,*q;int min=head-&gt;next-&gt;data;q=p=head-&gt;next;while(p!=NULL)&#123; if(min&gt;p-&gt;data) &#123; min=p-&gt;data; q=p; &#125; p=p-&gt;data;&#125; 在链表中找最大值同理。 例：一双链表非空，有head指针指出，结点结构为{llink,data,rlink},请设计一个将结点数据域data值最大的那个结点（最大值结点只有一个）移动到链表最前边的算法，要求不得申请新结点空间。12345678910111213141516171819202122232425void maxFirst(DLNode *head)&#123; DLNode *p=head-&gt;rlink,*q=p; int max=p-&gt;data; while(p!=NULL) &#123; if(max&lt;p-&gt;data) &#123; max=p-&gt;data; q=p; &#125; p=p-&gt;rlink; &#125; DLNode *l=q-&gt;llink; *r=q-&gt;rlink; l-&gt;rlink=r; if(r!=NULL) //防止最大值为最后一个结点 r-&gt;llink=l; q-&gt;llink=head; q-&gt;rlink=head-&gt;rlink; head-&gt;rlink=q; q-&gt;rlink-&gt;llink=q;&#125; 归并问题：1：顺序表归并12345678910111213141516void mergearray(int a [],int m,int b[],int n,int c[])&#123; int i=0,j=0; int k=0; while(i&lt;m&amp;&amp;j&lt;n) &#123; if(a[i]&lt;b[j]) c[k++]=a[i++]; //c[k]=a[i];k++;i++ else c[k++]=b[j++]; &#125; while(i&lt;m) c[k++]=a[i++]; while(j&lt;n) c[k++]=b[j++];&#125; 分别将a[]和b[]的数组有小到大的归并为数组c[]，m,n分别为两个数组的长度，c数组的长度为两个长度的之和，所以不需要再来一个变量来存储了。i,j分别是数组下标用来指出哪个元素在进行比较，k是指向c数组的下标。如果a[i]&lt;b[j]则将a[i]赋值给c[k]，且k向后移一位，i也向后移一位。下一个while是在一个数组全部比较完而另一个数组还有剩余的时候，将剩余的数组中的每一个元素都移动到数组c中去。 2：链表归并–顺序归并123456789101112131415161718192021222324252627282930void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *r; C=A; C-&gt;next=NULL; free(B); r=C; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; r-&gt;next=p; p=p-&gt;next; r=r-&gt;next; &#125; else &#123; r-&gt;next=q; q=q-&gt;next; r=r-&gt;next; &#125; if(p!=NULL) r-&gt;next=p; if(q!=NULL) r-&gt;next=q; &#125;&#125; p,q是指向两个链表的指针，C是指向新链表的指针，r是指向新链表表尾的指针。C=A是以A链表的头结点作为新链表的头结点。然后释放B结点（头结点）。此时新链表为空链表，所以r指针指向此时的头结点r=C。 –逆序归并123456789101112131415161718192021222324252627282930313233343536373839404142void mergeR(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *s; C=A; C-&gt;next=NULL; free(B); while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; else &#123; s=q; q=q-&gt;next; s-&gt;nexr=C-&gt;next; c-&gt;next=s; &#125; while(p!=NULL) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; while(q!=NULL) &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; &#125;&#125; 用头插法的形式重新进行归并，这样就得到了逆序。在一个链表的元素全部取完之后，逆序的话剩余的元素就不能直接修改指针了，要用循环将剩余的元素一个一个的以头插法的形式插入到新链表中。 划分问题：取什么数作为树轴，这个数的大小是关键，这个数的由来不是关键。1：以数组中的第一个元素为树轴，左边的元素为小于树轴的元素，右边的元素为大于树轴的元素。1234567891011121314151617181920212223242526void partition(int arr[],int n)&#123; int temp; int i=0;j=n-1; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 2：以任意一个数作为树轴，左边的元素为小于树轴的元素，右边的元素为大于树轴的元素。1234567891011121314151617181920212223242526void partition(int arr[],int n,int comp)&#123; int temp; int i=0;j=n-1; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=comp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;comp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 这里i和j共同指向的还是temp，comp只是一个比较大小的标准，comp都不一定是数组中存在的元素。理解最前面的黑体字就懂这个类型了。3：以数组元素中的任意一个元素作为树轴，左边小于树轴，右边大于树轴。 1234567891011121314151617181920212223242526272829void partition(int arr[],int n ,int k)&#123; int temp; int i=0;j=n-1; temp=arr[0]; //区别就在这三句话，1 arr[0]=arr[k]; //2 arr[k]=temp; //3 temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 将这个数组中k位置的值直接放在数组中的第一个位置那就行。之所以放在第一个那，只是后面的代码和第一种情况的一个统一，更方便的去操作。","link":"/2018/08/03/xianxingbiao-prac1/"},{"title":"tcp协议概念辨析","text":"之前学的网络这块的知识感觉都忘得差不多了，加之网络本来也比较理论抽象的。。。概念都有点模糊了。。趁复习之余就整理一下~暂时先准备从几个方面谈一下tcp协议吧。。。这个太多了，一点一点写吧~想到再加。 主要从：特点，握手协议，arq协议，流量控制，拥塞控制，可靠传输的原理等方面去谈起。首先： tcp协议的特点:(这里只主要讲解tcp是面向字节流的这一特点) 首先tcp是面向连接的。在使用tcp协议之前一定要先建立tcp连接，传输数据完毕之后也要释放tcp的连接。 每一条tcp的连接只能有两个端点，每一个tcp的连接都是点对点的连接。 tcp连接是可靠交付的连接。目的是无差错，不丢失，不重复。 tcp提供全双工通信。tcp的两端都设有“接收缓存”和“发送缓存”，在发送时，应用程序把数据传送给tcp的缓存后就可以去做自己的事情，tcp在合适的时间再从缓存中去取自己需要的数据发送出去。在接收时，tcp将收到的数据放入缓存，上层的应用在合适的时间从缓存中取走自己需要的数据就好。 tcp是面向字节流的。这里详细讲一下“字节流”和“tcp报文段”的区别与联系。“tcp传送数据的单元是“tcp报文段””，这句话的意思准确来说是：tcp与应用进程在交互的时候的数据单元是“报文段”。从某种方面上来说字节流组成相应的报文段。应用程序和tcp进行交互的时候是按照一段一段的“报文段”，但是，tcp自身在接收到后，在处理这些“报文段”的时候是又将其分成一个一个的“字节流”去发送的。tcp不关心应用进程一次把多长的“报文段”发送到tcp的缓存中，他会将其分成更小的“字节流”，根据对方的窗口值和网络拥塞情况去决定选择多少“字节流”组成“报文段”再发送出去。（udp则是进程发送了多大的报文段他就传送多大的报文段）。再啰嗦一句，tcp和应用进程在接收和发送的时候都是以“报文段”为传送的数据单元，而tcp自己在处理这些“报文段”的时候，又会将其分成“字节”，整体上看就有了所谓的“字节流”，所以，“字节流”是tcp自身在处理时的数据单元。 tcp的三次握手：（这里依然一样，不讲解主要的细节流程，只讲解为什么要三次握手，为什么不是两次握手，四次握手？） （图片来源：Michael Kerrisk） 这里，在客户机（client）收到服务器(server)发送的确认报文段后（SYN N,ACK M+1）,客户机还需要再发送一条确认报文段。为什么要再发送一条？假定之前，客户机向服务器发送一条请求报文段1（SYN M），由于某种原因这条请求报文段1没有及时送达，服务器自然就不会发送确认报文段，这时，客户机就会重新发送一条请求报文段2，后来成功建立了连接。但是，再重新建立连接后，假定之前发送的请求报文段1突然又成功的传到了服务器那里，那么服务器会误认为是客户机给他发送的请求报文段，这时他就会发送一个确认报文段给客户机，而客户机是不会响应这个确认报文段的（因为这个确认报文段是由先前认为他已经丢失的请求报文段1的回应），客户机还是会自己干自己的事情，而服务器却在那等待着客户机传送报文段。浪费了服务器的资源。 考完试了更新一下网络中的各个数据报的结构吧，嗯。。挖个坑。","link":"/2018/03/15/tcp-introduction/"},{"title":"data-structure———查找","text":"注意一下有一个概念：平均查找长度：ASL 顺序查找：举例如果从一个无序数组a（数组下标从1开始）中找到值为k的元素，查找成功就返回1，不成功就返回0，采用顺序查找的话：12345678int Search(int a[] ,int n ,int k)&#123; int i ; for(i=1;i&lt;=n;i++) if(a[i]==k) return 1; return 0;&#125; 以上是使用顺序表的时候的情况，下面再看一下链式结构的情况：1234567891011LNode* search(LNode* head,int key)&#123; LNode* p = head-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==key) return p; p=p-&gt;next; //注意一下 &#125; return 0; //注意一下这个没有找到所要值得情况的位置&#125; 一个是使用循环递增i数组下标，还有一个是使用p=p-&gt;next，一个一个的顺序访问。折半查找：折半查找的要求是表中记录是按关键字有序的。用到的是递归的思想。123456789101112131415int Bsearch(int R[],int low,int high,int k)&#123; int mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(R[mid]==k) return mid; else if(R[mid]&gt;k) high=mid-1; else if(R[mid]&lt;k) low=mid+1; &#125; return 0;&#125; 这里的low，high，mid是下标，不是值的大小分块查找： 索引表：12345678typedef struct //索引表结构体&#123; int key; //存放这个表中的最大的关键字 int low,high; //存放这个块中的第一个和最后一个元素的位置&#125;indexElem;indexElem index[maxsize]; //定义索引表 查找过程是先使用二分查找法找到带查找元素在哪一个块中，然后在块中使用顺序查找就好，因为在一个块中的元素的个数就已经很少了。 二叉排序树和平衡二叉树： 二叉排序树的定义： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 二叉排序树的存储结构：采用二叉链表存储123456typedef struct BTNode&#123; int key; struct BTNode *rchild; struct BTNode *lchild;&#125;BTNode; 二叉排序树中查找关键字的算法：1234567891011121314BTNode *BSTSearch(BTNode *bt,int key)&#123; if(bt==NULL) return NULL; else &#123; if(bt-&gt;key==key) return bt; else if(key&lt;bt-&gt;key) return BSTSearch(bt-&gt;lChild,key); else if(key&gt;bt-&gt;key) return BSTSearch(bt-&gt;rchild,key); &#125;&#125; 可以看到这里的查找的过程和折半查找的过程非常相似，其实，实质上折半查找（判定树是二叉排序树）就是二叉排序树的查找过程。 二叉树的插入关键字的算法：1234567891011121314151617181920int BSTInsert(BTNode *&amp;bt,int key)&#123; if(bt==NULL) //对应的是空树的情况 &#123; bt=(BTNode *)malloc(sizeof(BTNode)); bt-&gt;rchild=NULL; bt-&gt;lchild=NULL; bt-&gt;key=key; return 1; &#125; else &#123; if(bt-&gt;key==key) //对应的是待插入的值已经在树中 return 0; else if(bt-&gt;key&gt;key) //这里往后就很像查找算法 return BSTInsert(lchild,key); else return BSTInsert(rChild,key); &#125;&#125; 不管什么情况，插入关键字都是在新创建的结点上，最后的递归处理对应的是，找到合适的插入的位置，一层一层的递归，最后还是会创建新结点，将要插入的值插入到新创建的结点处。 二叉树的构造算法：假设所要构造的值都已经存储在了数组中1234567void CreateBST(BTNode *&amp;bt,int key[],int n)&#123; int i; bt=NULL; //将树置空 for(i=0,i&lt;n,i++) BSTInsert(bt,key[i]);&#125; 这里使用了上面的插入算法。","link":"/2018/09/16/search-1/"},{"title":"css小笔记","text":"唤醒记忆三部曲——css(Cascading Style Sheets) css简单介绍： 众所周知，css是帮助人们将文档信息的内容和如何展现它的细节相分离。以便人们更好的处理文档的“内容”和“样式”。 那么浏览器是怎么处理标志语言和css的呢？ 浏览器首先将标记语言和css转换成dom（文档对象模型）结构。之后，浏览器将dom的内容展现出来。 这里再讲一下dom结构和标记语言中的元素的区别：首先，我们可以将标记语言如html中的&lt;p&gt;标签称为“元素”。这里的元素可以允许我们把它作为一个容器去存储信息： 12345&lt;p&gt; &lt;strong&gt;C&lt;/strong&gt;ascading &lt;strong&gt;S&lt;/strong&gt;tyle &lt;strong&gt;S&lt;/strong&gt;heets&lt;/p&gt; 这里就用&lt;p&gt;和&lt;/p&gt; 构造了一个容器。而dom结构是一个树形结构，每个元素和非空文本都可以看做是树形结构上的一个结点。dom不再是一个容器，但是，它可以看做为子节点的父节点而存在。可以看： P ├─STRONG │ └─&quot;C&quot; ├─&quot;ascading&quot; ├─STRONG │ └─&quot;S&quot; ├─&quot;tyle&quot; ├─STRONG │ └─&quot;S&quot; └─&quot;heets&quot; 针对上面的html标记语言，dom模型可以这样去理解其结构。 层叠和继承: 一个元素的样式，有很多种定义的方式，对于层叠来说，主要有三种样式的来源： 浏览器对HTML定义的默认样式 用户定义的样式 开发者定义的样式：1、定义在外部文件（外链样式）2、在页面的头部定义（内联样式）3、定义在特定的元素身上（行内样式） 他们之间的优先级是：浏览器默认定义&lt;用户定义&lt;开发者定义。我们这里主要是针对于开发者定义。css还提供了使用!important关键字，使关键字处的样式立马成为最高级别的优先级。 选择器: 元素选择器 请看下面这个例子： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;a&lt;/div&gt; &lt;p&gt;b&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这里是一段html的代码，我在body中分别写了两个标签，然后请看index.css代码： 123div &#123; color: red;&#125; index.css中，这个代码的意思是以&lt;div&gt;标签为选择器，括号中是对其进行的申明（declaration），其中的color是“属性”，red是对应的“值”。&lt;div&gt;标签中的a就会被变为红色。如果想同时选择多个标签作为选择器，那么他么之间只需要加一个英文的逗号即可。这种以标签类型作为选择条件的方法我们就称为类型选择器。 类选择器（class selectors） 类选择器主要是通过设置元素的class属性，然后通过“类”（class）对其进行选择，请看： 1234567891011!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;a&lt;/div&gt; &lt;p class=\"afv\"&gt;bab&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这里我们将&lt;p&gt;标签添加了class=&quot;afv&quot;这个“类”，然后请看index.css代码： 123.afv &#123; color: red;&#125; 这里我们通过.afv这样的格式，选定了有类为afv的元素，然后就可以将bab变为了红色。注意，其中的&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;这句话的意思是链接一个名为index的外部样式表，这句话不能省略。如果，同时定义两个类，那么类之间需要添加一个空格就好： 123...&lt;p class=\"afv xcs\"&gt;... 此时想要选择同时有afv和xcs的类时，index.css就可以这样： 123.afv.xcs &#123; color: red;&#125; 如果在定义类时是这样的：（span是用来组合文档中的行内元素） 123&lt;p class=\"afv\"&gt; &lt;span class=\"xcs\"&gt;&lt;/span&gt;&lt;/p&gt; index.css文件就要这样 123.afv .xcs &#123; font-weight:bolder;&#125; 在两个属性之间要有一个空格。 id选择器 一般id选择器只用于页面中的唯一的元素，例如： 1&lt;p id=\"principal\"&gt;logo&lt;/p&gt; 在index.css文件中这样来选择： 123#principal &#123; color:bolder; &#125; 属性选择器 例如此段代码： 123&lt;body&gt; &lt;button title=\"提交此文件\"&gt;提交&lt;/button&gt;&lt;/body&gt; 可以通过属性“title”去选择：看index.css文件： 123[title] &#123; color: blue;&#125; 此时就可以将含有title元素的button的字体“提交”改为了蓝色。如果我们想特定的选择属性值为xx的，可以直接这样书写： 123[title=\"提交此文件\"] &#123; color: blue;&#125; 这样选择控制就更加的精确。 如果，index.css文件是这样： 123[title*=\"提交\"] &#123; color: blue;&#125; 这个的意思是选择只要属性中包含“提交”两字的所有元素。上面的直接等号是指完全匹配，注意区分。 如果，index.css文件是这样的： 123[title^=\"提交\"] &#123; color: blue;&#125; 这里的意思是选择那些元素中包含“提交”两字的，且必须是以“提交”两字开头的元素。 如果想选择以“提交”两个字结束的元素，那么可以这样： 123[title$=\"提交\"] &#123; color: blue;&#125; 如果想选择特定标签的特定属性的元素，那么可以这样： 123a[title] &#123; color: blue;&#125; 后代选择器 例如看下面这个例子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"a\"&gt;a &lt;div class=\"b\"&gt;b &lt;div class=\"c\"&gt;c &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里嵌套了三个div标签，然后请看asd.css：123.a .b .c &#123; border: 2px solid black;&#125; 这里因为我们是对“类”进行选择，所以要加一个点号，这里.a .b .c（.a前面没有空格）的意思是在a的下面去找b再在b的下面去找c，中间用空格去隔开。也可以.a .c依然可以定位到类c，所以说，只要类a下面有类c就可以。也可以.a *（.a和*之间有空格）选择类a下面的所有类，以此类推。总的来说，注意他们之间的嵌套关系，使用空格，*号去操作就可以，要灵活使用。 相邻选择器 例如请看： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"a\"&gt;a&lt;/div&gt; &lt;div class=\"b\"&gt;b&lt;/div&gt; &lt;div class=\"c\"&gt;c&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里有三个并行的div标签。然后我们可以这样对其选择： 123.a + div &#123; background: rgba(220,0,0,.4);&#125; 这里因为我们是选择类a，所有要加一个点号，然后使用+号，意思是选择类a的相邻的（准确的来说是选择类a下面的一个，因为相邻选择器只会至下选择）一个div标签。如果想要选择类a下面的所有的标签，可以这样： 123.a ~ div &#123; background: rgba(220,0,0,.4);&#125; 当然上面两个中的div都可以直接写成.b这里之所以写.div就是假如类a的弟弟没有“类”呢。也当然，我也可以直接写.b直接选择到了类b的元素，这里之所以这样写只是为了说明相邻选择器的工作方式，不要误会~~ 伪类选择器 同样看例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://google.com\"&gt;google&lt;/a&gt; &lt;input type=\"text\"&gt; &lt;button&gt;进入&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 这里分别有一个链接，一个输入框，一个按钮，接着看asd.css： 12345678910111213141516171819a:link &#123; color: red;&#125;a:visited &#123; color: blue;&#125;button:hover &#123; background: #fff;&#125;button:active &#123; background: #111;&#125;input:focus &#123; outline: none;&#125; 这里第1行是选择a标签，且网址链接没有点击的话就显示为红色，第5行的意思是如果网址被点击过，那么就显示为蓝色。第8行是选择button标签，hover的作用是在鼠标悬停在按钮上时的效果，这里为背景色为#fff。hover同样可以在&lt;a&gt;标签中使用。button:active的作用是设置按钮在被触发时候的效果。input:focus的作用是设置选定输入框时的效果。这里只例举了几个常用的伪类选择器。 伪元素选择器 直接看例子：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;a class=\"comm\"&gt;查看目录&lt;/a&gt; &lt;a class=\"comm\"&gt;查看目录&lt;/a&gt; &lt;p&gt;i love learning css! &lt;/p&gt; &lt;div&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt; &lt;/div&gt; &lt;/html&gt; 这里写了两个链接，一个段落，一个div里面有三个p标签，现在使用伪元素选择器对其进行修改： 12345678910111213141516171819202122232425p:first-letter &#123; font-size: 25px;&#125;.comm:before &#123; content: \"-\"; color: blue;&#125;.comm:after &#123; content: \"@\"; color: red;&#125;div p:first-child &#123; color: blue;&#125;div p:last-child &#123; color: red;&#125;div p:nth-child(2) &#123; color: green;&#125; 这里第1-3行的意思是选择p标签且对他的第一个字母改变字体大小，使用first-letter。第5-8行分别是选择了类comm，所以要加一个点号，接着使用before在其前面添加了一个-，第10-13行一个意思，只是是在最后加。（这里使用了content，一般css只对样式进行修改，不会改变其中的内容，而这里是为数不多的css中增加了内容的用法，注意）第15-17行，是先选择div标签后再选择p标签，后对其中的“第一个孩子”进行修改。第19-21行是对“最后一个孩子”，第23-25是通过传值来指定选择“哪一个孩子”。不难类推。","link":"/2018/03/21/css-learning/"},{"title":"data structure——线性表","text":"顺序表定义： 123456#define maxsize 100typedef struct&#123; int data[maxsize]; int length;&#125;sqList; 或者可以这样：12int A[maxsize];int n; 单链表结点定义：12345typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode; 双链表结点定义： 123456typedef struct DLNode&#123; int data; struct DLNode *prior; struct DLNode *next; &#125;DLNode; 下面说几个例题，以说明顺序表的操作： 1.已知一个顺序表L其中元素为递增有序排列，先插入一个元素x使其仍为递增有序排列： 123456789101112131415161718192021222324252627#define maxsize 100int L[maxsize];int n;int findElem(sqList L,int x)&#123; int i; for (i=0;i&lt;L.length;++i) &#123; if(x&lt;L.data[i]) &#123; return i; &#125; &#125; return i;&#125;void insertElem(sqList &amp;L,int x)&#123; int p,i; p=findElem(L,x); for(i=L.length-1;i&gt;=p;--i) L.data[i+1]=L.data[i]; L.data[p]=x; ++(L.length);&#125; 其中findElem函数是返回这个递增顺序表中第一个比他大的元素的地址，最后一句return i是在顺序表所有的元素都比他小的情况下，此时for循环不满足条件退了出来，而此时对应的元素的地址刚好是最后一个元素的位置。insertElem函数是将找到的位置后面的元素，将元素往右移动，这里L因为本身是要改变，所以用了引用型。函数里面的for循环是从最右边往左一个一个的右移。 2.删除顺序表L中下标为p的元素，成功返回1，不成功返回0并将被删除元素的值赋给e 1234567891011int deleteElem(sqlist &amp;L,int p,int &amp;e)&#123; int i; if(p&lt;0||p&gt;L.length-1) return 0; e=L.data[p]; for (i=p;i&lt;L.length;++i) L.data[i]=L.data[i+1]; --(L.length); return 1; &#125; 这里是删除一个下标为p的元素，只要直接将p下标之后的元素，从左往右一个一个的覆盖即可。 实例1和实例2，主要就讲了顺序表中最基本的操作：查找，插入，删除。 还有初始化顺序表和求指定位置元素的算法： 1234void initList(sqList &amp;L)&#123; L.length=o;&#125; 1234567int getElem(sqlist L,int p,int &amp;e)&#123; if(p&lt;0||p&gt;L.length-1) return 0; e=L.data[p]; return 1;&#125; 下面通过一个实例来说明一下单链表的操作： 例：A和B是两个带头结点的单链表，其中元素递增有序，设计一个算法，将A和B归并成一个按元素值非递减有序的链表C。 12345678910111213141516171819202122232425262728void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *r; C=A; C-&gt;next=NULL; free(B); r=C; while (p!=NULL&amp;&amp;q!=NULL) &#123; if (p-&gt;data&lt;=q-&gt;data) &#123; r-&gt;next=p;p=p-&gt;next; r=r-&gt;next; &#125; else &#123; r-&gt;next=q;q=q-&gt;next; r=r-&gt;next; &#125; &#125; r-&gt;next=NULL; if(p!=NULL) r-&gt;next=p; if(q!=NULL) r-&gt;next=q;&#125; 这个实例的主要方法是，首先先创建一个新的单链表C，C的头结点使用A链表的头结点，再用新的指针C指向他。B链表的指针的头结点就没什么用了就free B，接着使用一个if判断，将A，B中的元素的大小进行比较，将小的那个插入到C链表中（A,B单链表是递增有序的）。最后再用一个if判断，将如果一方有剩余的元素的单链表全部插入到C链表中，注意，剩余的插入C链表中，只需要将前面的一个指针链接到C链表后面即可，因为剩余的那个链表后面已经链接好了，不需要再用for循环一个一个的将其断开再链接上去。 这个实例中用了尾插法创建了一个链表，下面对创建链表的方法做一个总结：尾插法：12345678910111213141516void createlistR(LNode *&amp;C,int a[],int n)&#123; LNode *s,*r; int i; C=(LNode *)malloc(sizeof(LNode)); C-&gt;next=NULL; r=C; for (i=0;i&lt;n;++i) &#123; s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=a[i]; r-next=s; r=r-&gt;next; &#125; r-&gt;next=NULL;&#125; 头插法：1234567891011121314void createlistF(LNode *&amp;C,int a[],int n)&#123; LNode *s; int i; C=(LNode*)malloc(sizeof(LNode)); c-&gt;next=NULL; for(i=0;i&lt;n;++i) &#123; s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=a[i]; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125;&#125; 如上面的实例中如果需要输出的是一个递减的链表C，那么我们就可以使用头插法来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *s; C=A; C-&gt;next=NULL; free(B); while (p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; s=p; p=p-next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; else &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; c-&gt;next=s; &#125; &#125; while(p!=NULL) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; while(q!=NULL) &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; &#125; 头插法的原理图可见：图片来源：https://www.jianshu.com/p/8613ea20dd19 请再看一下个实例：查找链表C中是否存在一个值为x的结点，如果存在则删除该结点并返回1，否则返回0。 1234567891011121314151617181920212223void findAndDelete(LNode *C,int x)&#123; LNode *p ,*q; p=C; while(p-&gt;next!=NULL) &#123; if(p-&gt;next-&gt;data==x) break; p=p-&gt;next; &#125; while(p-&gt;next=NULL) &#123; return 0; &#125; else &#123; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); return 1; &#125;&#125; 注意，这里的p指针，我们是要他停在要删除结点的前驱结点处，而不是直接指向要删除的结点。 双链表：使用尾插法建立:1234567891011121314151617void createDlistR(DLNode *&amp;L,int a[], int n)&#123; DLNode *s,*r; int i; L=(DLNode *)malloc(sizeof(DLNode)); L-&gt;prior=NULL; L-&gt;next=NULL; r=L; for(i=0;i&lt;n;++i) &#123; s=(DLNode *)malloc(sizeof(DLNode)); s-&gt;data=a[i]; r-&gt;next=s; s-&gt;prior=r; r=s; &#125; r-&gt;next=NULL; 查找结点：查找值为x的结点，找到就返回结点指针，否则返回NULL。1234567891011DLNode* findNode(DLNode *C,int x)&#123; DLNode *p=C-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==x) break; p=p-&gt;next; &#125; return p;&#125; 插入一个结点的操作：1234s-&gt;next=p-&gt;next;s-&gt;prior=p;p-&gt;next-&gt;prior=s;p-&gt;next=s; 删除p结点的后继结点：1234q=p-&gt;next;p-&gt;next=q-&gt;next;q-&gt;next-&gt;prior=p;free(q); 下面是例题：1.设顺序表用数组A[]表示，表中元素存储在数组下标0~m+n-1的范围内，前m个元素递增有序，后n个元素也递增有序，设计一个算法，使得整个顺序表都递增有序。1234567891011121314void insertElem(int A[], int m, int n)&#123; int i,j; int temp; for(i=m;i&lt;m+n;++i) &#123; temp=A[i]; for(j=i-1;j&gt;=0&amp;&amp;temp&lt;A[j];--j) &#123; A[j+1]=A[j]; &#125; A[j+1]=temp; //因为for循环多移了一位，所以要j+1 &#125;&#125; 2.已知递增有序的单链表A,B（个数分别为m,n，且都有头结点）分别存储了一个集合，请设计一份个算法将两个集合的差集(即在A中出现而不在B中)保存在A中，并保持元素递增有序。12345678910111213141516171819202122232425262728void diffence(LNode *A LNode *B)&#123; LNode *p=A-&gt;next; LNode *pre=A; LNode *q=B-&gt;next; LNode *r; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;q-&gt;data) &#123; pre=p; p=p-&gt;next; &#125; else if(p-&gt;data&gt;q-&gt;data) &#123; q=q-&gt;next; &#125; else &#123; pre-&gt;enxt=p-&gt;next; r=p; p=p-&gt;next; free(r); &#125; &#125;&#125; 3.设计一个算法，将顺序表中的元素逆置 123456789101112viod reverse(sqlist &amp;L)&#123; int i; int j; int temp; for(i=0,j=L.length-1;i&lt;j;++i,j--) //i&lt;j,不能大于也不能等于 &#123; temp=L.data[i]; L.data[i]=L.data[j]; L.data[j]=temp; &#125;&#125; 4.从一个给定顺序表L中删除下标i~j的所有元素。（假定i和j都合法） 12345678910void delete(sqlist *L,int i,int j)&#123; int k,delta; delta=j-i+1; for(k=j+1;k&lt;L.length-1,++k) &#123; L.data[delta]=L.data[k]; &#125; L.length=L.length-delta; &#125; 此题主要是用第j+1即往后的元素覆盖到i~j之间的元素，这里，如果j+1往后的元素没有I~j之间的元素个数多也不要紧，不要认为就没有”删除”完i~j之间的元素，因为L.length=L.length-delta就已经限定了表长，后面就算有元素也不是表内元素了。 5.一个顺序表L，元素为整型，设计一个算法将比L的表头元素小的元素放在其左边，将比他大的元素放在右边。 12345678910111213141516171819202122232425262728void move(sqlist &amp;L)&#123; int temp; int i=0; int j=L.length-1; temp=L.data[i] while(i&lt;j) &#123; while(i&lt;j&amp;&amp;L.data[j]&gt;temp) --j; if(i&lt;j) &#123; L.data[i]=L.data[j]; ++i; &#125; while(i&lt;j&amp;&amp;L.data[i]&lt;temp) ++i; if(i&lt;j) &#123; L.data[j]=L.data[j]; --j; &#125; &#125; L.data[i]=temp;&#125; 此题需要好好的理解一下，主要是要知道，i和j是轮流移动的，不是同时移动的，这样就能够保证，在交换的时候不会造成元素丢失，因为他们是轮流着来移动，所以在交换元素之前，这个元素肯定已经存入到了其他的位置了。 6.将一个递增非空单链表中的相同值域的元素删除。 123456789101112131415161718192021222324252627void deletesil(LNode *L)&#123; LNode *p=L-&gt;next; LNode *q=L-&gt;next-&gt;next; *r; while(q!=NULL) &#123; while(q!=NULL&amp;&amp;q-&gt;data=p-&gt;data) &#123; q=q-&gt;next; &#125; if (q!=NULL) &#123; p=p-&gt;next; p-&gt;data=q-&gt;data; &#125; q=p-&gt;next; p-&gt;next=NULL; while(q!=NULL) //这里有点不理解。。。。 &#123; r=q; q=q-&gt;next; free(r); &#125; &#125;&#125; 7.删除一个单链表L中的最小值结点。1234567891011121314151617181920void deletesmall(LNode &amp;L)&#123; LNode *p=L-&gt;next; LNode *ppre=L; LNode *qpre=L; LNode *q=L-&gt;next; while(q!=NULL) &#123; if(q-&gt;data&lt;p-&gt;data) &#123; p=q; ppre=qpre; &#125; qpre=q; q=q-&gt;next; &#125; ppre-&gt;next=p-&gt;next; free(p);&#125; 此代码中，之所以要对p再使用一个前驱指针ppre，以及对q也使用了一个前驱指针qpre的原因是通过这前驱指针分别“记住”原来p和q指针的位置在哪。p指针用来指定最小值的位置，q指针则用来向前进，使元素一个一个的与目前p指针所指定的最小值作比较。 8.有一个线性表，采用带头结点的单链表L来存储。设计一个算法将其逆置。要求不能建立新结点，只能通过表中已有的结点的重新组合来完成。 12345678910111213void reversel(LNode *L)&#123; LNode *p=L-&gt;next; LNode *q; L-&gt;next=NULL; while(p!=NULL) &#123; q=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=q; &#125;&#125; 9.设计一个算法，将一个带头结点为A的单链表分解为两个单链表A和B，A链表中含有原来链表中data域中为奇数的结点，B链表中含有原来链表中data域中为偶数的结点。且保持相对位置不变。 12345678910111213141516171819202122void seletejiandou(LNode *A,LNode *&amp;B)&#123; LNode *p,*q,*r; B=(LNode*)malloc(sizeof(LNode)); B-&gt;next=NULL; r=B; p=A; while(p-&gt;next!=NULL) &#123; if(p-&gt;next-&gt;data%2==0) &#123; q=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=NULL; r-&gt;next=q; r=q; &#125; else p=p-&gt;next; &#125;&#125; 10.写出一个函数，逆序打印单链表中的数据，假设指针L指针指向了单链表的开始结点。12345678void reprint(LNode *L)&#123; if(L!=NULL) &#123; reprint(L-&gt;next); //递归逆序打印开始结点的后面的数据 cout&lt;&lt;L-&gt;data&lt;&lt;\" \"; &#125;&#125; 11.编写一个函数，以不多于3n/2的平均比较次数，找出在一个n个整数的顺序表A中的最大值和最小值。 123456789101112void searchmaxandmin(int A[], int n,int &amp;max,&amp;min)&#123; max=min=A[1]; for(int i=2,i&lt;=n,++i) &#123; if(A[i]&gt;max) max=A[i]; else if(A[i]&lt;min) min=A[i]; &#125;&#125; 12.假设一个链表只有一个头指针head，设计一个算法，查找链表中倒数第k个位置上的结点，查找成功就返回data值，且返回1，若不成功就返回0。 1234567891011121314151617181920int findElem(LNode *head,int k)&#123; p1=head-&gt;next; p=head; i=1; while (p1!=NULL) &#123; p1=p1-&gt;next; ++i; if(i&gt;k) p=p-&gt;next; &#125; if (p==head) return 0; else &#123; count&lt;&lt;p-&gt;data; return 1; &#125;&#125; 13.设将n个整数存放在一维数组R中，设计一个尽可能高效的算法将R中保存的序列循环左移P个位置。 1234567891011121314151617181920212223void reverse(int R[],int l,int r)&#123; int i,j; int temp; for (i=l,j=r,i&lt;j,++i,--j) &#123; temp=R[i]; R[i]=R[j]; R[j]=temp; &#125; &#125;void RCR(int R[],int n,int p)&#123; if(p&lt;0||p&gt;n) cout&lt;&lt;\"Error\"&lt;&lt;endl; else &#123; reverse(R,0,p-1); //先将前p个逆置 reverse(R,p,n-1); //接着将剩下的逆置 reverse(R,0,n-1); //最后将所有的一起再逆置一下 &#125;&#125; 14.已知一个整数序列A(a0,a1,a2,..ai..,an-1)其中0&lt;=ai&lt;n(0&lt;=i&lt;n).如果其中有超过一半的元素的值相同，那么这个相同的值就称之为”主元素”。假设A中的n个元素保存在一个一维数组中，设计一个算法，找出A中的主元素，如果有则输出他，如果没有就输出为-1。 123456789101112131415161718192021222324252627282930313233int majority(int A[],int n)&#123; int i ,c, count=1; c=A[0]; for (i=1,i&lt;n,i++) if(A[i]==c) count++; else &#123; if(count&gt;0) count--; else &#123; c=A[i]; count=1; &#125; &#125; if(count&gt;0) &#123; for(i=count=0,i&lt;n,i++) &#123; if(A[i]==c) count++; &#125; &#125; if(count&gt;n/2) return c; else return -1; &#125;","link":"/2018/04/06/data-structure-2/"},{"title":"data structure——栈和队列","text":"栈和队列的特点是：栈(stack)是先进后出，而队列是先进先出。 栈的不同形式的定义： 顺序栈的定义： 12345typedef struct&#123; int data[maxsize]; //存放栈中元素 int top; //注意这是栈顶指针，这个指针是用来指数组中的元素的，不是在结点中的指针域&#125; 链栈结点定义：(即用链表来存储栈) 12345typedef struct LNode&#123; int data; //数据域 struct LNode *next; //指针域&#125;LNode; 顺序栈的一些操作： 初始化栈1234void initStack(SqStack &amp;st)&#123; st.top=-1; //栈顶指针设置为-1&#125; 或者可以简写：int stack[maxsize-1];int top==-1; 判断栈空 1234567int isEmpty(SqStack st)&#123; if(st.top==maxsize-1) return 1; else return 0;&#125; 进栈 12345678int push(SqStack &amp;st,int x)&#123; if(st.top==-1) return 0; ++(st.top); st.data[st.top]=x; return 1;&#125; 或者也可以简写：stack[++top]=x; 出栈12345678int pop(SqStack &amp;st, int x)&#123; if(st.top==-1) return 0; x=st.data[st.top]; --(st.top); return 1;&#125; 或者也可以简写：x=stack[top--]; 链栈的一些操作: 初始化链栈 12345void initStack(LNode *&amp;lst)&#123; lst=(LNode* )malloc(sizeof(LNode)); //制造一个头结点 lst-&gt;next=NULL;&#125; 判断栈空 1234567int isEmpty(LNode *lst)&#123; if(lst-&gt;next=NULL) return 0; else return 1;&#125; 进栈操作 123456789void push(LNode *lst,int x)&#123; LNode *p; p=(LNode *)malloc(sizeof(LNode)); p-&gt;next=NULL; p-&gt;data=x; p-&gt;next=lst-&gt;next; lst-&gt;next=p;&#125; 出栈操作 1234567891011void pop(LNode *lst, int &amp;x)&#123; LNode *p; if(lst-&gt;next==NULL) return 0; p-&gt;next=lst-&gt;next; p-&gt;data=x; lst-&gt;next=p-&gt;next; free(p); return 1;&#125; 队列的不同形式的定义： 顺序队列的定义： 123456typedef struct&#123; int data[maxsize]; //用一个数组存储数据 int front; //队首指针 int rear; //队尾指针&#125;sqQueue; 链队定义：队结点类型定义： 12345typedef struct QNode&#123; int data; //数据域 struct QNode *next; //指针域&#125;QNode; 链队类型定义： 12345typedef struct&#123; QNode *front; //队头指针 QNode *rear; //队尾指针&#125;LiQueue; 循环队列的一些操作: 初始化 1234void initQueue(SqQueue &amp;qu)&#123; qu.front=qu.rear=0;&#125; 判断队空： 1234567void isQueueEmpty(sqQueue qu)&#123; if(qu.rear=qu.front) return 1; else return 0;&#125; 进队： 1234567891011void enQueue(sqQueue &amp;qu,int x)&#123; if((qu.rear+1)%maxsize==qu.front) return 0; else &#123; qu.rear=(qu.rear+1)%maxsize; qu.data[qu.rear]=x; return 1; &#125;&#125; 出队： 1234567891011void deQueue(sqQueue &amp;qu,int x)&#123; if(qu.front==qu.rear) return 0; else &#123; qu.front=(qu.front+1)%maxsize; x=qu.data[qu.front]; return 1; &#125;&#125; 链队的一些操作： 初始化 12345void initQueue(LiQueue *&amp;lqu)&#123; lqu=(LiQueue *)malloc(sizeof(LiQueue)); lqu-&gt;front=lqu-&gt;rear=NULL;&#125; 判断队空 1234567int isQueueEmpty(LiQueue *lqu)&#123; if(lqu-&gt;front==NULL||lqu-&gt;rear==NULL) return 1; else return 0;&#125; 入队 123456789101112131415void enQueue(LiQueue *lqu,int x)&#123; QNode *p; //指针p是另一个结构体而来的 p=(QNode *)malloc(sizeof(QNode)); p-&gt;data=x; p-&gt;next=NULL; if(lqu-&gt;rear==NULL) lqu-&gt;front=lqu-&gt;rear=p; else &#123; lqu-&gt;rear-&gt;next=p; //将新节点连接至队尾，rear指向它 lqu-&gt;rear=p; &#125;&#125; 出队 123456789101112131415void deQueue(LiQueue *lqu ,int &amp;x)&#123; QNode *p; if(lst-&gt;rear=NULL) return 0; else p=lst-&gt;front; if (lqu-&gt;front==lqu-&gt;rear) lqu-&gt;front=lqu-&gt;rear==NULL; else lqu-&gt;front=lqu-&gt;front-&gt;next; x=p-&gt;data; free(p); return 1;&#125; 应用 顺序栈的应用 1.设计一个算法，判断一个表达式中的括号是否正确的配对，表达式已经存入字符数组exp[]中，表达式中的字符个数是n。 12345678910111213141516171819202122int match(char exp[],int n)&#123; char stack[maxsize-1]; int top==-1; int i; for(i=0;i&lt;n;++i) &#123; if(exp[i]=='(') stack[++top]='('; if(exp[i]==')') &#123; if(top==-1) return 0; else --top; &#125; &#125; if(top==-1) return 1; else return 0;&#125; 此列题很好的说明了栈是一种有效处理”先进后出”的一种数据类型，也就是说，当以后遇到一种问题，在处理问题的过程中如果出现了一个子问题，那么先解决了这个子问题再来处理这个问题的处理思路可以使用栈这个模型去解决问题。 2.编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中，exp中最后一个字符为\\0，作为结束符，并假设后缀式中的数字都只有一位。（出现的除法的结果都按一位存储） 12345678910111213141516171819202122232425262728293031323334353637383940int jisuan(int a,char jisuan,int b)&#123; if('jisuan'='+') return a+b; if('jisuan'='-') return a-b; if('jisuan'='*') return a*b; if('jisuan'='/') &#123; if(b==0) &#123; cout&lt;&lt;\"error\"&lt;&lt;endl; return 0; &#125; else return a/b; &#125;&#125;int houzhui(char exp[])&#123; int i,a,b,c; char yunsuanfu; int stack[maxsize-1]; int top=-1; for(i=0;exp[i]!='\\0;++i) &#123; if(exp[i]&gt;='0'&amp;&amp;exp[i]&lt;='9') stack[++top]=exp[i]-'0'; else &#123; yunsuanfu=exp[i]; b=stack[top--]; a=stack[top--]; c=jisuan(a,yuansuanfu,b); stack[++top]=c; &#125; &#125; return stack[top]; //这句话有点不能理解&#125; 3.用不带头结点的单链表存储链栈，设置初始化栈，判断栈是否为空，进栈和出栈等相应的算法 123456789101112131415161718192021222324252627282930313233void initStack1(LNode *&amp;lst) //初始化栈&#123; lst=NULL;&#125;int isEmpty1(LNode *lst) //判断是否为空&#123; if (lst==NULL) return 1; else return 0;&#125;void pop1(LNode *lst,int x) //进栈&#123; LNode *p; p=(LNode *)malloc(sizeof(LNode)); p-&gt;next=NULL; p-&gt;data=x; p-&gt;next=lst; lst=p;&#125;void push1(LNode *lst,int x) //出栈&#123; LNode *p; if (lst==NULL) return 0; x=p-&gt;data; lst=p-&gt;next; free(p); return 1;&#125; 下面是例题：1.顺序栈s0和s1共享了一个存储区elem[0,1,..,maxsize-1]。是设计共享栈s0,s1以及有关共享栈的入栈和出栈操作的算法，假设元素为int型。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct //结构体定义&#123; int elem[maxsize]; int top[2]; &#125;sqstack;int push(sqstack &amp;st,int stNo,int x)&#123; if(st.top[0]+1&lt;st.top[1]) //判断是否栈满 &#123; if(stNo==0) &#123; ++(st.top[0]); st.elem[st.top[0]]=x; return 1; &#125; else if(stNo==1) &#123; --(st.top[1]); st.elem[st.top[1]]=x; return 1; &#125; return -1; //如果栈的编号既不是0也不是1的话就返回-1 &#125; else return 0;&#125;int pop(sqstack &amp;st ,int x)&#123; if(stNo==0) &#123; if(st.top[0]!=-1) &#123; x=st.elem[st.top[0]]; --(st.top[0]); return 1; &#125; else return 0; &#125; else if(stNo=1) &#123; if(st.top[1]!=maxsize) &#123; x=st.elem[st.top[1]]; ++(st.top[1]); return 1; &#125; return 0; &#125; else return -1;&#125; 2.利用两个站s1,s2来模拟一个队列，假设栈中的元素为int型，栈中元素最多为maxsize。已知栈的3个运算定义如下：push(ST,x):元素x入st栈pop(ST,&amp;x):st栈顶元素出栈，赋给元素xisEmpty(ST):判断st栈是否为空如何利用栈的运算来实现队列的3个运算，（元素入队列）enQueue,（元素出队列）deQueue,（判断栈是否为空）isQueueEmpty。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int enQueue(sqstack &amp;s1,sqstack &amp;s2,int x)&#123; int y; //这里为什么还要一个y if(s1.top==maxsize-1) &#123; if(!isEmpty(s2)) return 0; else if(isEmpty(s2)) &#123; while(!isEmpty(s1)) &#123; pop(s1,y); push(s2,y); &#125; push(s1,x); return 1; &#125; &#125; else &#123; push(s1,x); return 1; &#125;&#125;int deQueue(SqStack &amp;s2,sqstack &amp;s1,int &amp;x)&#123; int y; if(!isEmpty(s2)) &#123; pop(s2,y); return 1; &#125; else &#123; if(isEmpty(s1)) return 0; else &#123; while(!isEmpty(s1)) &#123; pop(s1,y); push(s1,y); &#125; pop(s2,x); return 1; &#125; &#125;&#125;int isQueueEmpty(sqstack s1,sqstack s2)&#123; if(isEmpty(s1)&amp;&amp;isEmpty(s2)) return 1; else return 0;&#125; 其实本题其实主要的工作是将栈的”先进后出”的特性变为”先进先出”。 3.假设一I,O分别表示入栈和出栈的操作，写出一个算法，判定给出的操作序列是否合法，若合法则返回1否则返回0假定被判定的操作序列已经存入一维数组ch[]中，操作序列以“\\0”为结束符。12345678910111213141516171819int judge(char[])&#123; int i=0; int I=0,O=0; while(ch[i]!='\\0') &#123; if(ch[i]='I') ++I; if(ch[i]='O') ++O; if(O&gt;I) return 0; ++i; &#125; if(I!=O) //判断入栈和出栈的操作次数是否相同，如果不同就不合法 return 0; else return 1;&#125; 4.假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队和出队的算法。12345678910111213141516171819202122232425void enQueue(LNode *&amp;rear,int x)&#123; LNode *s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=x; s-&gt;next=rear-&gt;next; //有疑问。。。 rear-&gt;next=s; //有疑问。。。 rear=s;&#125; void deQueue(LNode *&amp;rear,int &amp;x)&#123; LNode *s; if(rear-&gt;next==rear) return 0; else &#123; s=rear-&gt;next-&gt;next; //s指向开始结点 rear-&gt;next-&gt;next=s-&gt;next; //rear指向s指针指向的下一个结点 x=s-&gt;data; if(s==rear) rear=rear-&gt;next; free(s); return 1; &#125;&#125; 5.如果允许在循环队列的两端都可以进行插入和删除操作，要求：写出循环队列的类型定义，写出从队尾删除和从对头插入的算法。123456789101112131415161718192021222324252627282930typedef struct&#123; int data[maxsize]; int front,rear;&#125;cycqueue;int deQueue(cycqueue &amp;Q,int &amp;x) //从队尾删除&#123; if(Q.front==Q.rear) return 0; else &#123; x=Q.data[Q.rear]; Q.rear=(Q.rear-1+maxsize)%maxsize; //这里要注意一下 return 1; &#125;&#125;int enQueue(cycqueue &amp;Q,int &amp;x) //从队头插入&#123; if(Q.rear==(Q.front-1+maxsize)%maxsize) return 0; else &#123; Q.data[Q.front]=x; //约定front指针是指向队头元素的前一个位置 Q.front=(Q.front-1+maxsize)%maxsize; //所以这里是先赋值后移动front指针 return 1; &#125;&#125; 6.设计一个循环队列，用front和rear分别作为队头和队尾指针，用一个标志tag表示队列是否为空当tag为1时队不空，为0时表示为空。这样就可以用front==rear来作为队满的条件。要求设计出队列的结构和相关的基本运算（队列元素为int型）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455typedef struct&#123; int data[maxsize]; int front,rear; int tag;&#125;Queue;void initQueue(Queue &amp;qu) //初始化&#123; qu.front=qu.rear=0; qu.tag=0;&#125;int isQueueEmpty(Queue qu) //判空&#123; if(qu.front==qu.rear&amp;&amp;qu.tag==0) return 1; else return 0;&#125;int QueueFull(Queue qu) //判满&#123; if(qu.tag==1&amp;&amp;qu.front==qu.rear) return 1; else return 0;&#125;int enQueue(Queue &amp;qu,int x)&#123; if(QueueFull(qu)==1) return 0; else &#123; qu.rear=(qu.rear+1)%maxsize; qu.data[qu.rear]=x; qu.tag=1; return 1; &#125;&#125;int deQueue(Queue &amp;qu,int &amp;x)&#123; if(isQueueEmpty(qu)==1) return 0; else &#123; qu.front=(qu.front+1)%maxsize; x=qu.data[qu.front]; qu.tag=0; return 1; &#125;&#125; 7.编写一个算法，将一个非负的十进制整数N转换为一个二进制数。123456789101112131415161718int BaseTrans(int N)&#123; int i,result=0; int stack[maxsize],top=-1; while(N!=0) &#123; i=N%2; i=N/2; stack[++top]=i; &#125; while(top!=1) &#123; i=stack[top]; --top; result=result*10+i; &#125; return result;&#125; 8.试编写一个算法，检查一个程序中的花括号，方括号，小括号是否匹配，若全部匹配则返回1，否则就返回0.对于程序中出现的单引号和双引号不进行括号匹配。39为单引号的ASCII值，34为双引号ASCII值，单双引号出现必定成双出现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int pipeikuohao(char f[])&#123; stack S,char ch; char* p=f; while(p!='\\0') &#123; if(*p==39) &#123; ++p; //跳过第一个单引号 while(*p!=39) ++p; //跳过单引号中的元素 ++p; //跳过第二个单引号 &#125; else if (*p==34) &#123; ++p; //跳过第一个双引号 while(*p!=34) ++p; //跳过双引号中的元素 ++p; //跳过第二个双引号，这里要注意程序的执行流程。 &#125; else &#123; switch(*p) &#123; case '&#123;': case '[': case '(': push(S,*p); //如果是&#123;，[,(这些左括号，就入栈 break; case '&#125;': getTop(S,ch); //当遇到右括号了，读取此时的栈顶元素(getTop)， if(ch=='&#123;') //如果此时栈顶元素是相应的左括号， pop(S,ch); //就出栈 else return 0; break; case ']': getTop(S,ch); if(ch==']') pop(S.ch); else return 0; break; case ')': getTop(S,ch); if(ch==')') pop(S,ch); else return 0; &#125; ++p; &#125; &#125; if(isEmpty(S)) return 1; else return 0;&#125; var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', //改为你自己的，下同 client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/04/10/data-structure-3/"},{"title":"data structure——图","text":"图的存储结构： 图的顺序存储结构：邻接矩阵的结构型有两个数组：一个一维数组存储图中的顶点信息；一个二维数组存储图中的边或弧的信息。缺点：如果边数相对于顶点数较少，那么边数组的存储空间是一个很大的浪费。123456789101112typedef struct&#123; int no; //顶点编号 char info; //顶点的其他信息，视情况而定写不写&#125;VertexType;typedef struct //图的定义&#123; int edges[maxSize][maxSize]; //邻接矩阵定义，可看做边表 int n,e; //顶点数和边数 VertexType vex[maxSize]; //顶点表，存放结点信息&#125;MGraph; //图的邻接矩阵类型 邻接矩阵事例： 图的链式存储结构：邻接表数组与链表相结合；图中顶点用一维数组来存储（也可用单链表）；图中的每个顶点的邻接点用单链表来存储。 12345678910111213141516171819typedef struct ArcNode //边表&#123; int adjvex; //该边所指向的结点的位置，就是顶点标号 struct ArcNode *nextarc; //指向这个顶点结点的另一条边的指针 int info; //该边的相关信息&#125;ArcNode;typedef struct //顶点表&#123; char data; //顶点信息 ArcNode *firstarc; //指向第一条边的指针&#125;VNode;typedef struct &#123; VNode adjlist[maxSize]; //邻接表 int n,e; //顶点数和边数&#125;AGraph; //图的邻接表类型 邻接表事例：ArcNode是“边”（边结点）的结构体，是用点与点之间的关系来表示边的。其中的adjvex（Adjacent vertices邻接顶点的缩写）这条边所指的顶点，是顶点在数组中的下标，*next是指向下一个边结点的指针。VNode是“顶点”的结构体，AGraph是“图”的结构体，其中定义了一个VNode型的数组来储存顶点，n,e是结点数和边数。邻接表中，如果是有向图的话，邻接表是存储的是这个结点引出的边，也即“出度”，而如果存储的是指向这个结点的边，也即“入度”的话，这个存储结构就是“逆邻接表”。 有向图的十字链表存储结构 如果我们想即存储出度又存储入度呢？我们可以这样：其中的firstIn是指向入边链表中第一个结点的指针，firstOut指向第一个出边链表的指针。start是指当前边起点的数据域，end是当前边终点的数据域，nextIn指向这个顶点的下一个入边，nextOut指向这个结点的下一个出边。 这就是有向图的十字链表存储结构。 无向图的邻接多重表 我们在看到用邻接表存储无向图的时候，会出现重复存储的情况，那么我可以这样：左上方是顶点的结构体设计，右上方是边结点的结构体设计。其中的Vi是边的起点，Vj是边的终点。ViNext是表示与Vi相关的下一个边结点，VjNext是表示与Vj相关的下一个边结点。 遍历这里dfs和bfs的代码所对应的都是图的邻接表的存储方式的遍历。 深度优先遍历（DFS） 很类似于树的先序遍历算法，这里用了一个visit[]数组，设置为一个标记，如果这个结点已经访问过了就设置为1，如果没有访问过默认为0。注意：Visit函数和visit[]数组不是同一个东西，第10句中的下一个结点指的是在邻接表中当前结点的下一个结点。123456789101112void DFS(int c,AGraph *G)&#123; visit[v]=1; Visit(v); //Visit函数代表了对顶点v的访问 ArcNode* q=G-&gt;adjList[v].first; //这里是p指向顶点的第一条边 while(q!=NULL) &#123; if(visit[q-&gt;adjV]==0) //如果这个顶点没有被访问过，那么就访问他 DFS(q-&gt;adjV,G); //递归处理 q=q-&gt;next; //指向当前顶点的下一个结点 &#125;&#125; 广度优先遍历（BFS）类似于树的层次遍历，遍历过程会用到一个列表。主要过程是：取一个顶点进行访问，入队，并将这个点标记为已访问；接着，访问这个结点的下一个结点，没有访问过就访问，标记为1，入队，如此循环将邻接点都入队，p为空时就出队，然后循环对这个出队顶点的所有没有被访问过的邻接顶点进行访问，标记，入队，依次循环最后，直至出队使得队列为空，结束循环。 123456789101112131415161718192021222324252627void BFS(AGraph *G,int v,int visit[maxsize])&#123; ArcNode *p; int que[maxSize],front=0,rear=0; //创建一个队列que int j; Visit(v); //访问任意一个v结点 visit[v]=1; //标记为已访问 rear=(rear+1)%maxSize; //当前结点入队 que[rear]=v; //入队，（是将数组下标写进队列中） while(front!=rear) //如果队列不为空，就循环 &#123; front=(front+1)%maxSize; //出队 j=que[front]; p=G-&gt;adjlist[j].first; //p指向这个出队顶点j的第一条边 while(p!=NULL) //当p不空的时候, &#123; if(visit[p-&gt;adjV]==0) //如果p的邻接点没有被访问过， &#123; Visit(p-&gt;adjV); //就访问他, visit[p-&gt;adjV]=1; //接着标记为已访问， rear=(rear+1)%maxSize; //该顶点也入队 que[rear]=p-&gt;adjV; //入队 &#125; p=p-&gt;next; //访问下一条边 &#125; &#125;&#125; 最小生成树 由一个图按照某种规则导出的一个树，叫生成树。最小生成树：构成这个生成树的所有分支的权值和最小。 prime算法求最小生成树的代码：1234567891011121314151617181920212223242526272829void Prim(int n ,float MGraph[][n],int v0,float &amp;sum)//顶点个数，带权图，构造生成树的起始顶点，&#123; //存储最小权值和（代价） int lowCost[n],vSet[n]; int v,k,min; for(int i=0;i&lt;n;++i) &#123; lowCost[i]=MGraph[v0][i]; //lowCost[]指向vo初始点的同一行的不同列的顶点 vSet[i]=0; &#125; v=v0; //v指向第一个结点， vSet[v]=1; //已经并入，所以标记设置为1 sum=0; //初始化 for(int i=0;i&lt;n-1;++i) &#123; min=INF; //min初始化为无穷大 for(int j=0;j&lt;n,++j) if(vSet[j]==0&amp;&amp;lowCost[j]&lt;min) &#123; min=lowCost[j]; k=j; &#125; vSet[k]=1; v=k; //v指向如今刚进入的结点 sum+=min; //min的值累加到sum for(int j=0;j&lt;n;++j) //更新lowCost数组 if(vSet[j]==0&amp;&amp;MGraph[v][j]&lt;lowCost[j]) lowCost[j]=MGraph[v][j]; &#125;&#125; lowCost[]数组是用来存储当前生成树到图中其余顶点的边的最小权值。vSet[i]为1时就说明已经被并入生成树中，为0就没有并入。v指向刚并入的顶点。 v0是最小生成树的初始结点，所以v=v0 kruskal算法 把当前未被并入的，且并入后不会产生环的最小边进行并入。如何检测并入后到底会不会产生环呢？就用到了“并查集”。所谓的并查集，就是通过这些图中的点构造出来的树，每一个结点在相连的时候，要一直查到到根结点，如果根结点不相同，说明图中选取边之后不会产生环，所以可以选择这个这个结点的边。 相关的存储结构：","link":"/2018/04/30/data-structure-7/"},{"title":"data structure——数组、矩阵与广义表","text":"数组： 1.两种逻辑结构 一维数组dataType a[n]; 二维数组dataType a[m][n];元素为一维数组的数组 2.行优先和列优先储存这里要区分数组在定义的时候例如：int a[2][3]中2和3就是又两行，有三列的意思，而在说数组中的某一个元素是例如a[2][1]这里的2和1编号，是不一样的，因为编号是从0开始编号的。 矩阵: 1.概念矩阵可以理解为二维数组。 2.操作 矩阵转置 1234567void trsmat(int A[][maxsize],int B[][maxsize],int m, int n) /*这里二维数组声明时省略了行的个数， 但是列数是不可以省略的*/&#123; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) b[j][i]=A[i][j];&#125; 矩阵相加 123456void addmat(int A[][maxsize],int B[][maxsize],C[][maxsize],int m ,int n)&#123; for (int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) C[i][j]=A[i][j]+B[i][j];&#125; 矩阵相乘假设A[][]和B[][]分别为m*n，n*k。 12345678910void mutmat(int C[][maxsize],int B[][maxsize],int A[][maxsize],int m ,int n ,int k)&#123; for (int i=0;i&lt;m;++i) for(int j=0;j&lt;k;++j) &#123; C[0][0]=0; for(h=0;h&lt;n;++h) C[i][j]+=A[i][h]*B[h][j]; &#125;&#125; 特殊矩阵和稀疏矩阵： 1.特殊矩阵 对称矩阵 三角阵只需要将那些相同的元素的值加在一维数组的后面一位就可以了。 对角矩阵同上 2.稀疏矩阵 稀疏矩阵有两种表示方法： 三元组表示法12345typedef struct&#123; int val; //值 int i,j; //行标和下标&#125;Trimat; 定义一个含有maxterm个元素的稀疏矩阵：Trimat trimat[maxterm];所以可以理解为，三元组表示法，是将稀疏矩阵以每个元素有三个分量的线性表形式将其进行存储。 当然，也可以这样存储：int trimat[maxterms+1][3];此时：tirmat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值trimat[k][1]，tirmat[k][2]表示第k值在矩阵中的位置。所以可以看出这是一个有maxterms行3列的数组，每行的第一列是值，第二列和第三列为这个元素的位置。还有，我们默认的将第一行：trimat[0][0]，trimat[0][1]，trimat[0][2]存储为非零元素的个数，矩阵行数，矩阵个数。 例题：给定一个稀疏矩阵A（float型），其尺寸为m*n，建立其对应的三元组存储，并通过三元组打印输出矩阵A 12345678910111213141516171819202122232425262728293031323334void createtrimat(float A[][maxsize],int m ,int n, float B[][3]) //建立三元组&#123; int k=1; for(int i=0;i&lt;m;++i) for(int j=0;j&lt;n;++j) if(A[i][j]!=0) &#123; B[k][0]=A[i][j]; B[k][1]=i; B[k][2]=j; ++k; &#125; B[0][0]=k-1; B[0][1]=i; B[0][2]=j;&#125;void print(float[][3]) //通过三元组打印矩阵A&#123; void k=1; for(int i=0;i&lt;B[0][1];++i) &#123; for(int j=0;j&lt;B[0][2];++j) &#123; if(i==(int)B[k][1]&amp;&amp;j==(int)B[k][2]) &#123; cout&lt;&lt;B[k][0]&lt;&lt;\" \"; ++k; &#125; else cout&lt;&lt;\"0 \"; &#125; cout&lt;&lt;endl; &#125;&#125; 伪地址表示法 1.邻接表表示法 2.十字链表表示法 两种结点的结构定义：12345678910111213typedef struct OLNode //普通结点定义&#123; int row,col; struct OLNode *right ,*down; float val;&#125;OLNode;typedef struct //头结点定义&#123; OLNode *rhead,*chead; int m,n,k; //矩阵的行数，列数，非零结点个数&#125;Crosslist; 例题：给定一个稀疏矩阵A，其尺寸是m*n。非零元素个数是k，建立其对应的十字链表存储结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int creatcrossListmat(float A[][maxsize],int m,int n,int k,Crosslist &amp;M)&#123; if(M.rhead) free(M.rhead); if(M.chead) free(M.chead); M.m=m; M.n=n; M.k=k; /*申请头结点数组空间*/ if(!(M.rhead=(OLNode*)malloc(sizeof(OLNode)*m))) return 0; if(!M.chead=(OLNode*)malloc(sizeof(OLNode)*n)) return 0; /*头结点数组right和down指针置空*/ fot(int i=0;i&lt;m;++i) &#123; M.rhead[i].right=NULL; M.rhead[i].down=NULL; &#125; for(j=0;j&lt;n;++j) &#123; M.chead[j].right=NULL; M.chead[j].down=NULL; &#125; OLNode *temp_r[maxsize]; //建立列链表的辅助指针数组 for(int j=0;j&lt;n;++j) temp_r[j]=&amp;(M.chead[j]); for(int i=0;i&lt;m;++i) &#123; OLNode *c=&amp;(M.rhead[i]); for (int j=0;j&lt;n;++j) &#123; if(A[i][j]!=0) &#123; OLNode *p=(OLNode*)malloc(sizeof(OLNode)); p-&gt;row=i; p-&gt;col=j; p-&gt;val=A[i][j]; p-&gt;down=NULL; p-&gt;right=NULL; c-&gt;right=p; c=p; temp_r[j]-&gt;down=p; temp_r[j]=p; &#125; &#125; &#125; return 1;&#125; 广义表： 广义表头尾链表存储结构A( )B(e)C(a,(b,c,d))D((),B,C)E(a,E)F(())其中有两种结点：原子结点，广义表结点。原子结点有两个域：标记域和数据域广义表结点有三个域：标记域，头指针和尾指针。当广义表非空时，第一个元素为广义表的表头，其余元素为广义表的表尾，这也是这个存储结构的名字的由来。 广义表的扩展线性表存储结构其中也有两种结点：原子结点，广义表结点。不同的是：原子结点有三个域：标记域，头指针和尾指针。广义表结点有三个域：标记域，头指针和尾指针。 特点广义表头尾链表存储结构类似于不带头结点的单链表存储结构，而广义表的扩展线性表存储结构类似于带头结点的单链表存储结构。 下面是例题：1.设数组A[0,...,n-1]的n个元素中有多个零元素，设计一个算法，将A数组中的所有非零元素依次移动到A数组的前端。1234567891011121314151617void movelement(int A[],int n) &#123; int i =-1,temp; //i用来指最远离A[j]的为零的元素 for(j=0,j&lt;n;++j) &#123; if(A[j]!=0) &#123; ++i; if(i!=j) &#123; temp=A[i]; //用当前不是0的A[j]通过temp， A[i]=A[j]; //与最远离他的0元素进行交换 A[j]=temp; &#125; &#125; &#125;&#125; 2.关于浮点型数组A[0,...,n-1]，试设计一个实现下列运算的算法。（1）求数组A中的最大值。（2）求数组中n个数之和。（3）求数组中n个数的平均值。123456789101112131415161718192021222324252627282930float findmax(float A[],int i ,int j) //求最大值，递归&#123; float max; if(i=j) return A[i]; else &#123; max=findmax(A[],i+1,j); if(A[i]=max) return A[i]; else return max； &#125;&#125;float arraysum(float A[],int i ,int j) //求和&#123; if(i=j) return A[i]; else return A[i]+arraysum(A[],i+1,j);&#125;float arrayavg(float A[],int i,int j) //求平均数&#123; if (i==j) return A[i]; else return(A[i]+(j-i)*arrayavg(A,i+1,j))/(j-i+1);&#125; 3.设计一个算法，将数组A[0,...,n-1]中所有奇数移到偶数之前。要求不增加存储空间，且时间复杂度为O(n)。1234567891011121314151617181920void divide(int A[],int n)&#123; int i=0,j=n-1,temp; while(i&lt;j) &#123; while(A[i]%2==1&amp;&amp;i&lt;j) //将i停在偶数上 ++i; while(A[i]%2==0&amp;&amp;i&lt;j) //将j停在奇数上 --j; if(i&lt;j) &#123; temp=A[i]; A[i]=A[j]; A[j]=temp; ++i; --j; &#125; &#125;&#125; 4.设有一元素为整数的线性表L，存放在一维数组A[0,...,n-1]中，设计一个算法，以A[n-1]为参考量，将该数组分为左右两个部分，其中左半部分的元素均小于等于A[n-1]，右半部分的元素值均大于A[n-1]，A[n-1]则位于这两个部分之间。要求结果仍存放在数组A中。12345678910111213141516171819202122232425262728void divide(int A[],int n)&#123; int temp; int i=0; int j=n-1; temp=A[i]; A[i]=A[j]; A[j]=temp; temp=A[i]; while(i!=j) &#123; while (j&gt;i&amp;&amp;A[j]&gt;temp) --j; //找到右边第一个小于temp的数 if(i&lt;j) &#123; A[i]=A[j]; ++i; &#125; while(i&lt;j&amp;&amp;A[i]&lt;temp) ++i; //找到左边第一个大于temp的数 if(i&lt;j) &#123; A[j]=A[i]; --j; &#125; A[i]=temp； &#125;&#125; 5.设计一个算法，对给定的一个整形m*n矩阵A,统计这个矩阵中具有下列特特征的元素并输出他们的坐标及数值：他们既是所在行中的最小值，又是所在列中的最小值：或者他们既是所在行中的最大值，又是所在列中的最大值。假设矩阵中元素各不相同，要求结果在处理过程中用输出语句输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void printmin(int A[][maxsize],int m,int n) //求最小，m是行号，n是列号&#123; int i,j,k,min,minj; //minj是记录第i行上最小值的列号 int flag; for(i=0;i&lt;m;++i) &#123; min=A[i][0]; minj=0; for(j=1;j&lt;n;++j) if (A[i][j]&lt;min) //找出第i行上的最小值，列号为minj &#123; min=A[i][j]; minj=j; &#125; flag=1; for(k=0;k&lt;m;++k) &#123; if(min&gt;A[k][minj]) &#123; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;min&lt;&lt;\",[\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;j&lt;&lt;\",]\"&lt;&lt;\" \"; &#125; cou &lt;&lt;endl;&#125;void printmax(int A[][maxsize],int m,int n) //最大&#123; int i,j,k,max,maxj; int flag=0; for(i=0;i&lt;m;++i) &#123; max=A[i][0]; maxj=0; for(j=1;j&lt;n;++j) &#123; if(A[i][j]&gt;max) &#123; max=A[i][j]; maxj=j; &#125; flag=1; for(k=0;k&lt;m;++k) &#123; if(max&lt;A[i][maxj]) &#123; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;max&lt;&lt;\",[\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;maxj&lt;&lt;\",]\"&lt;&lt;\" \"; &#125; &#125; cout&lt;&lt;endl;&#125; 此题是一行一行的循环，首先是由第5行的循环，然后再通过第10行的循环，找出这一行中的最小值，然后，再在第16行的循环比较，这一行的这个最小值是不是又是他所在列的最小值，如果不是就将flag值为0，并退出，如果是，就以min,[i,minj]的格式将其输出。求最大的值的思路一样。 6.给定稀疏矩阵A（int型），创建其三元组存储结构B;查找给定元素x是否在矩阵中。1234567891011121314151617181920212223242526272829void create(int A[][maxsize],int m,int n,int B[][3])&#123; int i,j,k=1; for(i=0;i&lt;m;++i) for(j=0;j&lt;n;++i) if(A[i][j]!=0) &#123; B[k][0]=A[i][j]; B[k][1]=i; B[k][2]=j; ++k; &#125; B[0][0]=k-1; B[0][1]=m; B[0][2]=n;&#125;int search(int B[][3],int x) //查找元素&#123; int i,t; t=B[0][0]; i=1; while(i&lt;=t&amp;&amp;B[i][0]!=x) i++; if(i&lt;=t) //这里有疑问 return 1; else return 0;&#125; 7.假设稀疏矩阵A采用三元组表示，编写一个函数，计算其转置矩阵B,要求B也采用三元组表示。1234567891011121314151617181920void transpose(int A[][3],int B[][3])&#123; int p,q,col; B[0][0]=A[0][0]; B[0][1]=A[0][2]; B[0][2]=A[0][1]; if(B[0][0]&gt;0) &#123; q=1; for(col=0;col&lt;B[0][1];++col) for(p=1;p&lt;=B[0][0];++p) if(A[p][2]==col) &#123; B[q][0]=A[p][0]; B[q][1]=A[p][2]; B[q][2]=A[p][1]; ++q; &#125; &#125;&#125; 8.假设稀疏矩阵A和B（两矩阵行列数对应相等）都采用三元组表示，编写一个函数，计算C=A+B，要求C也采用三元组表示，所有矩阵均为int型。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void add(int A[][3],int B[][3],int C[][3]) &#123; int i=1,j=1,k=1,m; while(i&lt;=A[0][0]&amp;&amp;j&lt;=B[0][0]) if(A[i][1]==B[i][1]) //如果a中的元素的行号等于b的元素的行号，说明，这两个元素在原来的稀疏矩阵中的同一行， &#123; if (A[i][2]&lt;B[i][2]) /*接着再比较这个元素的列号，若果a的列号小于b,那么就说明， a这个非零元素在稀疏矩阵中的位置， 对应于b的这个相同行号的元素在其稀疏矩阵中的位置的那个元素是0*/ &#123; C[k][0]=A[i][0]; /*所以，a的元素加上0，就相当于将a当前的元素直接赋值给三元组c，下面的思路是一个意思*/ C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; else if (A[i][2]&gt;B[1][2]) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++j; &#125; else (A[i][2]==B[j][2]) &#123; m=A[i][0]+B[j][0]; if(m!=0) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; &#125; ++j; ++i; &#125; &#125; else if(A[i][1]&lt;B[j][1]) //如果a三元组的这个元素的行号小于b三元组的行号时 &#123; C[k][0]=A[i][0]; C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; else(A[i][1]&gt;B[j][1]) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++i; &#125; while(i&lt;=A[0][0]) //如果a三元组中有多余的元素，将多余的元素直接赋值给c &#123; C[k][0]=A[i][0]; C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; while (i&lt;B[0][0]) //如果b三元组有多余 &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++j; &#125; C[0][0]=k-1; C[0][1]=A[0][1]; C[0][2]=A[0][2]; &#125; 由稀疏矩阵而来的三元组中，其实已经存储的是稀疏矩阵中非零的元素了，切记。 9.假设稀疏矩阵A,B（分别为m*n,n*k矩阵）采用三元组表示，编写一个函数计算C=A*B，要求C也是采用三元组表示的稀疏矩阵。12345678910111213141516171819202122232425262728293031int getvalue(int D[][maxsize],int i,int j) //返回三元组中的元素对应于他在稀疏矩阵中的值&#123; int k=1; while(k&lt;=D[0][0] &amp;&amp; (D[k][1]!=i||D[k][2]!=j)) //不相同的是0元素 k++; //所以就跳过 if (k&lt;=D[0][0]) return D[k][0]; else return 0;&#125;void mul(int A[][3],int B[][3],int C[][3],int m,int n,int k)&#123; int i,j,l,p=1,s; for(i=0;i&lt;m;++i) for(j=0;j&lt;n;++j) &#123; s=0; for(l=0;l&lt;n;++l) //主要是这个l要注意一下 s+=getvalue(A,i,l)*getvalue(B,l,j); if(s!=0) &#123; C[p][1]=i; C[p][2]=j; C[p][0]=s; ++p; &#125; &#125; C[0][1]=m; C[0][2]=n; C[0][0]=p-1;&#125; -..—.–..-.-./-.–..-..-.-..-/-.-.–.—…../-..—…—.-./–…-….-…-/-…-.——.-../-..—.-….–./-..—………/-.-..—–..-.-/-..-.-.-…–..-/-…-.—-.—.-/——–….–../-…-.—.-.-..-/-..—-.–…../–..—….-..-/—….-.—..-/-.—……—-/-..—…..–.-/-..–.-.–.–…/-.-…-.—.-../-..—.-….–./——–….–../-…——.–…/-..—………/-..—…-.-.-./-.-..-.-.–..-./—.–.-….-../-..—…..–.-/—.-…….–./–…-….-…-/——–….–../-….–..—–.-/—…-..–.–./–…-….-…-/—.——..-.-/-..-…..-.-..–/-.-..—–.-.-./–..–…-.—-/-..—-.–…../-.-.-..-…–../–…-….-…-/—.-.-…—–/—.–.-….-../-.—……—-/-..—…..–.-/-.—–……../-.——-….–/——–….–../-.-..—–.—-/–..–…-.—-/–..-.—–.–./-..-.-.—–.-../-..—………/-..-.-.-.——-/–…-….-…-/-…——.–…/–..–…-.—-/–..—….-..-/-..—………/—….-.—..-/-.—……—-/-.–..-..–…-/-….-….—-.-/-.-.-…–…-./–……….-./—..—.–…./-.-.—..-.-…/-..—-.–…../-.-.—..-.-…/-.-.–.——-./-..—..–..–./-..–..–….–./-..-…—..–../——–….–../-.-.—..-.-…/–…-….-…-/—.–.-….-../-.–.——-..-/-..-.—.–…-./—.—.–….-/—.—.-……/-..—.-….–./——–….–../–…-….-…-/–…-..-.-..–/-.—–……../-..-.——-..–/-..—..-.-…./——–….–../-.-..—-..-…/——.–.–..-/–…-….-…-/–…—.-.-…/-..-………..-/-..—.-….–./-..—………/-..—…-.-.-./-..—………/-..–..–..-.–./-.-..–.–….-/-.-…–..—../——–….–../-.——.-.—./-..–…–..—./-…—-.—-.–/–…-.–….-./—.—.-……/-..—-.–…../——–….–../–…-….-…-/—.—….-.–/—.—.-……/-..—-.–…../——–….–../-….–..—–.-/—…-..–.–./–.–..-.-….-/–..—….-..-/-.–..-..-.-.-./-..-.–…–..–/——–….–../-.-..–.—.-../-…——.–…/–..–…-.—-/-…-..—..-..-/—.–.-….-../-.-.-..-…–../-..—-.–…../-.-.—..-.-…/-..—………/-…–.-.—.—/—.—…—–/-.–..-.—–.-/–……….-.","link":"/2018/04/14/data-structure-5/"},{"title":"data structure——树与二叉树","text":"看一下知识点： 树的存储结构 二叉树的存储结构 二叉树的性质 树与二叉树的转换 森林与二叉树的转换 二叉树的遍历算法 非递归的二叉树的遍历算法 树的遍历算法 森林的遍历算法 线索二叉树，结构，遍历算法 赫夫曼树和编码 二叉树的确定 二叉树的估计 二叉树表达式 树的存储结构 顺序存储结构即定义一个数组来存储，如：int tree[maxsize];。用数组下标来表示树中的结点，数组元素中的内容表示该结点的双亲结点。所以又称为双亲存储结构。 链式存储结构主要有孩子存储结构和孩子兄弟存储结构两种。 二叉树的定义满足条件：1，每个结点最多只有两棵子树2,子树有左右顺序之分。 二叉树的存储结构 顺序存储结构（适用于完全二叉树）图中右边的规则只是适合完全二叉树，（如果用来储存一般的二叉树会浪费大量的存储空间）且是从0开始编号的。 链式存储结构（又名二叉链表存储结构）123456typedef struct BTNode&#123; char data; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode; 如下图： 树的孩子兄弟存储结构可以用于树等结构，可以将树变为二叉树，然后再用链式存储，其实也是链式存储，和上面那个是一样的意思。 满二叉树在一棵二叉树中，所有所有的分支结点都有左右孩子，并且所有的叶子结点都集中在二叉树的最后一层。 完全二叉树求完全二叉树的高度(h)（完全二叉树与结点个数有关系）看规律：高为1 共有 2^1-1 个结点高为2 共有 2^2-1 个结点高为3 共有 2^3-1 个结点… … 高为h 共有 2^h-1 个结点 所以也可以知道高度为h的完全二叉树的结点的个数n在这个范围内2^(h-1)-1&lt; n &lt;=2^h-12^(h-1)&lt;= n &lt;2^h 处理方法2：2^(h-1)+1&lt;= n+1 &lt;2^h+1h-1&lt;=log2n &lt;h (比h-1只大了一个不大于1的小数，所以可以取整)h-1=下取整log2n &lt;h所以h=下取整log2n+1 如果使用处理方法2：那么，可以接着化简：h-1 &lt; log2(n+1) &lt;= h (比h小了一个不大于1的小数)上取整：h=上取整log2(n+1) 二叉树的性质1，总分支数=总结点数-1（所有树结构都满足这个性质） 1 2，叶子结点数n0,单分支结点数n1，双分支结点数n2。则总结点数=n0+n1+n2 2总分支数=n1+2n2 （因为叶子结点无分支，单分支结点1个分支，双分支结点2个分支） 3 3，由1和2和3联立方程组，解得：n0=n2+1即得：叶子节点数=双分支结点数+1。 4，空分支数=总结点数+1 树与二叉树的相互转化把每一个结点的兄弟结点相互连接起来，然后删除父结点与孩子结点的连线，只保留一条，默认的是保留最左边（视觉上的最左的那个）的一个连线。二叉树转换为树的话，过程相反即可。 森林与二叉树的相互转换 首先按照将树转换成二叉树的方法，将森林中的每棵树转换为二叉树，然后，将每一个二叉树的根结点的右边的分支连接起来即可。 二叉树的遍历算法二叉树的深度优先遍历的算法用到递归这个概念，所以先看一下递归函数，递归有直接递归和间接递归，这里只讲直接递归1234void r()&#123; r();&#125; 简单一点讲，递归就是这个函数自己调用自己。在自己中调用自己的时候系统会做一个保护现场的操作，在调用玩自己后，系统又会做一个恢复现场的操作，这样就可以实现原路返回了，且，第一个调用自己的时候，在返回时是最后一个恢复现场的，这里明显有一个先进后出的感觉，这就是使用了“系统栈”，非递归就是使用自己定义的一个栈来进行遍历。 1.深度优先遍历 先序遍历 123456789void preorder(BTNode *p)&#123; if(p!=NULL) &#123; Visit(p); preorder(p-&gt;lchild); preorder(p-&gt;rchild); &#125;&#125; 中序遍历 123456789void inorder(BTNode *p)&#123; if(p!=NULL) &#123; inorder(p-&gt;lchid); Visit(p); inorder(p-&gt;rchild); &#125;&#125; 后序遍历 123456789void postorder(BTNode *p)&#123; if(!p=NULL) &#123; postorder(p-&gt;lchid); postorder(p-&gt;rchild); Visit(p); &#125;&#125; 例题：写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。123456789101112int getDepth(BTNode *p)&#123; int LD,RD; if(p=NULL) return 0; else &#123; LD=getDepth(p-&gt;lchid); RD=getDepth(p-&gt;rchild); return (LD&gt;RD?LD:RD)+1; &#125;&#125; 采用后序遍历方式，先算出左子树的深度LD再算出右子树的深度RD,最后max{LD,RD}+1，加一是因为还有一个根节点。其中LD&gt;RD?LD:RD是一个三目运算符，LD如果大于RD就返回LD,如果不大于就返回RD。 例题：在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点是否存在（找到任何一个满足要求的结点即可），如果存在，则将q指向该结点，否则q赋值为NULL，假设data为int型。12345678910111213int search(BTNode *p,BTNode *&amp;q,int key)&#123; if(p!=NULL) &#123; if(p-&gt;data==key) q=p; else &#123; search(p-&gt;lchild,q,key); search(p-&gt;rchild,q,key); &#125; &#125;&#125; 此算法可以进行修改，因为只需要找到一个满足条件的结点就好，所以当在左子树中找到这个结点了之后就可以直接退出了，如果没有找到，才需要再在右子树中去寻找，这就是所谓的“剪枝操作”，所以代码修改如下：123456789101112131415int search(BTNode *p,BTNode *&amp;q,int key)&#123; if(p!=NULL) &#123; if(p-&gt;data==key) q=p; else &#123; search(p-&gt;lchild,q,key); if(q==NULL) search(p-&gt;rchild,q,key); &#125; &#125;&#125; 例题：假设二叉树采用二叉链表存储结构存储，编写一个程序，输出先序遍历序列中第k个结点的值，假设k不大于总的结点数（结点data域类型为char型）。1234567891011121314151617int n=0;void trave(BTNode *p,int k)&#123; if(p!=NULL) &#123; ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; trave(p-&gt;lchild,k); trave(p-&gt;rchild,k); &#125;&#125; 若是中序或者后序遍历的话，代码如下：123456789101112131415161718192021222324252627282930void(BTNode *p,int k) //中序&#123; if(p!=NULL) &#123; trave(p-&gt;lchild,k); ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; trave(p-&gt;rchild,k); &#125;&#125;void trave(BTNode *p,int k) //后序&#123; if(p!=NULL) &#123; trave(p-&gt;lchild,k); trave(p-&gt;rchild,k); ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; &#125;&#125; 2.广度优先遍历 层次遍历层次遍历的主要过程是：从根节点开始，根结点先入队，然后根结点出队，访问他，看他是否存在左右孩子，如果存在就入队，先入左孩子，再入右孩子。然后就是重复以上过程：出队结点，访问，看是否存在左右孩子，存在就入队，直到队空为止。 1234567891011121314151617181920212223242526272829void level(BTNode *p)&#123; int front,rear; BTNode *que[maxsize]； //定义一个循环列表，来记录要访问的一个层次上的结点 front=rear=0; BTNode *q; //遍历指针 if(p!=NULL) &#123; rear=(rear+1)%maxsize； //入队 que[rear]=p; //根节点入队 while(front!=rear) //队列不空的时候循环 &#123; front=(front+1)%maxsize; //出队 q=que[front]; //队头结点出队 Visit(q); //访问队头结点 if(q-&gt;lchild!=NULL) //如果左子树不空, &#123; rear=(rear+1)%maxsize; que[rear]=q-&gt;lchild; //则左子树的根结点就入队 &#125; if(q-&gt;rchild!=NULL) //右子树如果不空， &#123; rear=(rear+1)%maxsize; que[rear]=q-&gt;rchild; //则右子树的根结点就入队 &#125; &#125; &#125;&#125; 例题：假设二叉树采用二叉链表储存结构储存，设计一个算法，求出该二叉树的宽度（具有结点数最多的那一层上的结点个数）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef struct&#123; BTNode *p; //结点指针 int lno; //结点的层次号&#125;St;int maxNode(BTNode *b)&#123; St que[maxsize]; int front,rear; int Lno,i,j,n,max; front=rear=0; BTNode *q; if(b!=NULL) &#123; ++rear; que[rear].p=b; que[rear].lno=1; while(front!=rear) &#123; ++front; q=que[front].p; Lno=que[front].lno; if(q-&gt;lchild!=NULL) &#123; que[rear].p=q-&gt;lchild; que[rear].lno=Lno+1; &#125; if(q-&gt;rchild!=NULL) &#123; ++rear; que[rear].p=q-&gt;rchild; que[rear].lno=Lno+1; &#125; &#125; max=0; //循环比较Lno，找出最大值，即为最大层数 for(i=1;i&lt;=Lno;++i) &#123; n=0; for(j=1;j&lt;=rear;++j) if(que[j].lno==i) ++n; if(max&lt;n) max=n; &#125; return max; &#125; else return 0;&#125; 树的遍历算法：树只有先序遍历和后序遍历算法，没有中序遍历算法。如果将一棵树转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对树进行先序遍历；对这个二叉树树进行中序遍历就相当于对这个树进行后序遍历。 树的先序遍历 1234567891011121314void preOrder(TNode* p,TNode tree[])&#123; if(p!=NULL) &#123; visit(p); Branch* q; q=p-&gt;first; while(q!=NULL) &#123; preOrder(&amp;tree[q-&gt;cIdx],tree); q=q-&gt;next; &#125; &#125;&#125; 树的后序遍历 123456789101112131415void preOrder(TNode* p,TNode tree[])&#123; if(p!=NULL) &#123; Branch* q; q=p-&gt;first; while(q!=NULL) &#123; preOrder(&amp;tree[q-&gt;cIdx],tree); q=q-&gt;next; &#125; visit(p); &#125;&#125; 树的层次遍历 12345678910111213141516171819202122232425void level(TNode *tn,TNode tree[])&#123; int front,rear; TNode *que[maxSize]; front=rear=0; TNode *p; if(tn!=NULL) &#123; rear=(rear+1)%maxSize; que[rear]=tn; while(front!=rear) &#123; front=(front+1)%maxSize; p=que[front]; visit(p); Branch* q=p-&gt;first; while(q!=NULL) &#123; rear=(rear+1)%maxSize; que[rear]=&amp;tree[q-&gt;cIdx]; q=q-&gt;next; &#125; &#125; &#125;&#125; 森林的遍历算法：森林也只有先序遍历和后序遍历。如果将一森林转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对森林进行先序遍历；对这个二叉树进行中序遍历就相当于对这个森林进行后序遍历。 二叉树的遍历算法的改进： 先序遍历的非递归算法 12345678910111213141516171819void preorderNonrecursion(BTNode *bt) //传入一个二叉树结点类型的指针&#123; if(bt!=NULL) &#123; BTNode *Stack[maxsize]; //建立了一个辅助栈 int top=-1; BTNode *p; //遍历指针 Stack[++top]=bt; while(top!=-1) &#123; p=Stack[top--]; //先出栈 Visit(p); if(p-&gt;rchild!=NULL) //如果右孩子存在就入栈 Stack[++p]=p-&gt;rchild; if(p-&gt;lchild!=NULL) //如果左孩子存在就入栈 Stack[++top]=p-&gt;lchild; &#125; &#125;&#125; 中序遍历的非递归算法 中序遍历的规则是：根结点入栈，栈顶结点的左孩子存在就入栈， 一直向左走，一直走到不能向左走了，即栈顶结点的左孩子不存在，则出栈并输出栈顶结点。然后向右走一步，如果栈顶结点的右孩子存在就入栈，再从这个右孩子向左一直走，走到不能向左走为止。不能走了就出栈，看其右孩子是否有，有的话就向右走一步，。。。就这样一直重复。123456789101112131415161718192021222324void inorderNoncursion(BTNode *bt)&#123; if(bt!=NULL) &#123; BTNode *Stack[maxsize]; int top=-1; BTNode *p=NULL; p=bt; //p指向根结点 while(top!=-1||p!=NULL) &#123; while(p!=NULL) &#123; Stack[++top]=p; p=p-&gt;lchild; &#125; if(top!=-1) &#123; p=Stack[top--]; Visit(p); p=p-&gt;rchild; &#125; &#125; &#125;&#125; 后序遍历的非递归算法后序遍历可以使用先序遍历得到：先对先序遍历序列进行左右子树的遍历顺序交换，得到逆后序遍历序列；再使用一个栈，将逆后序遍历序列的顺序逆过来输出得到后序遍历序列。1234567891011121314151617181920212223242526void postorderNoncursion(BTNode *bt) &#123; if(bt!=NULL) &#123; BTNode *Stack1[maxsize]; //定义一个辅助遍历的栈 int top1=-1; BTNode *Stack2[maxsize]; //定义一个用来逆序的栈 int top2=-1; BTNode *p=NULL; //遍历指针 Stack1[++top1]=bt; //根结点入栈Stack1 while(top1!=-1) &#123; p=Stack1[top1--]; //出栈S1 Stack2[++top2]=p; //上一步出栈出来的元素入栈到S2 if(p-&gt;lchild!=NULL) Stack1[++top1]=p-&gt;lchild; //左孩子先入栈 if(p-&gt;rchild!=NULL) Stack1[++top1]=p-&gt;rchild; //右孩子入栈 &#125; while(top2!=-1) &#123; p=Stack2[top2--]; //出栈, Visit(p); //后打印 &#125; &#125; &#125; 二叉树的估计 二叉树的表达式 本文章主要整理于《数据结构高分笔记》和《率辉数据结构辅导专栏》微信号:辉解读。","link":"/2018/10/14/data-structure-6/"},{"title":"纪念一下~","text":"前几天突然不知怎么的，在网上看到了hexo。了解了一番后才知道原来是搭建博客的好工具，孤陋寡闻，原来好多大牛都有自己的博客，看到人家写的博客觉得好炫酷，而且感觉很自由，帮助别人解决一直困惑的感觉一定也很好~哈哈，顿时我就准备搞一个出来，，，嗯，，，看到自己做出来的博客感觉还是很好的。计算机小白，就在自己的博客里记录记录自己的所学以及一些感悟吧~~ 深知能力还远远不够，我们一起努力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#include ＜stdio.h＞#include ＜conio.h＞ //必须加路径，必须把头文件packet32.h包含进去#include \"..\\..\\Include\\packet32.h\"#include \"..\\..\\Include\\ntddndis.h\"#define Max_Num_Adapter 10// Prototypes原型//发包void PrintPackets(LPPACKET lpPacket);//设备列表char AdapterList[Max_Num_Adapter][1024]; //zi ding yi yi ge han shu // 主程序开始int main()&#123; //define a pointer to an ADAPTER strUCture设备指针 LPADAPTER lpAdapter = 0; //define a pointer to a PACKET structure包指针 LPPACKET lpPacket; int i; DWord dwErrorCode; DWORD dwVersion; DWORD dwWindowsMajorVersion; //Unicode strings (WinNT) WCHAR AdapterName[8192]; //网络适配器设备列表，kuanzifu WCHAR *temp,*temp1; //ASCII strings (Win9x) char AdapterNamea[8192]; //网络适配器设备列表 char *tempa,*temp1a; int AdapterNum=0,Open; ULONG AdapterLength; //wu fu hao chang zeng xing char buffer[256000]; // 容纳来自驱动器的数据的缓冲区 struct bpf_stat stat; // 获得本机网卡名 AdapterLength=4096; printf(\"Packet.dll test application. Library version:%s\\n\", PacketGetVersion()); printf(\"Adapters installed:\\n\"); i=0; //下面这段代码是用来在不同版本下得到网络适配器名： //Win9x 和WinNT中的网卡名称是分别用ASCII和UNICODE实现的，所以首先要得到本地操作系统的版本号：dwVersion=GetVersion();dwWindowsMajorVersion= (DWORD)(LOBYTE(LOWORD(dwVersion))); //这里首先用到的Packet.dll函数是PacketGetAdapterNames（PTSTR pStr，PULONG BufferSize,//通常它是与驱动程序通信并被调用的第一个函数，它将返回的用户本地系统中安装的网络适配器的名字放在缓冲区pStr中；BufferSize是缓冲区的长度：if (!(dwVersion ＞= 0x80000000 &amp;&amp; dwWindowsMajorVersion ＞= 4))&#123; //是Windows NT // 找不到设备列表 if(PacketGetAdapterNames(AdapterName,&amp;AdapterLength)==FALSE)&#123; printf(\"Unable to retrieve the list of the adapters!\\n\"); return -1; &#125; // 找到设备列表 temp=AdapterName; temp1=AdapterName; while ((*temp!='\\0')(*(temp-1)!='\\0')) &#123; if (*temp=='\\0') &#123; memcpy(AdapterList[i],temp1,(temp-temp1)*2); temp1=temp+1; i++; &#125; temp++; &#125; // 显示适配器列表 AdapterNum=i; for (i=0;i＜AdapterNum;i++) wprintf(L\"\\n%d- %s\\n\",i+1,AdapterList[i]); printf(\"\\n\"); &#125; else //否则就是windows 9x，获取适配器名的方法同WinNT下 &#123; if(PacketGetAdapterNames(AdapterNamea,&amp;AdapterLength)==FALSE)&#123; printf(\"Unable to retrieve the list of the adapters!\\n\"); return -1; &#125; tempa=AdapterNamea; temp1a=AdapterNamea; while ((*tempa!='\\0')(*(tempa-1)!='\\0')) &#123; if (*tempa=='\\0') &#123; memcpy(AdapterList[i],temp1a,tempa-temp1a); temp1a=tempa+1; i++; &#125; tempa++; &#125; AdapterNum=i; for (i=0;i＜AdapterNum;i++) printf(\"\\n%d- %s\\n\",i+1,AdapterList[i]); printf(\"\\n\");&#125; //下面这段代码就是让用户选择监听的网络适配器号：// 选择设备do &#123; printf(\"Select the number of the adapter to open : \"); scanf(\"%d\",&amp;Open); if (Open＞AdapterNum) printf(\"\\nThe number must be smaller than %d\",AdapterNum); &#125; while (Open＞AdapterNum); //然后，将所选择的设备打开，这里可以设置为“混杂”模式打开，也可以是“直接”模式打开。代码如下：// 打开设备lpAdapter = PacketOpenAdapter(AdapterList[Open-1]);// 当设备无法打开时，出示错误信息：if (!lpAdapter (lpAdapter-＞hFile == INVALID_HANDLE_VALUE))&#123; dwErrorCode=GetLastError(); printf(\"Unable to open the adapter, Error Code : %lx\\n\",dwErrorCode); return -1;&#125; //将网卡设置为“混杂”模式，代码如下： //这里用到函数PacketSetHwFilter（LPADAPTER AdapterObject，ULONG Filter），它在到来的包上设置了一个硬件过滤器，如操作成功，返回TRUE。AdapterObject是过滤器所在的网卡设备指针；过滤器的常量Filter定义在头文件ntddndis.h 中，包括有： /*·NDIS-PACKET-TYPE-PROMISCUOUS：设置混杂模式，每个到来的包都会被网卡接受； ·NDIS-PACKET-TYPE-DIRECTED：只有直接到主机网卡的包才会被接受； ·NDIS-PACKET-TYPE-BROADCAST：只接受广播包； ·NDIS-PACKET-TYPE-MULTICAST：只接受到主机所在的组的多播包； ·NDIS-PACKET-TYPE-ALL-MULTICAS：接受每个多播的包。*/// set the network adapter in promiscuous mode// 假如混杂模式设置失败，提示错误：if(PacketSetHwFilter(lpAdapter,NDIS_PACKET_TYPE_PROMISCUOUS)==FALSE)&#123;printf(\"Warning: unable to set promiscuous mode!\\n\");&#125; //然后在driver中置512K的缓冲： //这里用到函数PacketSetBuff（LPADAPTER AdapterObject，int dim），它被用于设置AdapterObject指向的网卡的驱动程序的缓冲区，//成功则返回TRUE。Dim是新的缓冲区的大小，当它被设定时，旧缓冲区中的数据将被丢弃，其中存储的包也会失去。 //需要注重的地方：驱动器缓冲区的大小设置是否恰当，将影响截包进程的性能，设置应能保证运行快且不会丢包。这里设置的是512000Byte。// set a 512K buffer in the driver// 当无法设置缓冲区时，提示错误：if(PacketSetBuff(lpAdapter,512000)==FALSE)&#123; printf(\"Unable to set the kernel buffer!\\n\"); return -1;&#125; PacketSetReadTimeout（LPADAPTER AdapterObject，int timeout）函数的功能是，设置与AdapterObject指定网卡绑定的读操作超时的值，timeout以毫秒为单位，0表示没有超时，当没有包到时，read就不返回。// set a 1 second read timeout// 设置1秒的读取操作超时if(PacketSetReadTimeout(lpAdapter,1000)==FALSE)&#123; printf(\"Warning: unable to set the read tiemout!\\n\");&#125; //接下来，定位设备，代码如下： //这里用到函数PacketAllocatePacket（Void）将在内存中分配一个PACKET结构并返回一个指向它的指针，//但这个结构的Buffer字段还没有设定，所以应再调用PacketInitPacket函数来对其进行初始化。//allocate and initialize a packet structure that will be used to//receive the packets.// 当定位失败时，提示错误：if((lpPacket = PacketAllocatePacket())==NULL)&#123; printf(\"\\nError: failed to allocate the LPPACKET structure.\"); return (-1);&#125; //然后，就可以初始化设备，开始接受网络包了： //用函数PacketInitPacket（LPPACKET lpPacket，PVOID Buffer，UINT Length）来初始化PACKET结构。//lpPacket是要被初始化的指针；Buffer为指向用户分配的包含包的数据的缓冲区的指针；Length为缓冲区长度。 //需要注重的地方：PACKET结构关联的缓冲区存储由packet capture driver 截获的包，包的数量被缓冲区大小所限制，//最大缓冲区的大小就是应用程序从驱动器中一次能读到的数据的多少。所以设置大的缓冲区可减少系统调用的次数，提高截获效率。这里设置的是256K。PacketInitPacket(lpPacket,(char*)buffer,256000); //接下来，是截包主循环：//main capture loop //这里又用到函数PacketReceivePacket（LPADAPTER AdapterObject，LPPACKET lpPacket，BOOLEAN Sync），//它将接受（截获）一个包的集合。参数包括一个指向用来指定截包的网卡的ADAPTER结构指针、一个指向用来容纳包的PACKET结构、//一个指出是同步还是异步方式操作的标记。当操作同步时，函数锁定程序；当操作异步时，函数不锁定程序，必须调用PacketWaitPacket过程来检查是否正确完成。一般采用同步模式。// 直到有键盘键入：while(!kbhit())&#123; // capture the packets 捕捉包 // 捕捉包失败时，提示错误： if(PacketReceivePacket(lpAdapter,lpPacket,TRUE)==FALSE)&#123; printf(\"Error: PacketReceivePacket failed\"); return (-1); &#125; // 打印包中的数据，调用自定义函数PrintPackets（） PrintPackets(lpPacket);&#125; //最后将得到的统计数据打印出来，代码如下： //这里用到函数PacketGetStats（LPADAPTER AdapterObject，struct bpf_star*s）可以得到两个驱动程序的内部变量的值：//从调用PacketOpenAdapter开始，已经被指定网卡接收的包数目；以及已经被网卡接收但被内核丢弃的包数目。这两个值被驱动程序拷贝到应用提供的bpf_stat结构中。//print the capture statistics// 得到统计值// 当无法从内核读取状态时，提示错误：if(PacketGetStats(lpAdapter,&amp;stat)==FALSE)&#123; printf(\"Warning: unable to get stats from the kernel!\\n\");&#125;// 打印“XX包被截取；XX包被丢弃”：elseprintf(\"\\n\\n%d packets received.\\n%d Packets lost\",stat.bs_recv,stat.bs_drop); //这里用函数PacketFreePacket(LPPACKET lpPacket)来释放由lpPacket指向的结构：// 释放空间PacketFreePacket(lpPacket);//用函数PacketCloseAdapter(LPADAPTER lpAdapter)来释放ADAPTER结构lpAdapter，并关闭网卡指针：// close the adapter and exit// 关闭设备退出PacketCloseAdapter(lpAdapter);return (0);&#125; // 主程序结束 //其中用来打印数据报的自定义的函数PrintPackets（）的代码在这里就不具体说明了。","link":"/2018/03/07/life-1/"},{"title":"urllib库详解","text":"&nbsp;&nbsp;非常明显，技术已经超越我们的人性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——阿尔伯特·爱因斯坦（Albert Einstein） python爬虫之旅之第一站~~ 首先讲一下urllib库，他是python内置的一个http请求库，他有以下主要的四个模块： urllib.request 请求模块，我们通过他来模拟发送一个请求 urllib.error 异常处理模块 urllib.parse url解析模块，可以对url进行拆分，合并等操作 urllib.robotparser robots.txt解析模块，主要是对网站的robots.txt文件进行解析 下面我们就来讲解一下urllib库中的各种使用情况： urlopen函数：urllib.request.urlopen(url,data=None,[timeout])urlopen函数中的常见的参数有url,data和timeout，url参数是传入网站的url，data参数主要是用来传入一些其他的数据，timeout是用于超时的数据。 下面看代码：123import urllib.requestresponse=urllib.request.urlopen(\"http://aisleep.xyz\")print(response.read().decode('utf-8')) 其中.read()是获取response的内容，因为一开始是bytes数据，所以才要再用.decode(&#39;utf-8&#39;)将其转为字符串。这个是request的一个get的请求。 接着看：123456import urllib.parseimport urllib.requestdata=bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;),encoding='utf8')response=urllib.request.urlopen('http://httpbin.org',data=data)print(response.read()) 这里传入了个data，且必须是bytes类型。其中调用urlencode方法传入所需要的字典，后又定义了一个编码方式。这就是post请求。 下面再看一下使用timeout参数的代码：12345678910import urllib.requestimport socketimport urllib.errortry: response=urllib.request.urlopen('http://httpbin.org/get',timeout=1) print(response.read())except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(\"time out\") 这里是使用了一个try-except处理异常，还设置了一个timeout参数，还有涉及到了一些error等，这个后面会有讲解。 下面我们再来看看，urlopen的响应类型（一般常用的有：状态码，响应头，响应体）：代码一：123import urllib.requestresponse=urllib.request.urlopen('http://baidu.com')print(type(response)) 代码二：123456import urllib.requestresponse=urllib.request.urlopen('https://baidu.com')print(response.status)print(response.getheaders()）print(response.getheader('Server'))print(response.read().decode('utf-8')) 代码一中是返回了response的类型是什么，代码二中第3行是返回的状态码，一般请求成功状态码就是200第4行是返回的响应头的全部信息，第5行则是返回的是响应头中的Server参数的信息，第6行则是使用了常用的read方法，来获取响应体的内容。 Request对象 代码一： 1234import urllib.requestrequest=urllib.request.Request('http://aisleep.xyz')response=urllib.request.urlopen(request)print(response.read().decode('utf-8')) 代码二：12345678910from urllib import request,parseurl=\"http://httpbin.org/post\"dict=&#123; 'name':'lifan'&#125;data=bytes(parse.urlencode(dict),encoding='utf8')req=request.Request(url=url,data=data,method='POST')req.add_header('User-Agent','Mozilia/4.0(compatible;MSIE 5.5;Windows NT)')response=request.urlopen(req)print(response.read().decode('utf-8')) 这里代码二是将url,data,header一起传给Request对象，然后再使用urlopen函数。第8行是传入了一个header,可以用特殊的add_header函数，也可以将其构造一个和这里的dict一样的字典传给Request。通过Request对象可以将我们需要传入的请求方式，请求头，请求体等参数构造成一各整体，传给Request对象，发送给服务器。这里使用Request对象，再调用urlopen函数的方法相比于直接使用urlopen函数的好处就是可以传入更多类型的参数。不单单只是url,timeout,data等了。 代理（handler） 12345678import urllib.requestproxy_handler=urllib.request.ProxyHandler(&#123; 'https': 'https://127.0.0.1:9743', 'http': 'http://127.0.0.1:9743' &#125;)opener=urllib.request.build_opener(proxy_handler)response=opener.open('http://www.google.com')print(response.read()) 这里稍后再细讲 cookie 获取cookie 1234567import urllib.request,http.cookiejarcookie=http.cookiejar.CookieJar()hander=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(hander)response=opener.open('http://www.baidu.com')for item in cookie: print(item.name+\"=\"+item.value) cookie保存： 12345678#cookie保存方式1import http.cookiejar,urllib.requestfilename=\"cookie.txt\"cookie=http.cookiejar.MozillaCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(\"http://www.baidu.com\")cookie.save(ignore_discard=True,ignore_expires=True) 12345678#cookie保存方式2import http.cookie,urllib.requestfilename ='cookie.txt'cookie=http.cookiejar.LWPCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open('http://www.baidu.com')cookie.save(ignore_discard=True,ignore_expires=True) 1234567#读取cookie文件import http.cookiejar,urllib.requestcookie=http.cookiejar.LWPCookiejar()cookie.load('cookie.txt',ignore_discard=True,ignore_expires=True)handler=urllib.request.build_opener(handler)response=opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) cookie这里的使用，后面再细讲。 error模块，异常处理 123456789from urllib import request,errortry: response=request.urlopen('http://www.baidu.com')except error.HTTPError as e: print(e.reason,e.code,e.headers,sep='\\n')except error.URLError as e: print(e.reason)else： print（'Request.Successfully'） urlparse模块，url解析 123from urlib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment')print(result) urlparse模块主要是对url进行解析，这个代码的输出信息是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id5&#39;,fragment=&#39;comment&#39;) 再看： 123from urlib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment',scheme='https')print(result) 这个代码的输出信息则是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id5&#39;,fragment=&#39;comment&#39;)可以看到，我们指定的协议类型，如果默认协议存在则不会被我们指定的协议所改变。 再看： 12from urllib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment',allow_fragments=False) 这个代码的输出信息则是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id=5#comment&#39;,fragment=&#39;&#39;)可见，当我们指定allow_fragment=False的时候，fragment的内容就会被拼接到前面的query 里面去。如果连前面的query也没有呢？fragment里面的内容会继续拼接到前面的地方。 unurlparse函数，组成url 123from urllib.parse import urlunparsedata=['http','www.baidu.com','index.html','user','a=6','comment']print(urlunparse(data)) 这个代码的输出信息则是：http://www.baidu.com/index.html;user?a=6#comment urljoin函数，拼接url 12345from urllib.parse import urljoinprint(urljoin('http://www.baidu.com','https://www.google.com/faq.html'))print（urljoin('http://www.baidu.com','https://www.baidu.com')）print(urljoin('http://www.baidu.com','http://www.baidu.com/FAQ.html?question=2'))print(urljoin('http://www.baidu.com','?category=1')) 这个代码的运行结果是：1234https://www.google.com/faq.htmlhttps://www.baidu.comhttp://www.baidu.com/FAQ.html?question=2http://www.baidu.com?category=1 我们从中可以知道，urljoin函数，泛泛的理解就是：在前者后者都有的情况下，后者的内容会覆盖前者，前者没有后者有的时候，也是为后者的内容，如果前者有，后者内容没有就以前者为准。 urlencode函数，将字典对象转换成get请求参数 12345678from urllib.parse import urlencodeparams=&#123; 'name':'lifan', 'age':23&#125;base_url='http://www.baidu.com'url=base_url+urlencode(params)print(url) 运行结果是：http://www.baidu.comname=lifan&amp;age=23 var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', //改为你自己的，下同 client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/04/01/web-scraping-1/"},{"title":"计划表","text":"2018年硕士研究生入学考试专业基础课程考试大纲及题型分布 题型分布 一、选择题：（40道题，每题2分，共80分） 操作系统：16道题数据结构：12道题组成原理：12道题 二、综合问答题：（7道题，平均10分，共70分）操作系统：3道题（共28分）数据结构：2道题（共21分）组成原理：2道题（共21分） 考试大纲 操作系统【考查目标】 掌握操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行。 掌握操作系统进程、内存、文件和I/O管理的策略、算法、机制以及互相关系。 能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C或C++等高级语言描述相关算法。 一、操作系统概述（一）操作系统的概念、特征、功能和提供的服务（二）操作系统的发展与分类（三）操作系统的运行环境 内核态与用户态 中断、异常 系统调用（四）操作系统的结构 二、进程管理（一）进程与线程 进程概念 进程的状态与转换 进程控制和组织进程控制块；调度队列和调度器；进程的创建和终止。4.线程概念与多线程模型（二）CPU调度 调度的基本概念 调度时机、切换与过程 调度的基本准则 调度方式 典型调度算法先来先服务调度算法；短作业（短进程、短线程）优先调度算法；时间片轮转调度算法；优先级调度算法；多级反馈队列调度算法。（三）同步与互斥 进程同步和临界区的基本概念 信号量 使用信号量描述和解决经典同步问题 （四）死锁 死锁的概念 死锁处理策略 死锁预防 死锁避免系统安全状态；银行家算法。 死锁检测和解除 三、内存管理（一）内存管理基础 内存管理概念程序装入与链接；逻辑地址与物理地址空间；内存保护。 连续分配管理方式 非连续分配管理方式分页管理方式；分段管理方式；段页式管理方式。（二）虚拟内存管理 虚拟内存基本概念 请求分页管理方式 页面置换算法最佳置换算法（OPT）；先进先出置换算法（FIFO）；最近最少使用置换算法（LRU）。 页面分配策略 工作集 抖动 四、文件管理（一）文件系统基础 文件概念 文件的逻辑结构顺序文件；索引文件；索引顺序文件。 目录结构文件控制块和索引节点；单级目录结构和两级目录结构；树形目录结构；图形目录结构。 文件共享 文件保护访问类型；访问控制。（二）文件系统实现 文件系统层次结构 目录实现 文件实现（三）磁盘组织与管理 磁盘的结构 磁盘调度算法 磁盘的管理 五、输入输出（I/O）管理（一）I/O管理概述 I/O控制方式 I/O软件层次结构（二）I/O核心子系统 I/O调度概念 高速缓存与缓冲区 数据结构【考查目标】 1. 理解数据结构的基本概念；掌握数据的逻辑结构、存储结构及其差异以及各种基本操作的实现。 2. 掌握基本的数据处理原理和方法的基础上，能够对算法进行设计与分析。 3. 能够选择合适的数据结构和方法进行问题求解；具备采用c或c++语言设计与实现算法的能力。【考查范围】 一、线性表 (一) 线性表的定义和基本操作 (二) 线性表的实现 1. 顺序存储结构 2. 链式存储结构 3. 线性表的应用 二、栈、队列和数组 (一) 栈和队列的基本概念 (二) 栈和队列的顺序存储结构 (三) 栈和队列的链式存储结构 (四) 栈和队列的应用 (五) 特殊矩阵的压缩存储 三、树与二叉树 (一) 树的基本概念 (二) 二叉树 1. 二叉树的定义及其主要特征 2. 二叉树的顺序存储结构和链式存储结构 3. 二叉树的遍历 4. 线索二叉树的基本概念和构造 (三) 树、森林 1. 树的存储结构 2. 森林与二叉树的转换 3. 树和森林的遍历(四) 树和二叉树的应用 二叉排序树 2. 平衡二叉树 3. 哈夫曼(Huffman)树和哈夫曼编码 三、图 (一) 图的概念 (二) 图的存储及基本操作 1. 邻接矩阵法 2. 邻接表法 (三) 图的遍历 1. 深度优先搜索 2. 广度优先搜索(四) 图的基本应用 1. 最小(代价)生成树 2. 最短路径 3. 拓扑排序 4. 关键路径 四、查找 (一) 查找的基本概念 (二) 顺序查找法 (三) 折半查找法 (四) B-树及其基本操作、B+树的基本概念(五) 散列(Hash)表 (六) 查找算法的分析及应用 五、内部排序 (一) 排序的基本概念 (二) 插入排序 1. 直接插入排序 2. 折半插入排序 (三) 冒泡排序(bubble sort) (四) 简单选择排序 (五) 希尔排序(shell sort) (六) 快速排序 (七) 堆排序 (八) 二路归并排序(merge sort) (九) 基数排序 (十) 各种内部排序算法的比较 (十一) 内部排序算法的应用 计算机组成原理 【考查目标】 1. 理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念。 2. 理解计算机系统层次化结构的概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。 能够运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行简单设计。 一、计算机系统概述 (一)计算机发展历程 (二)计算机系统层次结构 1.计算机硬件的基本组成 2.计算机软件的分类 3.计算机的工作过程 (三)计算机性能指标 响应时间、吞吐率，CPU时钟周期、主频、CPI、CPU执行时间，MIPS、MFLOPS 二、数据的表示和运算 (一)数制与编码 1.进位计数制及其相互转换 2.数据编码：机器数及其编码，BCD码，字符编码 3.校验码(二)数据的表示 数值数据的定点表示：无符号数的表示，有符号数的表示 数值数据的浮点表示：浮点表示方法，IEEE754标准 非数值数据的表示：字符与字符串的表示，逻辑数的表示(三) 定点数的运算 位移运算，位扩展运算，原码加/减运算，补码加/减运算，原码一位乘法运算，补码一位乘法运算，溢出概念和判别方法 (四)浮点数的运算 加/减运算 (五)算术逻辑单元ALU 1.串行进位加法器和并行进位加法器 2.算术逻辑单元ALU的功能和结构 三、存储器层次结构 (一)存储器的分类 (二)存储器的层次化结构 (三)半导体随机存取存储器 1. SRAM存储器的工作原理 2. DRAM存储器的工作原理 3.只读存储器(四)主存储器主存的逻辑设计，主存与CPU的连接，提高访存速度的措施 (五)高速缓冲存储器(Cache) 1.Cache的基本工作原理 2.Cache和主存之间的映射方式 3. Cache中主存块的替换算法 4. Cache写策略 (六)虚拟存储器 1.虚拟存储器的基本概念 2.虚拟存储器的实现 页式虚拟存储器，段式虚拟存储器，段页式虚拟存储器，TLB(快表) 四、指令系统 (一)指令格式指令的功能，指令的基本格式，操作码字段的功能及表示，地址码字段的功能及表示，指令字的相关概念 (二)指令的寻址方式 1.有效地址的概念 2.数据寻址和指令寻址 3.常见寻址方式 (三) CISC和RISC的基本概念 五、中央处理器(CPU) (一) CPU的功能和基本结构(二) 指令执行过程 CPU的工作流程，指令的执行过程，CPU基本操作与微操作的关系，指令执行过程的微操作序列(三)数据通路的功能和基本结构数据通路的类型，单总线数据通路的基本结构，微操作与微操作命令的关系，指令执行过程的微操作命令序列 (四)控制器的功能和工作原理 1.硬布线控制器基本结构，时序系统组成，信号时序控制方式，微操作控制信号形成 2.微程序控制器 微程序相关概念，微指令的编码方式，微地址的形成方式 (五)指令流水线 1.指令流水线的基本概念 2.指令流水线的基本实现 3.超标量和动态流水线的基本概念 (六)多核处理器的基本概念 六、总线 (一)总线概述 1.总线的基本概念 2.总线的分类 3.总线的组成及性能指标 总线的操作过程 (二)总线仲裁 1.集中仲裁方式：链式查询，计数器定时查询，独立请求 2.分布仲裁方式的基本概念 (三)总线操作定时 同步定时方式，异步定时方式，半同步定时方式 (四)总线标准 七、输入输出(I/O)系统 (一)I/O系统基本概念 (二)外部设备 输入设备，输出设备，外存储器 (三) I/O接口(I/O控制器) 1.I/O接口的功能和基本结构 2.I/O端口及其编址 3.I/O地址空间及其编码 (四)I/O方式 1.程序查询方式 2.程序中断方式 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念 3.DMA方式 DMA控制器的组成，DMA传送过程4.通道方式","link":"/2018/04/13/plan/"},{"title":"贴一个用python实现了一个解析pcap文件的小工具","text":"作为学习了一段时间的py和复习了一段网络有关的知识，就实现了如下的一个小工具，输入时pcap格式的文件，后序的话在实现用哈希来更好的存储吧。。嗯。。写的有点乱。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211import structimport os#x=os.system('cls')def clear():os.system('cls')#def clear(): # os.system('clear')#huanyingdef welcome(): print('\\t******************************\\n') print ('\\t* *\\n') print ('\\t* oneturle sniffer *\\n') print ('\\t* *\\n') print('\\n\\t******************************\\n') print('你想要了解什么呢?\\n') print('1.报文总数统计\\n') print('2.平均每秒字节数和每秒报文数的统计\\n') print('3.各种协议的每秒报文数统计和每秒字节数统计\\n') print('4.各种协议数据在流量中所占的比例\\n') print('5.退出\\n')#初始化参数input_file=input('请输入文件名：\\n')output_file=input('请输出文件名：\\n')print(\"\\n\"*15)m=0n=0tcp_n=0udp_n=0tcp_n=0udp_n=0egp_n=0igp_n=0ipv6_n=0ospf_n=0icmp_n=0igmp_n=0tcp_l=0udp_l=0tcp_l=0udp_l=0egp_l=0igp_l=0ipv6_l=0ospf_l=0icmp_l=0igmp_l=0ftime=0ltime=0ip_tlen=0with open(output_file,'w') as g: with open(input_file,'rb') as f: total=f.read(24) total=struct.unpack('LHHLLLL',total)#BHL while True: b=f.read(16) if b==b'': break #for i in range(18): #b=f.read(16) #shujutou b=struct.unpack('4i',b) if m==0: ftime=b[0] #shujudaodashijian else: ltime=b[0] #n=n+b[3] #jisuanshujuchangdu #g.write('%d '%b[1]) #print('%d'%b[3]) f.read(12) #mac frametype=f.read(2) #panbianip leixing if frametype!=b'\\x08\\x00': f.read(b[2]-14) #if frametype!=b'\\x08\\x00': #f.read(b[2]-14) else: g.write('%6d '%b[1]) n=n+b[2] version=f.read(1) #ipv4 or ipv6 g.write('IPV'+str(int(struct.unpack('B',version)[0]/16))+' ') TOS=f.read(1) #fuwu lei xing total_length=f.read(2) # chang du ip_tlen=ip_tlen+total_length[1] #jisuan changdu ID=f.read(2) Flag_segment=f.read(2) life=f.read(1) xieyi=f.read(1) #print(xieyi) check=f.read(2) #xieyi=struct.unpack('B',xieyi) #print('%d'%xieyi) ip_from=f.read(4) #ip address ip_from=struct.unpack('4B',ip_from) ip_to=f.read(4) ip_to=struct.unpack('4B',ip_to) port_from=f.read(2) #duan kou port_to=f.read(2) port_from=port_from[0]*256+port_from[1] port_to=port_to[0]*256+port_to[1] #port_from=struct.unpack('H',port_from) #port_to=struct.unpack('H',port_to) seq=f.read(4) #xu lie hao ac=f.read(4) #ack renzheng g.write('.'.join(['%3d'%i for i in ip_from])+':%d'%port_from) g.write('==&gt;') g.write('.'.join(['%3d'%i for i in ip_to])+':%d '%port_to) f.read(b[3]-34-12)#shuju chang du -shuju tou -shuju neirong #if frametype==b'\\x08\\x00': m=m+1 #ip bao geshu if xieyi==b'\\x06': g.write('TCP') tcp_n=tcp_n+1 tcp_l=tcp_l+b[2] elif xieyi==b'\\x11': g.write('UDP') udp_n=udp_n+1 udp_l=udp_l+b[2] elif xieyi==b'\\x01': g.write('ICMP') icmp_n=icmp_n+1 icmp_l=icmp_l+b[2] elif xieyi==b'\\x02': g.write('IGMP') igmp_n=igmp_n+1 igmp_l=igmp_l+b[2] elif xieyi==b'\\x08': g.write('EGP') egp_n=egp_n+1 egp_l=egp_l+b[2] elif xieyi==b'\\x09': g.write('IGP') igp_n=igp_n+1 igp_l=igp_l+b[2] elif xieyi==b'\\x29': g.write('IPV6') ipv6_n=ipv6_n+1 ipv6_l=ipv6_l+b[2] elif xieyi==b'\\x4f': g.write('OSPF') ospf_n=ospf_n+1 ospf_l=ospf_l+b[2]#3 g.write(' ') g.write('%dbyte'%b[2]) #dan ge baowen changdu g.write('\\n') #print('%d'%f.tell())welcome()k=mwhile True: f=input('请输入：\\n') f=int(f) if f==1: print('\\n\\n\\n报文大小为: %ld byte\\n'%n) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==2: print(\"\\n\\n\\n平均每秒字节数为:%4.2f b/s\\n\"%(n/(ltime-ftime))) print(\"平均每秒报文数为:%8.6f m/s\\n\"%(k/(ltime-ftime))) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==3: print(\"\\n\"*5) print('\\n\\n\\nICM2P:协议的每秒报文数统计:%4.2f b/s\\n'%(icmp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(icmp_n/(ltime-ftime))) print(\"IGMP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(igmp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(igmp_n/(ltime-ftime))) print('TCP:协议的每秒报文数统计:%4.2f b/s\\n'%(tcp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(tcp_n/(ltime-ftime))) print(\"EGP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(egp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(egp_n/(ltime-ftime))) print('IGP:协议的每秒报文数统计:%4.2f b/s\\n'%(igp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(igp_n/(ltime-ftime))) print(\"UDP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(udp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(udp_n/(ltime-ftime))) print('IPV6:协议的每秒报文数统计:%4.2f b/s\\n'%(ipv6_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(ipv6_n/(ltime-ftime))) print(\"OSPF:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(ospf_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(ospf_n/(ltime-ftime))) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==4: print(\"\\n\"*18) print('\\n\\n\\nICMP :%4.2f'%(icmp_n/k*100)+'%\\n') print('IGMP :%4.2f'%(igmp_n/k*100)+'%\\n') print('TCP :%4.2f'%(tcp_n/k*100)+'%\\n') print('EGP :%4.2f'%(egp_n/k*100)+'%\\n') print('IGP :%4.2f'%(igp_n/k*100)+'%\\n') print('UDP :%4.2f'%(udp_n/k*100)+'%\\n') print('IPV6 :%4.2f'%(ipv6_n/k*100)+'%\\n') print('OSPF :%4.2f'%(ospf_n/k*100)+'%\\n') flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==5: print('\\n\\n再见~\\n\\n') exit(0)","link":"/2018/07/18/shujubaojiexi-py/"},{"title":"有关栈的问题","text":"1、利用栈将中缀表达式求值：计算规则：设两个栈，s1用来存储操作数，s2用来存储运算符。从左往右扫描表达式，遇到操作数就将入栈s1,遇到运算符就入栈s2。当前扫描到的运算符优先级大于栈顶的运算符的优先级，则入栈，否则，就出栈s1中的两个操作数，进行计算，将计算结果入栈s1。且栈顶的操作数先出栈，放在运算符的右边，栈顶下面的一个操作数后出栈，放在运算符的左边。如果遇到左括号就直接入栈s2，直到遇到右括号，此时，从栈顶到左括号的运算符都出栈进行计算。出栈的运算符都不再入栈。如果表达式全部扫描完毕，s2栈中还有运算符的话就挨个出栈进行计算，计算结果依次放入s1栈中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int getpriority(char op) //判断运算符的优先级&#123; if(op=='+'||op == '-') // 规定只有+,-,*,/这四个运算 return 0; //若是+，-，则返回0 else return 1; //若是*，/，则返回1&#125;int calSub(float opandl,char,op,float opand2,float &amp;result) //出栈两个操作数和一个运算符进行运算&#123; if(op=='+') result = opandl+opand2; if(op=='-') result = opandl-opand2; if(op=='*') result = opandl*opand2; if(op=='/') &#123; if(fabs(opand2)&lt;MIN) //判断float型为0的标准语句 &#123; return 0; //除数为0的情况返回0，意为运算失败 &#125; else &#123; result = opandl / opand2; // 如果除数不是0的话就相除 &#125; &#125; return 1; //成功运算返回1，且结果保存在result中。&#125;float calInfix(char exp[]) //计算中缀表达式&#123; float s1[maxSize];int top1=-1; //顺序栈，来存操作数 char s2[maxSize];int top2=-1; //存运算符 int i=0; while(exp[i]!='\\0') //串尾为\\0 &#123; if('0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') //这里的0，9都是字符，不是数字，且假设输入都是一位数字 &#123; //所以字符的大小比较，是比较这个字符对应ascll码值 s1[++top1]=exp[i] -'0'; //exp[i]-'0'就将字符转为这个字符对应的数值，入栈 ++i; &#125; else if (exp[i]=='(') //如果扫描到了（,则直接入运算符栈 &#123; s2=[++top2]='('; ++i; &#125; else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') //如果扫描到了运算符 &#123; //一般有两种情况，一是直接入栈，二是弹出操作数进行运算后再入栈 if(top2==-1||s2[top2]=='(' || getpriority(exp[i])&gt;getpriority(s2[top2])) //如果栈空， //如果为（， &#123; //如果当前扫描到的运算符的优先级大于栈顶的运算符的优先级 s2[++top2]=exp[i]; //就入栈 ++i; &#125; else //如果不满足，就弹出运算符，和一些运算符进行运算 &#123; float opnd1,opnd2,result; //出栈的两个操作数，和结果 char op; //要进行运算的运算符 int flag; //接受calSub返回的标记 opnd2=s1[top--]; //先出栈的为第二个操作数 opnd1=s1[top--]; //后出栈的为第一个操作数，顺序不能弄反了 op=s2[top2--]; //弹出一个运算符 flag=calSub(opnd1,op,opnd2,result); //调用calSub函数，函数返回的是0,1，代表成不成功，结果是存在result中的 if(flag==0) //0代表计算不成功 &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; //求值成功了就将结果压栈 &#125; &#125; else if (exp[i]==')') //扫描遇到')'时， &#123; while(s2[top2] !='(') //就不停的出栈，直到遇到'(', &#123; float opnd1,opnd2,result; //且对每一个出栈的运算符进行一次运算 char op; int flag; opnd2=s1[top--]; opnd1=s1[top--]; op=s2[top2--]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; &#125; --top2; //此时指向'(',出栈，去掉他 ++i; //指向下一个字符 &#125; &#125; while(top2!=-1) //当表达式全部扫描之后，如果栈中还有运算符剩余，就全部出栈，且取两个操作数进行计算 &#123; float opnd1,opnd2,result; char op; int flag; opnd2=s1[top--]; opnd1=s1[top--]; op=s2[top2--]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; &#125; retunr s1[top1]; //操作数的结果在栈顶，返回即可&#125; 2、用栈求后缀表达式值：从左往右扫描这个表达式串，当遇到操作数的时候就入栈，当遇到运算符就出栈两个操作数，进行运算，先出栈的操作数放在运算符的左边，后出战的操作数放在运算符的右边。计算出结果，然后将这个结果入栈。一直将运算符全部运算完，最后一个计算结果即所求的值。1234567891011121314151617181920212223242526float calPostFix(char exp[])&#123; float s[maxsize];int top=-1; for(int i=0;exp[i]!='\\0';++i) &#123; if('\\0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') s[++top]=exp[i]-'0'; else //else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') &#123; float opnd1,opnd2,result; char op; int flag; opnd2=s[top--]; opnd1=s[top--]; op=exp[i]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; break; &#125; s[++top]=result; &#125; &#125; return s[top];&#125; 3、用栈求前缀表达式：从右往左扫描这个表达式。当遇到操作数的时候就入栈，当遇到运算符就出栈两个操作数，进行运算，先出栈的数放在运算符的右边，后出栈的放在运算符的左边。其他操作和后缀表达式计算方式一样。1234567891011121314151617181920212223242526float calPreFix(char exp[],int len)&#123; float s[maxsize];int top=-1; for(int i=len-1;i&gt;=0;--i) //从右往左 &#123; if('\\0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') s[++top]=exp[i]-'0'; else //else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') &#123; float opnd1,opnd2,result; char op; int flag; opnd1=s[top--]; //这里的出栈操作数的顺序也不一样 opnd2=s[top--]; op=exp[i]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s[++top]=result; &#125; &#125; return s[top];&#125; 这里就可以看出，中缀形式求值明显比用后缀或者前缀来的复杂，所以，这就是为什么计算机中会出现在生活中不会使用到的后缀和前缀形式。就像十进制一样，为人们所习惯，而计算机中普遍使用的是二进制。所以我们也必须为计算机的发展创造出能被计算机所方便使用和接受的规则。 4、中缀转后缀：转化规则：从左到右扫描中缀表达式，如果遇到操作数就直接将其写入结果表达式，（这个结果表达式的书写顺序是从左往右书写）如果遇到运算符就将其入栈。且如果这个即将入栈的运算符小于等于当前栈顶的运算符，则将当前栈顶的运算符出栈，写入当前得到的结果表达式中，这样一直比较下去，直到即将入栈的运算符的优先级大于当前栈顶的运算符，此时再将这个即将入栈的运算符入栈。如果栈空，就直接入栈，不需要上述的比较。如果遇到左括号，就直接入栈，当栈顶元素是左括号的时候，所有扫描到的运算符都入栈。当扫描到右括号的时候，执行一系列的出栈操作。将当前栈顶到左括号的运算符全部出栈，并将其写入结果表达式中，其中出栈的括号直接扔掉，左右括号都不写入结果表达式。一个左括号配一个右括号。此时如果全部扫描完表达式，栈中还有运算符，则将其全部出栈，写入结果表达式中即可。 12345678910111213141516171819202122232425262728293031323334353637void infixToPostFix(char infix[],char s2[],int &amp;top2)//infix为中缀表达式，s2这个栈用来存储转换后的后缀，top2作为栈顶&#123; char s1[maxSize];int top1=-1;//再定义一个辅助栈 int i=0; while(infix[i]!='\\0') &#123; if('0'&lt;=infix[i] &amp;&amp; infix[i]&lt;='9') &#123; s2[++top2]=infix[i]; ++i; &#125; else if(infix[i]='(') &#123; s1[++top]='('; ++i; &#125; else if(infix[i]=='+'||infix[i]=='-'||infix[i]='*'||infix[i]='/') &#123; if(top1==-1||s1[top1]=='(' || getpriority(exp[i])&gt;getpriority(s1[top1])) &#123; s1[++top1]=infix[i]; ++i; &#125; else s2[++top2]=s1[top1--]; //否则就从s1中出栈一个运算符入s2栈 &#125; else if(infix[i]==')') &#123; while (s1[top1]!='(') s2[++top2]=s1[top--]; --top1; //(出栈 ++i; &#125; &#125; while(top1!=1) s2[++top2]=s1[top1--];&#125; 5、中缀转前缀：转化规则：从右往左扫描，书写结果表达式的方向是从右往左写。遇到右括号直接入栈，遇到左括号就将当前栈顶到右括号的运算符出栈。当前运算符如果小于栈顶的运算符时，则当前栈顶的运算符出栈。其他的操作和中缀转后缀式一样的。12345678910111213141516171819202122232425262728293031323334353637void infixToPreFix(char infix[],char s2[],int &amp;top2,int len)//infix为中缀表达式，s2这个栈用来存储转换后的后缀，top2作为栈顶&#123; char s1[maxSize];int top1=-1;//再定义一个辅助栈 int i=len-1; while(i&gt;=0) &#123; if('0'&lt;=infix[i] &amp;&amp; infix[i]&lt;='9') &#123; s2[++top2]=infix[i]; --i; //注意 &#125; else if(infix[i]=')') //注意 &#123; s1[++top]=')'; --i; //注意 &#125; else if(infix[i]=='+'||infix[i]=='-'||infix[i]='*'||infix[i]='/') &#123; if(top1==-1||s1[top1]=='）' || getpriority(exp[i])&gt;=getpriority(s1[top1])) //注意，为&gt;=，不是&gt; &#123; s1[++top1]=infix[i]; --i; //注意 &#125; else s2[++top2]=s1[top1--]; //否则就从s1中出栈一个运算符入s2栈 &#125; else if(infix[i]=='(') //注意 &#123; while (s1[top1]!=')') //注意 s2[++top2]=s1[top--]; --top1; //(出栈 --i; //注意 &#125; &#125; while(top1!=1) s2[++top2]=s1[top1--];&#125; 6、括号匹配问题：12345678910111213141516171819202122232425262728293031323334int isMatched(char left,char right)&#123; if(left=='(' &amp;&amp; right==')') return 1; if(left=='[' &amp;&amp; right==']') return 1; if(left=='&#123;' &amp;&amp; right=='&#125;') return 1; else return 0;&#125;int isParenthesesBalanced(char exp[])&#123; char s[maxSize];int top=-1; for(int i=0;exp[i]!='\\0';++i) &#123; if(exp[i]=='('||exp[i]=='['||exp[i]=='&#123;') s[++top]=exp[i]; if(exp[i]==')'||exp[i]==']'||exp[i]=='&#125;') &#123; if(top==-1) return 0; //如果栈空就不匹配，返回0 char left =s[top--]; if(isMatched(left,exp[i])==0) return 0; &#125; &#125; if(top&gt;-1) return 0; // 栈不空，则不匹配 return 1; //栈为空，则匹配。返回1&#125; 7、计算问题：类似于这类问题，可以用递归去处理，不过递归的实质也是用栈，只是这个栈是系统分配的栈，我们这里是自己定义了一个栈。 1234567891011121314int calF(int m)&#123; int cum=1; int s[maxSize],top=-1; while(m!=0) &#123; s[++top]=m; m /= 3; //m=m/3 &#125; while(top!=-1) cum *=s[top--]; return cum;&#125; 8、共享栈：这样来定义共享栈：(假设共享栈由s1和s2两个栈共享)12int satck[maxsize];int top1=-1,top2=maxsize; 可以看到，无非就是在栈尾后面一个位置定义一个top2去指向他，在栈首的前一个位置定义一个top1去指向他。一般的，为了更好的同一形式，不用定义两个新的量去指向这些位置，而是定义一个数组，数组中有两个值，分别指向这两个位置。即：top[2]={-1,maxsize};就可以了。分别用top[0],top[1]去使用它们。 s1栈为空：top[0]==-1;s2栈为空：top[1]==maxsize;s1入栈：stack[++top[0]] = x;s2入栈：stack[–top[1]] = x;栈满判断：top[0]+1==top[1]; 9、用栈来模拟队列：用两个栈来实现，即要将栈的“先进后出”变为队列的“先进先出”。","link":"/2018/08/19/zhan-prc/"},{"title":"windump使用注意事项","text":"之前在准备的时候需要用到windump这个软件，这里就主要记录一下使用过程中遇到的坑吧。。 首先使用windump是需要安装winpcap的，安装就好，然后在命令行下直接使用windump。（要先打开到windump所处的位置）接着windump是直接监听网卡，所以你要选择你监听的网卡，这里也需要注意，你无线上网或者有线上网是不一样的，不然是捕获不到包的。有代理服务器的话也会多出来另外一个选择，所以最好要先运行windump -D先把网卡列表显示出来。（这里切记是大写的D,坑~）之后你再选择了哪一个网卡之后在进行针对性操作。例如，你可以键入： windump -i 2 -q -w C:\\perflogs\\filename\\ -n -C 30 -W 10 -U -s 0 其中， -i是选择你需要监听的网卡号，这里选择的是2号。 -q是指在安静（quiet）模式下。 -w是要创建的文件的前缀。 -n是指不会解析主机名称，以ip地址存储。 -C是此文件大小为百万字节，多了就转移到下一个文件。 -W是指将抓取的包存在一个位于perflogs处的文件中，文件名可以自己起。 -U是指随着每个数据包的保存，它将被写入输出文件。 -s减少了数据包缓冲量，将其设置为零。 （注意:一定要区分大小写，空格.） 抓包成功后，我们可以使用wireshark去分析，wireshark的安装等就不说了，这里主要介绍一下，在你选定一条数据包的时候，双击去查看他的详细信息。 (图片来源网络) 这里有： 帧：这里告诉用户帧号，与数据包有关的时间相关信息，帧长度，帧内的协议以及着色规则。 以太网II：指示数据包的来源和目的地。 Internet协议：包含了源和目标信息以及版本，标题详细信息和生命周期。可以看到源ip地址和目的ip地址。 TCP（transmission control protocol）:这里捕获有关通信中涉及的源端口和目标端口的信息，下一个要查找的序列号以及不同的标记。 HTTP(Hypertext Transfer Protocol):包含http的版本，服务器信息，超时值，连接状态，内容类型和字符集的信息。 基于行的文本数据：这包含了HTML的源代码。 还有一些根据你具体不同的协议有所不同。 windump的使用信息在百度搜索都很有限，感觉少数人是总结的，大部分都是复制黏贴，嗯。。。 为了能够让更多的人快速，更好的上手windump,本文会持续更新。 2018.5.12更新一、关键字表达式是一个正则表达式，Windump利用它作为过滤报文的条件，如果一个报文满足表达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会被截获。在表达式中一般如下几种类型的关键字。 1、第一种是关于类型的关键字，主要包括host，net，port, 例如 host 192.168.0.111，指明 192.168.0.111是一台主机，net 192.168.0.0 指明 192.168.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host. 2、第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,这些关键字指明了传输的方向。举例说明，src192.168.0.94 ,指明ip包中源地址是192.168.0.94 , dst net 192.168.0.0 指明目的网络地址是192.168.0.0。如果没有指明方向关键字，则缺省是src or dst关键字。 3、第三种是协议的关键字，主要包括fddi,ip,arp,rarp,tcp,udp等类型。Fddi指明是在FDDI(分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则Windump将会监听所有协议的信息包。 4、除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是’and’,’&amp;&amp;’;或运算 是’or’ ,’││’；这些关键字可以组合起来构成强大的组合条件来满足人们的需要，下面举几个例子来说明。A想要截获所有192.168.0.94 的主机收到的和发出的所有的数据包： #Windump host 192.168.0.94B想要截获主机192.168.0.94 和主机192.168.0.168 或192.168.0.111的通信，使用命令：（在命令行中适用括号时，一定要 #Windump host 192.168.0.94 and (192.168.0.168 or 192.168.0.111)C如果想要获取主机192.168.0.94除了和主机192.168.0.111之外所有主机通信的ip包，使用命令： #Windump ip host 192.168.0.94 and ! 192.168.0.111D如果想要获取主机192.168.0.94接收或发出的telnet包，使用如下命令： #Windump tcp port 23 host 192.168.0.94 二、Windump的输出结果介绍1、数据链路层头信息 使用命令 #Windump –e host test100 16:20:51.602645 arp who-has TEST100 tell wh16:20:51.602931 arp reply TEST100 is-at 0:1:2:9a:d:2416:20:51.602979 wh.137 &gt; TEST100.137:16:29:26.397806 TEST100.139 &gt; wh.1226: . 4218060367:4218060368(1) ack 4122708076 win 17223分析：16:20:51是显示的时间， 602645是ID号，首先主机wh发出arp请求test100的MAC地址,接着test100返回了它的MAC地址,wh的137与test100 的137端口发送.test100的139端口向wh的1226端口发送数据, ack 4122708076 表明对序列号是4122708076的包进行响应. win 17223表明发送窗口的大小是17223 2、ARP包的WINDUMP输出信息 使用命令 #Windump arp得到的输出结果是：22:32:42.802509 arp who-has 192.168.0.168 tell 192.168.0.9422:32:42.802902 arp reply 192.168.0.168 is-at 0:1:2:9a:d:24分析: 22:32:42是时间戳, 802509是ID号, arp表明是ARP请求包, who-has 192.168.0.168 tell 192.168.0.94 表示主机192.168.0.94请求主机192.168.0.168的MAC地址.接着arp reply 192.168.0.168 is-at 0:1:2:9a:d:24表示主机192.168.0.168收到请求并返回自己的MAC地址. 3、TCP包的输出信息 用WINDUMP捕获的TCP包的一般输出信息是：时间戳&amp;ID号 src.port1&gt;dst.port2 : flags data-seqno ack window urgent options02:53:03是时间戳, 541838是ID号,src &gt; dst:表明从源地址到目的地址, port1,port2代表端口号,flags是TCP包中的标志信息,S 是SYN标志, F (FIN), P (PUSH) , R (RST) “.” (没有标记); data-seqno是数据包中的数据的顺序号, ack是下次期望的顺序号, window是接收缓存的窗口大小, urgent表明数据包中是否有紧急指针. Options是选项. 4、UDP包的输出信息 用WINDUMP捕获的UDP包的一般输出信息是：时间戳&amp;ID号 src.port1&gt;dst.port2: udp lengthUDP十分简单，上面的输出行表明从主机src的port1端口发出的一个UDP数据包到主机dst的port2端口，类型是UDP， 包的长度是length 三、Windump网络数据的过滤不带任何参数的Windump将搜索系统中所有的网络接口，并显示它截获的所有数据，这些数据对我们不一定全都需要，而且数据太多不利于分析。所以，我们应当先想好需要哪些数据，Windump提供以下参数供我们选择数据： 1、Windump后直接跟 数据-链路层上选择协议 包括ip、arp、rarp、ipx都是这一层的。例如：D:>Windump arp //将只显示网络中的arp即地址转换协议信息。 2、-i选择过滤的网络接口 如果是作为路由器至少有两个网络接口，通过这个选项，就可以只过滤指定的接口上通过的数据。例如：src、dst、port、host、net、ether、gateway这几个选项又分别包含src、dst、port、host、net、ehost 等附加选项。他们用来分辨数据包的来源和去向，src host 192.168.0.1指定源主机IP地址是192.168.0.1，dst net 192.168.0.0/24指定目标是网络192.168.0.0。以此类推，host是与其指定主机相关无论它是源还是目的，net是与其指定网络相关的，ether后面跟的不是IP地址而是物理地址，而gateway则用于网关主机。可能有点复杂，看下面例子就知道了：D:>Windump src host 192.168.0.1 and dst net 192.168.0.0/24过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头。D:>Windump ether src 00:50:04:BA:9B and dst……过滤源主机物理地址为XXX的报头(为什么ether src后面没有host或者net？物理地址当然不可能有网络喽)。D:>Windump src host 192.168.0.1 and dst port not telnet过滤源主机192.168.0.1和目的端口不是telnet的报头。 3、ip icmp arp rarp和tcp、udp、icmp这些选项等都要放到第一个参数的位置 用来过滤数据报的类型。例如：D:>Windump ip src……只过滤数据-链路层上的IP报头。D:>Windump udp and src host 192.168.0.1只过滤源主机192.168.0.1的所有udp报头 4、-n不进行IP地址到主机名的转换 四、Windump实战解析 我经常用的命令是windump –n –S,或者windump –n –S –v 或者windump –n-S-vv.-n表示源地址和目的地址不采用主机名的形式显示而采用IP地址的形式;-S是显示TCP/IP的实际进程数,如果不选择这个选项,可能出现的就是近似值,比如:如果现在的进程数是87334271,下一秒变成了多了一个,就会显示出来是87334272.-v和-vv是让机器显示更加全面的信息,显示诸如存活时间/IP的ID等信息.,上一节1.2.2中已经对各参数的详细功能做了介绍.接着我们对TCP握手过程进行嗅探分析,在windows命令行界面下,运行windump,如下:D:>windump –nwindump: listening on\\Device\\Packet_{9D9A4413-7F41-463A-BA3C-B17145F4A626}02:53:03.541838 192.168.0.194.4423 &gt; 192.168.0.168.80: S 4057648491:4057648491(0) win 16384 (DF) 02:53:03.542005 192.168.0.168.1234 &gt; 192.168.0.194.4423: S 1391008532:1391008532(0) ack 4057648492 win 17520 (DF) 02:53:03.542167 192.168.0.194.4423 &gt; 192.168.0.168.1234: . ack 1 win 17520 (DF) 当TCP三次握手不成功又是怎么样的呢?接着telnet到一台没有开telnet服务的计算机上面,插看windump抓获的数据包C:\\Documents and Settings\\wh&gt;telnet 192.168.0.194Connecting To 192.168.0.194…Could not open a connection to host on port 23 : Connect failed D:>windump –nwindump: listening on\\Device\\Packet_{9D9A4413-7F41-463A-BA3C-B17145F4A626}18:19:45.278916 arp who-has 192.168.0.194 tell 192.168.0.168 18:19:45.279090 arp reply 192.168.0.194 is-at 0:d0:f8:38:de:ab 18:19:45.279108 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF) 18:19:45.279269 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 2869223553 win 0 18:19:45.769542 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF)18:19:45.769757 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 1 win 018:19:46.316397 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF)18:19:46.316636 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 1 win 0以上是利用Windump对TCP的三次握手过程进行分析,Windump的参数很多，功能也非常强大,实际运用中根据实际的需求,来设置参数,获得你所需要的信息.相信每次使用都会有不同的收获． 五、命令参数-a将网络和广播地址转化为名称-c接收指定数据包后退出-d接收人可读的包匹配编译代码到标准输出，然后停止-dd以C程序分段方式捕获包匹配代码-ddd以十进制数据形式捕获包匹配代码-e在每个捕获行打印链路层头标-Ealgo:secret为解密IPSE ESP包使用算法。算法可以是des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或none。默认值是desc-cbc。只有当TCPDUMP编译时使用激活加密选项时，才可以解密数据包。Secret是ESP密匙是ASCII码。当前还不能认为一定是二进制值。该选项是以RFC2406ESP为假设，而不是RFC1827 ESP。只用于调试，不鼓励用真正的密码作为选项。当你在PS或其他场合，把IPSEC密码写在命令行上时，会被他人看到。-f不用符号而用数字方式输出外部英特网地址-F使用文件作为过滤表达式的输入。命令行的其他部分会被忽略。-i在接口上监听。如果没有指定，TCPDUMP将搜索系统接口列表中最小，被配置激活的接口（LOOPBACK接口除外）。可用最先匹配替换这种关系。在WINDOWS中接口可以是网卡的名称，或是网卡的号码（-D参数可显示该号码）。 内核为2。2或其后的LINUX系统，参数“ANY”可以获取所有接口的数据。应注意的是在混乱模式下不能使用“ANY”参数。-l标准输出行缓存。如果你想在捕获数据时查看的话，这个参数很有用。例如：“tcpdump -l │ tee dat or tcpdump -l &gt; dat &amp; tail -f dat.” n 不要将地址（如主机地址，端口号）转换为名称 -N 不要打印主机名称的域名限定。如：如果你使用该参数，TCPDUMP会输出“NIC”而不是“NIC。DDN。MIL”。 -m 从文件模块中载入SMI MIB 模块定义。这个选项可以为TCPDUMP载入多个MIB模块 -O 不要运行包匹配代码优化器。只有在你怀疑优化器有问题时可以使用这个参数。 -p 不要让接口处于“混乱”模式。注意接口可能由于其他原因处于“混乱”模式；因此“-p”不能用作以太网络主机或广播的缩写。 -q 快速（安静？）输出。打印较少的协议信息，因此输出行更短。 -r 从文件中读取包（与参数据-W一起使用）。如果文件是“-”就使用标准输入。 -s 不使用默认的68个字节，更改从每个包中获取数据的字节数量（ SunOS系统实际最小为96）。对于IP，ICMP，TCP和UDP包68个字节已足够，但是对命名服务和NFS包，他们的协议会被截断（见下面）。包被截断是因为在使用参数[│proto]输出时指定受限制的快照，proto是被截断协议层的名称。注意如果使用大的快照会增加处理包的时间，并且明显地减少包的缓存数量。也许会导致包的丢失。你应该将snaplen 设置成你感兴趣协议的最小数。当snaplen 为0时接收整个包。-T根据表达式将选中的数据包表达成指定的类型。当前已有的类型有CNFP（Cisco的网络流量协议），rpc（远端程序调用），rtp（实时程序协议），rtcp（实时程序控制协议），snmp（简单网络管理协议），vat（可视单频工具），和wb（分布式白板）。-R假设ESP/AH包遵守旧的说明（RFC1825到RFC1829）。如果该参数被指定，TCPDUMP不打输出域。因为在ESP/AH说明中没有协议版本，TCPDUMP就无法推断出其版本号。-S输出绝对TCP序列号，而不是相对号。-t每个捕获行不要显示时间戳。-tt每个捕获行显示非格式化的时间时间戳。-v详细输出。例如，显示生存时间TTL，标识符，总长度和IP数据包的选项。也进行额外的包完整性较验，如验证IP和ICMP的头标较验值。-vv更为详细的输出。例如，显示NFS中继包中的其他域。-vvv很详细的输出。如，完全输出TELNET SB… SE选项。带-X参数的TELNET，打印并以十六进制输出。-w不对原始数据包解析打印而是转到文件中去。以后可用-r选项打印。当文件名为“-”表示标准输出。-x以十六进制（去除链路层头标）输出每个数据包。输出整个包的小部分或snaplen 个字节。-X输出十六进制同时，输出ASCII码。如果-x也被设置，数据包会以十六制/ASCII码显示。这对于分析新协议非常方便。如果-x也没有设置，一些数据包的部分会以十六制/ASCII码显示。Win32特殊扩展-B以千字节为单位设置驱动缓存。默认缓存为1M（即1000）。如果在获取数据包时有数据丢失，建议使用该参数增大核心缓存大小，因为驱动缓存大小对数据捕获性能有很大影响。-D显示系统上可用的网卡列表。该参数将返回每块网卡的号码，名称和描述。用户可以输入“WinDump –i 网卡名称”或“WinDump –i 网卡号码”。如果机器有多块网卡，不带参数的WINDUMP命令会从系统的第一块可用网卡开始。","link":"/2018/03/09/windump-use/"}],"tags":[{"name":"data-structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"web-scraping","slug":"web-scraping","link":"/tags/web-scraping/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"crawler","slug":"crawler","link":"/tags/crawler/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"tcp/ip","slug":"tcp-ip","link":"/tags/tcp-ip/"},{"name":"windump","slug":"windump","link":"/tags/windump/"},{"name":"OJ","slug":"OJ","link":"/tags/OJ/"}],"categories":[]}