{"pages":[{"title":"","text":"CS专业，渴望继续当个学生，男 追求自由，喜爱自然目前还没有找到自己感兴趣的东西，也还没有达到那个地步吧。。。总之加油吧， 远远还没有到能够输出的程度，只是找个地方整理自己的所学，也顺便写点关于生活的东西。 才学疏浅，正在努力~~ aisleep.xyz或fanandli.github.io所发布的内容采用知识共享署名-非商业性使用 4.0 国际许可协议进行许可。","link":"/about/index.html"}],"posts":[{"title":"Requests库详解","text":"真正危险的不是计算机开始像人那样去思考，而是人类开始像计算机一样思考。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——西德尼·哈里斯（Sydney Harris） python爬虫之旅之第二站~~ Requests库是经常用的库，比urllib更加方便。首先先领略一下使用Requests的方便之处：1234567import requestsresponse=requests.get('http://aisleep.xyz')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 这里的第6行和在urllib中使用read的作用是一样的，在urllib中还要使用.decode使得其变成字符串类型。在Requests中就很方便了，直接使用text就可以了。在最后一行中的cookies获取中也比在urllib中方便很多。 再看requests中还提供了很多比较方便的各种请求方式：123456import requestsrequests.post(\"http://httpbin.org/post\")requests.put(\"http://httpbin.org/put\")requests.delete(\"http://httpbin.org/delete\")requests.head(\"http://httpbin.org/get\")requests.options(\"http://htpbin.org/get\") 可见想要进行一个post请求，直接requests.post就好。 好，Requsets的方便之处你现在也稍微感受到一点了，现在在仔细的看一下他的使用。 get请求 123import requestsresponse=requests.get('http://aisleep.xyz')print(response.text) 这里就是一个最简单的一个get请求。那如果我们还要传一些自己的参数怎么设置呢：123import requestsresponse=requests.get(\"http://httpbin.org/get?name=lifan&amp;age=23\")print(response.text) 也可以这样：1234567import requestsdata=&#123; 'name':'lifan', 'age':23&#125;response=requests.get(\"http://httpbin.org/get\",params=data)print(response.text) 第一种方法比较繁琐一点，需要加一个?再在多个参数之间再加上&amp;就可以。第二种方法就是自己先构造一个字典，然后传给params就可以方便的构造一个get请求的url，不需要再手动输入了。 解析json 12345import requestsresponse=requests.get(\"http://httpbin.org/get\")print(type(response.text))print(response.json())print(type(response.json())) 这是直接提供的了个解析json格式的方式，其实第4行就相当于进行一个这样的调用：print(json.load(response.text))(在前面再加一句import json) 获取二进制数据 12345678import requestsresponse=requests.get(\"https://github.com/favicon.ico\")print(type(response.text),type(response.content))print(response.text)print(response.content)with open('favicon.ico','wb') as f: f.write(response.content) f.close() 这里使用content获取二进制数据，比如图片，视频等，第6行开始到结束做的是保存这个二进制文件的工作：打开一个文件，wb是说明对这个文件进行操作的方式为“以二进制格式打开一个文件只用于写入”，as f是帮这个文件起了一个别名，f.write是写入到打开的文件中，最后要关闭文件。 header添加 添加headers主要是模拟成你是浏览器要求的访问，防止被浏览网站所禁止。这里添加一个浏览器信息就好1234567import requestsheaders=&#123; 'User-Agent':'Mozilla/5.0 (Macintosh; intel Mac OS X 10_11_4) AppleWebKit/537.36(KHTML,like Gecko)Chrome/52.0.2743.116 Safari/537.36'&#125;response=requests.get('http://www.zhihu.com',headers=headers)print(response.text) 基本的post请求 1234import requestsdata=&#123;'name':'lifan','age':'23'&#125;response=requests.post(\"http://httpbin.org/post\",data=data)print(response.text) 这里就明显看出比urllib中的操作方便很多。 response属性 1234567import requestsresponse=requests.get('http://www.baidu.com')print(type(response.status_code),response.status_code)print(type(response.headers),response.headers)print(type(response.cookies),response.cookies)print(type(response.url),response.url)print(type(response.history),response.history) 运行结果为：12345&lt;class &apos;int&apos;&gt; 200&lt;class &apos;requests.structures.CaseInsensitiveDict&apos;&gt; &#123;&apos;Server&apos;: &apos;bfe/1.0.8.18&apos;, &apos;Date&apos;: &apos;Tue, 03 Apr 2018 07:59:03 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Last-Modified&apos;: &apos;Mon, 23 Jan 2017 13:27:36 GMT&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Cache-Control&apos;: &apos;private, no-cache, no-store, proxy-revalidate, no-transform&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Set-Cookie&apos;: &apos;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;&#125;&lt;class &apos;requests.cookies.RequestsCookieJar&apos;&gt; &lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;&lt;class &apos;str&apos;&gt; http://www.baidu.com/&lt;class &apos;list&apos;&gt; [] 状态码判断 123import requestsresponse=requests.get('http://www.baidu.com')exit() if not response.status_code==requests.codes.ok else print('request successfully') 这个状态码的判断的意思是，在requests.codes里面他将很多的状态码对应了一些方便记忆的单词，比如，将200对应了ok这个词，404对应了not_found这个词，这样我们只要查表不需要记住这些状态码就行了，第3行的代码的意思是：如果response的状态码不等于ok就退出，如果等于，就打印request successfully。","link":"/2018/04/03/Requests-webscraping/"},{"title":"数组和字符串例题","text":"(持续更新）list:1：Score (ACM/ICPC Seoul2007,UVa1586) ================================================================= 1：Score(ACM/ICPC Seoul2007,UVa1586) 给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分 别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的 分子量为94.108g/mol. 分析：题目中所说的原子只有4种，可以用数组存储，建立起原子和原子量的关系。最基本的是要对数字和原子进行区别处理。分子式的计算需要注意到原子后面是否跟了数字，如果是数字就需要乘以数字前面的原子值。 代码：12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;char s[1024];int main()&#123; double a[128]; a['C']=12.01; a['H']=1.008; a['O']=16.00; a['N']=14.01; int testcase; scanf(\"%d\",&amp;testcase); while(testcase--)&#123; scanf(\"%s\",s);//notice int n=strlen(s); double result=0; for(int i=0;i&lt;n;)&#123; int ele=s[i]; int num=0; i++; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')&#123; num=num*10+s[i]-'0'; i++; &#125; if(num==0) num=1; result+=a[ele]*num; &#125; printf(\"%.3lf\\n\",result); &#125; return 0;&#125; 注意：数组的一些基本的操作。strlen()数组在不同的地方定义影响不同。在mian函数外和在main函数里定义的区别。for()循环语句的灵活使用。a[‘C’]中的C用的是ASCII码.","link":"/2019/04/15/array-and-string-exercises/"},{"title":"C++中的重载","text":"c++的重载的注意事项：1，引用作为重载的条件，举例：12345678910#include&lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout&lt;&lt;\"func(int &amp;a)调用\"&lt;&lt;endl;&#125;int main()&#123; int a=10; func(a); return 0;&#125; 与12345678910#include&lt;iostream&gt;using namespace std;void func(const int &amp;a)&#123; cout&lt;&lt;\"func(const int &amp;a)调用\"&lt;&lt;endl;&#125;int main()&#123; int a=10; func(a); return 0;&#125; 调用的是上面一个版本，但是如果main函数中是这样写的话:func(10);return 0;那么调用的就是下面这个版本，这里的原因主要通过引用的原理很好理解：int &amp;a=10;不合法，因为引用只能是栈或者堆中的数据，而10是常量，是放在常量区中的，所以不合法。而const int &amp;a=10;是合法的。 2，函数重载碰到默认参数,举例：1234567891011121314#include&lt;iostream&gt;using namespace std;void func(int a,int b=10)&#123; cout&lt;&lt;\"func(int a,int b=10)调用\"&lt;&lt;endl;&#125;void func(int a)&#123; cout&lt;&lt;\"func(int a)调用\"&lt;&lt;endl;&#125;int main()&#123; func(10); return 0;&#125; 上面这种情况也会报错，因为默认参数在这种情况，上下两个func既能满足重载，又能因为默认参数导致编译器不知道调用谁。理解了默认参数的使用就可以避免。","link":"/2019/05/23/c-chongzai/"},{"title":"data structure 杂物间","text":"小插曲：写作风格想渐渐地由便于理解的语言向最精简的叙述方式转变。（严谨的风格保持不变且在努力提高中：）） 整理一下数据结构所涉及到的一些C或C++中的基础知识。 结构型 结构型的作用就是满足对数据类型的需求的补充，我们可以自己创造合适自己的数据类型，例如现有int,char等数据类型，我们可以：12345typedef struct &#123; int a ; char b ;&#125;typeA; 这样就定义了一个typeA类型的数据类型。 他的使用需要注意：typeA a[3]这句话是定义了一个typeA类型的数组a[]。这个数组是由a[0]，a[1]，a[2]组成，且a[0]中由2个分别为int，char组成。使用a[0].a调用。 所以，这里的a[]可以理解为是一个二维数组了。需要理解一下。 使用自己定义的结构型构造结点 构造一个链表结点，分为两步：第一步：构造出需要的结构型（链表结点的定义）： 12345typedef struct Node&#123; int a; struct Node *next; &#125;Node; 构造出一个Node型，里面是一个int型的数据域，一个是Node型的指针。 第二步：构造出结点（用一个指针指向他）：12Node *p;p=(Node*)malloc(sizeof(Node)); 定义了一个p指针指向了结点，结点构造成功。结点的名字为p，这里的第2句的意思自行google。如果我们想要取出这个结点的data赋给x，那么应该这样做：x=p-&gt;data，或者可以这样x=(*p).data这里主要是指针的使用注意点。注意，这里的p命名了两个东西：一个是结点，另一个是指向这个结点的指针。所以p既是指针名又是结点名。 #define和typedef的使用 请看实例：123456789101112#define error 1#define ok 0typedef bool statustypedef int elemtypestatus f(elemtype a)&#123; if (a&gt;0) return error; else return ok;&#125; 上面这个代码其实就是这个意思： 1234567bool f(int a )&#123; if (a&gt;0) return 1; else return 0;&#125; typedef是为变量起一个新名字，#define则是定义一个常量，也可以理解为为常量起一个新名字。这样的用法的意义是可以当你有多个地方的int型的变量想要修改为char型的时候，不要一个一个的去修改，直接将typedef int xx改成typedef int yy就可以一下子全部修改了。 还有需要补充的小知识点再补充。。","link":"/2018/04/06/data-structure-1/"},{"title":"C++中的友元","text":"友元的功能是让一个函数或者类，能够访问另一个类中的私有成员。 实现方法： 1.全局函数作为友元：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;class Building&#123;//类friend void goodfri(Building *building);//这句话就是让全局函数做Building类的友元//这样，private的m_bedroom才可以被goodfri访问 public: Buliding()&#123;//构造函数 this-&gt;m_sittingroom=\"keting\";//在其中赋值 this-&gt;m_bedroom=\"woshi\"; &#125; public: string m_sittingroom; private: string m_bedroom;&#125;;void goodfri(Building *building)&#123;//全局函数 cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_sittingroom&lt;&lt;endl; cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_bedroom&lt;&lt;endl;&#125;void test01()&#123; Building b;//创建一个Building型的b goodfri(&amp;b);&#125;int main()&#123; test01(); return 0;&#125; 2.类做友元：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;class Building;//提前声明一下有Building这个类class goodfri&#123; public: goodfri();//构造函数 void visit();//一个普通函数 private: Building *building;//一个Building类型的指针&#125;;class Building&#123; friend class goodfri;//这句话就实现了类做友元，告诉Building,goodfri类是你的朋友(友元) public: Building();//构造函数 public: string m_sittingroom; private: string m_bedroom;&#125;;Building::Building()&#123; //在类外面写构造函数 this-&gt;m_sittingroom=\"keting\"; this-&gt;m_bedroom=\"woshi\";&#125;goodfri::goodfri()&#123;//在类外面写构造函数 building=new Building;//创建了一个新的对象，new返回的是这个新的对象的地址，所以用指针来接收 //building指针是在goodfri中的private类型&#125;void goodfri::visit()&#123; cout&lt;&lt;\"now in:\"&lt;&lt;building-&gt;m_bedroom&lt;&lt;endl; cout&lt;&lt;\"now in:\"&lt;&lt;building-&gt;m_sittingroom&lt;&lt;endl;&#125;void test01()&#123; goodfri hfri;//创建了一个goodfri类型的对象hfri hfri.visit();&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125; 3.成员函数作为友元：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;class Building;class goodfri&#123; public: goodfri();//构造函数 void visit(); void visit2();//只是用来和visit函数做对比的 private: Building *building;&#125;;class Building&#123; friend void goodfri::visit();//这句话就是让成员函数visit为友元 public: Building(); public: string m_sittingroom; private: string m_bedroom;&#125;;Building::Building()&#123; this-&gt;m_bedroom=\"woshi\"; this-&gt;m_sittingroom=\"keting\";&#125;goodfri::goodfri()&#123; building=new Building;&#125;void goodfri::visit()&#123; cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_sittingroom&lt;&lt;endl; cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_bedroom&lt;&lt;endl;&#125;void goodfri::visit2()&#123; cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_sittingroom&lt;&lt;endl; //cout&lt;&lt;\"now is:\"&lt;&lt;building-&gt;m_bedroom&lt;&lt;endl;这句话不能访问，&#125;void test01()&#123; goodfri hhh; hhh.visit();&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125;","link":"/2019/05/27/c-friend/"},{"title":"c++中的多态","text":"多态分为两类1.静态多态: 函数重载和运算符重载属于静态多态，复用函数名2.动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别：1.静态多态的函数地址早绑定 - 编译阶段确定函数地址2.动态多态的函数地址晚绑定 - 运行阶段确定函数地址 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;class Animal&#123; public: virtual void speak()&#123;//在成员函数前面加上virtual就变为了虚函数 //编译器就不能确定函数调用了 cout&lt;&lt;\"animal speak\"&lt;&lt;endl; &#125;&#125;;class Cat:public Animal&#123;//继承了animal这个类 public: void speak()&#123;//子类重写了父类中的虚函数 cout&lt;&lt;\"cat speak\"&lt;&lt;endl; &#125;&#125;;class Dog:public Animal&#123; public: void speak()&#123;//也重写了父类中的虚函数 cout&lt;&lt;\"dog speak\"&lt;&lt;endl; &#125;&#125;;void dospeak(Animal &amp;animal)&#123;//Animal &amp;animal=cat animal.speak();//父类的引用指向了子类对象， //首先要知道c++中运行父子之间的类型转换，不需要强制类型转换 //父类的引用或指针可以直接指向子类对象 &#125;void test01()&#123; Cat cat; dospeak(cat); Dog dog; dospeak(dog);&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125;// 总结：// 多态满足条件：// 有继承关系， 子类重写父类中的虚函数// 多态使用条件：父类指针或引用指向子类对象// 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 上面的代码输出为：cat speakdog speak 我们再来看一下本质：Animal的内部结构在变为虚函数后是这样的：123456789class Animal size(4) +--- 0 |&#123;vfptr&#125; +---Animal::$vftable@: |&amp;Animal_meta |00 |&amp;Animal::speak 变为虚函数后，由vfptr这个指针指向vftable中，Cat类重写过后内部是这样的：12345678910class Cat size(4) +---0 | +---base class Animal0 | | &#123;vfptr&#125; | +--- +--- Cat::$vftable@: | &amp;Cat_meta | 00 | &amp;Cat::speak 由vfptr指针指向vftable，其中因为被重写过了，已经由上面的&amp;Animal::speak变为&amp;Cat::speak,变为虚函数，编译器就不能确定函数调用了，又经过这样的重写，指向了Cat,这样就真正实现了多态。 ======下面再介绍纯虚函数的概念：在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为抽象类。 抽象类特点：无法实例化对象，子类必须重写抽象类中的纯虚函数，否则也属于抽象类实例：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;class Base&#123; public: virtual void func()=0;//这样就是一个纯虚函数&#125;;//此时Base被称为抽象类class Son:public Base&#123;//这里Son继承了Base类 public: virtual void func()&#123; cout&lt;&lt;\"func diaoyong\"&lt;&lt;endl; &#125;//这里就是对父类（抽象类）进行了重写&#125;;void test01()&#123; Base *base=NULL; //base=new Base; 错误，抽象类无法实例化对象 base = new Son;//这个是可以实例化对象的，因为Son里面重写了(能用父类指向子类) base-&gt;func(); delete base;//销毁&#125;int main()&#123; test01(); system(\"pasue\"); return 0;&#125; ======在多态的使用，如果子类中的属性有开辟到对去了，那么父类指针在释放时调用不到子类的析构函数，所以c++中将父类的析构函数改为虚析构函数或者纯虚析构函数来解决此问题。 两者的共性：1.都可以解决父类指针释放子类对象的问题2.但是都需要具体的函数实现，也就是说是不能自动生成两类函数的 两者的区别：1.如果是纯虚析构函数，该类属于抽象类，无法实例化实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;class Animal&#123; public: Animal()&#123;//构造函数 cout&lt;&lt;\"Animal gouzao func\"&lt;&lt;endl; &#125; virtual void speak()=0;//虚函数 // virtual ~Animal()&#123;//虚析构函数 // cout&lt;&lt;\"Animal virtual xigou func\"&lt;&lt;endl; // &#125; virtual ~Animal()=0;//纯虚析构函数&#125;;Animal::~Animal()&#123;//纯虚析构必须要有一个函数的具体实现，所以，//这里必须要对上面的纯虚析构进行重写 cout&lt;&lt;\"Animal pure virtual xigou func\"&lt;&lt;endl;//对纯虚析构函数的重写&#125;class Cat:public Animal&#123; public: Cat(string name)&#123;//构造函数 cout&lt;&lt;\"cat gouzao func have name\"&lt;&lt;endl; m_name=new string(name); &#125; // Cat()&#123; // cout&lt;&lt;\"Cat gouzao func\"&lt;&lt;endl; // &#125; virtual void speak()&#123;//虚函数 cout&lt;&lt;*m_name&lt;&lt;\"cat speak\"&lt;&lt;endl; &#125; ~Cat()&#123; cout&lt;&lt;\"Cat xigou func\"&lt;&lt;endl; if(this-&gt;m_name!=NULL)&#123; delete m_name; m_name=NULL; &#125; &#125; public: string *m_name;&#125;;void test01()&#123; Animal *animal=new Cat(\"tom\");// animal-&gt;speak(); delete animal;&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125; 总结： 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 拥有纯虚析构函数的类也属于抽象类","link":"/2019/05/28/c-duotai/"},{"title":"图——最小生成树","text":"由一个图按照某种规则导出的一个树，叫生成树。最小生成树：构成这个生成树的所有分支的权值和最小。 prime算法求最小生成树的代码：1234567891011121314151617181920212223242526272829void Prim(int n ,float MGraph[][n],int v0,float &amp;sum) //顶点个数，带权图，构造生成树的起始顶点，存储最小权值和（代价）&#123; int lowCost[n],vSet[n]; int v,k,min; for(int i=0;i&lt;n;++i) &#123; lowCost[i]=MGraph[v0][i]; //lowCost[]指向vo初始点的同一行的不同列的顶点 vSet[i]=0; &#125; v=v0; //v指向第一个结点， vSet[v]=1; //已经并入，所以标记设置为1 sum=0; //初始化 for(int i=0;i&lt;n-1;++i) &#123; min=INF; //min初始化为无穷大 for(int j=0;j&lt;n,++j) if(vSet[j]==0&amp;&amp;lowCost[j]&lt;min) &#123; min=lowCost[j]; k=j; &#125; vSet[k]=1; v=k; //v指向如今刚进入的结点 sum+=min; //min的值累加到sum for(int j=0;j&lt;n;++j) //更新lowCost数组 if(vSet[j]==0&amp;&amp;MGraph[v][j]&lt;lowCost[j]) lowCost[j]=MGraph[v][j]; &#125;&#125; lowCost[]数组是用来存储当前生成树到图中其余顶点的边的最小权值。vSet[i]为1时就说明已经被并入生成树中，为0就没有并入。v指向刚并入的顶点。 v0是最小生成树的初始结点，所以v=v0 kruskal算法 把当前未被并入的，且并入后不会产生环的最小边进行并入。如何检测并入后到底会不会产生环呢？就用到了“并查集”。所谓的并查集，就是通过这些图中的点构造出来的树，每一个结点在相连的时候，要一直查到根结点，如果根结点不相同，说明图中选取边之后不会产生环，所以可以选择这个这个结点的边。 相关的存储结构: 代码实现：","link":"/2018/05/01/data-structure-13/"},{"title":"图——拓扑排序","text":"拓扑排序 AOV网，描述了一种有实际意义的过程，所以结点之间有了先后顺序，其次是结点之间是没有环的。如何导出正确的结点之间的顺序，就需要拓扑排序。三个步骤: 用邻接表来存储图，且修改顶点结构体为123456typedef struct&#123; int data; int count; //指示当前结点的入度 ArcNode* first;&#125;VNode; 拓扑排序的代码实现：123456789101112131415161718192021222324252627282930313233int TopSort(AGraph *G)&#123; int i ,j ,n=0; //n统计当前已经输出的顶点个数 int stack[maxSize],top=-1; //定义一个栈，保存所有入度为0的顶点 ArcNode* p; //遍历 for(i=0;i&lt;G-&gt;n;++i) if(G-&gt;adjList[i].count==0) stack[++top]=i; //将入度为0的压栈 while(top!=-1)//若栈不为0， &#123; i=stack[top--]; //取出顶点，等效于将这个顶点删除， ++n; //记录取出的点的个数， std::cout&lt;&lt;i&lt;&lt;\" \"; //输出这个顶点 p=G-&gt;adjList[i].first; //遍历刚才出栈顶点的所有边， while(p!=NULL) &#123; j=p-&gt;adjV; //通过这些边找到其相邻顶点， --(G-&gt;adjList[j].count); //修改其count if(G-&gt;adjList[j].count==0) //然后将count为0的点入栈，以待输出 stack[++top]=j; p=p-&gt;next; &#125; &#125; if(n==G-&gt;n) //输出的顶点个数是否为图中顶点的个数 return 1; //相等则拓扑排序完成 else return 0;&#125; 逆拓扑排序 如何用深度优先遍历实现逆拓扑排序深度优先遍历： 以此实现逆拓扑排序：","link":"/2018/05/15/data-structure-10/"},{"title":"图——关键路径","text":"关键路径AOE网，(activate on edge)1为源点，6为汇点。所谓关键路径，就是在AOE网中从源点开始到汇点结束的具有最大路径长度的那个路径就为关键路径。 首先由事件的拓扑排序和逆拓扑排序求出事件最早发生时间，规定第一个结点的最早发生时间为0，这里所谓的最早发生时间的最早，是指在这个事件可以发生的前提下最早发生的时间，例如结点6首先他要发生，得必须等到3,4结点都发生完了，才可以考虑发生，因为如在现实生活中是一样的，事件6可以在事件3,4完成的前提下发生，他只是有发生的条件了，并不是说就一定发生了，我可以先等一会，然后再发生，那样，只要事件6的发生时间大于等于6他都可以发生，所以，他最早发生时间为6，这里所谓的最早是指在这个结点能有发生的前提下，不再等待任何多余的时间，即最早。 事件最晚发生时间：这个概念，首先我们由上面可知事件6的发生时间只要大于等于6就可，可是在现实生活中，一个事件一直拖着毫无意义。所以我们人为规定最后一个事件的（这里为事件6）最晚发生时间就等于最早发生时间。在此前提下我们再去求之前事件的最晚发生时间。如果没有这个规定，事件6之前的事件都可以往后拖了。 活动的最早发生时间：活动的最早发生时间为引出这个活动的事件（ -&gt;活动）的最早发生时间。如活动a2，引出这个活动的事件只有事件1，那么这是事件1的最早发生时间就是活动a2的最早发生时间为0。 活动的最迟发生时间：活动的最迟发生时间为这个活动引出的事件（活动-&gt; ）的最迟发生时间减去这个活动持续的时长。 关键路径就是活动的最早发生时间等于活动的最晚发生时间的那些活动构成的路径，为关键路径。","link":"/2018/05/15/data-structure-11/"},{"title":"希尔排序","text":"首先我们来先看一个过程， 对于这个我们首先取五为一个子序列，将13和49进行了交换，就这样一直移动到最后，将指到的两个数字进行排序，接着我们取5的一半，下取整，就是2.以此再对子序列中的值进行大小比较。也一直移动到最后，最后再以2的一半的下取整，为1，划分为子序列对其元素进行大小排序。 下面看一下代码事例：gap是增量，待排序的规模n是10，所以gap=n/2=5,i的范围是从gap到最后一个关键字，i是用来选出无序序列中的一个关键字，然后将其插入到有序序列中的合适的位置的。 外层的for循环是改变选出的子序列的长度大小，刚开始是5，后来是2，再后来是1。然后内层的for循环是对子序列中的变量进行大小比较排序，满足条件就将其进行互换位置。以第一次操作为例，将arr[5]与arr[j=0]比较大小，然后满足条件就转换他们的位置。以此类推。","link":"/2018/05/18/data-structure-14/"},{"title":"直接插入，简单选择和冒泡排序","text":"直接插入排序 insertSort[]数组用来存储我们要排的关键字，n为关键字的个数，temp用来暂时存储我们当前要插入的排序的关键字。第一个for循环是从i=1开始，是因为我们规定认为初始状态的第0个元素为有序序列，第0个元素之后的元素为无序序列。我们的思路是从无序序列中逐次扫描，与有序序列中的大小进行比较，从而将他们插入到合适的位置中去。因为箭头总是指向带插入位置的前一个位置，所以我们要arr[j+1]=temp 12345678910111213141516void insertSort(int arr[],int n) &#123; int temp,i,j; for(i=1;i&lt;n;++i) &#123; temp=arr[i]； j=i-1; //j指向有序序列中的最右边的一个元素 while(j&gt;=0&amp;&amp;temp&lt;arr[j]) &#123; arr[j+1]=arr[j]; --j; //j是从右往左扫描有序序列 &#125; arr[j+1]=temp; //将temp中的待排关键字插入 &#125;&#125; 简单选择排序 首先这个排序的思想是：首先初始状态是从这个所有元素中选择出最小的元素，将他与这个整体中的第一个元素互换，这样，这个元素就为有序序列，然后再从已经除去被排序好的那个元素的无序序列中再选择出一个最小的元素，将这个元素与当前无序序列的第一个元素交换位置，此时有序序列的长度变为2，以此循环，将其变为有序。 123456789101112131415void selectSort(int arr[],int n)&#123; int i,j,k; int temp; for(i=0;i&lt;n;++i) &#123; k=i; //循环取最值 for(j=i+1;j&lt;n;++j) if(arr[k]&gt;arr[j]) k=j;//只是用k来存储最小元素在数组中的下标 temp=arr[i]; //将当前元素的最小值与无序序列中的第一元素互换位置 arr[i]=arr[k]; arr[k]=temp; &#125;&#125; 冒泡排序 首先我们从一个序列中依次从左往右扫描，如果当前的元素，比当前元素的前一个元素小的话，那么就交换这两个元素，这样一直扫描到最后，这样一趟扫描下来，目前最大的元素就会被移动到最右边，此时，就将最右边设为有序序列。接着，如此循环，将前面的无序序列的元素扫描，将最大的元素又移动到最右边，并入有序序列。以此即可。不过我们为了提高效率，发现，如果我们在扫描的时候，如果没有发生元素的交换的话，就说明无序序列也变为有序了。所以我们可以设置一个标记去标记（flag）这种情况是否发生。 12345678910111213141516171819void bubleSort(int arr[],int n)&#123; int i,j,flag; int temp; for(i=n-1;i&gt;=1;--i) //无序序列逐渐缩小 &#123; flag=0; for(j=1;j&lt;=i;++j) if(arr[j-1]&gt;arr[j]]) &#123; temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; flag=1; &#125; if(flag==0) return; &#125;&#125;","link":"/2018/05/17/data-structure-12/"},{"title":"快速排序","text":"首先以几个图片大致说一下这个算法的思路是什么： 然后看以下代码事例：其中arr[]是装关键字的数组，low和high是处理关键字的范围，初始就为整个数组。if(low&lt;high)成立才递归，很明显是因为low&gt;high了，说明子序列就不存在了。 123456789101112131415161718192021222324252627void quickSort(int arr[],int low,int high)&#123; int temp; int i=low;j=high; if(low&lt;high) &#123; temp=arr[low]; while(i&lt;j) &#123; while(j&gt;i&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; quickSort(arr,low,i-1); quickSort(arr,i+1,high); &#125;&#125; 这里我说明一下这段代码的大致意思。首先先讲i,j指向low,high。temp先指定low处的关键字，然后第10行的while循环，这个循环的主要目的是找到一个arr[j]处的关键字比temp指的小，不然就一直往前移（–j），如果找到了，且满足if（i&lt;j），就将这个小的值，移到temp处，即往前移，然后让i往后移。同样的道理，在i处是找到比temp大的数就停下来，让这个大的数往后移，即与arr[j]交换，j往前再走一步。如此一直循环，直到不满足i&lt;j。然后退出第8行的循环，将此时的temp赋给arr[i]。 接着到了24行，进入递归，level1（0,3,7）是为了方便理解自己写出来的，指出范围为0到7，且i，j指向3。在第一次进入这个递归的时候，low=0，i-1=2；所以，如图所示。 i=0，j=2.temp暂存arr[0]=27。然后下面的while循环同上面的过程一样。一直走到第23行，循环完之后，i和j同时指向了1。所以我们可以记录为level2（0,1,2），代表这次是在0到2中循环且最后落在在了1这个位置。然后我们又来到了第24行，又进入了递归，此时i=j=0,进入递归，在第5行if（low&lt;high）处就不满足条件了，就直接跳出来了一直到代码底此时的记录应该为level3(0, ,0)1。然后，我们跳出来了，我们就得从递归函数那出来，此时我们的level还是上一个，即level2（0,1,2）,然后程序执行来到第25行，又得进入一个递归，此时i=2，high=2.不满足第5行的if。就跳出来，然后从这个递归入口函数又出来，此时为level3(0, ,0)2。然后回到上一个递归，即到了level3（0，，0）1。上面已经知道了，这一层也不满足条件直接跳过，所以我们来到了level1(0,3,7)。然后执行第25行，i=4，j=7。然后进入if判定进行循环，接着个判定大小移动的操作和上面的步骤一样。此时level(4,6,7)2。然后在 准备进入递归入口函数，然后循环，然后再出递归，。。。以此再操作。","link":"/2018/05/20/data-structure-15/"},{"title":"排序算法习题","text":"1.设计一个算法指出在一个无序关键字序列中的某个关键字是该序列中的第几个关键字（从小到大数），序列中关键字均为整数类型，且各不相同，要求比较的次数尽可能的少。12345678910111213141516171819int getPos(int arr[],int n,int k)&#123; int i=0,j=n-1; int temp; while(i&lt;=j) &#123; while(i&lt;n&amp;&amp;arr[i]&lt;=k) ++i; //把比这个数小的放在左边 while(j&gt;=0&amp;&amp;arr[j]&gt;k) --j; //把比这个数大的放在右边 if(i&lt;j) &#123; temp=arr[i]; //逻辑上为啥就能找到这个数的位置的原因不知道。。 arr[i]=arr[j]; arr[j]=temp; ++i; --j; &#125; &#125; return j+1;&#125; 2.设计一个用二分查找法来找插入位置的改进的插入排序算法??。123456789101112131415161718192021void BSSort(int arr[],int n)&#123; int low,high,mid,place; for(int i=2;i&lt;=n;++i) &#123; low=1;high=i-1; arr[0]=arr[i]; while(low&lt;=high) // 二分查找 &#123; mid=(low+high)/2; if(arr[0]&lt;arr[mid]) high=mid+1; else low=mid+1; &#125; place=low; //插入arr[i]的位置？？ for(int j=i-1;j&gt;=place;--j) arr[j+1]=arr[j]; arr[place]=arr[0]; &#125;&#125; 3.设计快速排序的递归和非递归算法??1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void partition(int arr[],int low,int high,int &amp;i) //划分函数&#123; int i; //初始化 int temp; i=low; j=high; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp;&#125;void quickSort(int arr[],int low,int high) //递归&#123; int i; if(low&lt;high) &#123; partition(arr,low,high,i); quickSort(arr,low,i-1); quickSort(arr,i+1,high); &#125;&#125;void quickSortNonrecursion(int arr[],int n) //非递归？？&#123; int i,low,high; int stack[maxSize][2],top=-1; //自己申请栈空间 low0;high=n-1; ++top; //入栈 stack[top][0]=low; stack[top][1]=high; while(top&gt;=0) &#123; low=stack[top][0]; //出栈 high=stack[top][1]; --top; partition(arr,low,high,i) if(low&lt;high) &#123; ++top; //入栈 stack[top][0]=low; stack[top][1]=i-1; ++top; //出栈 stack[top][0]=i+1; stack[top][1]=high; &#125; &#125;&#125; 4.设有整数0~n-1存放在整形数组A[0,1,2,…n-1]中，请设计一个时间复杂度为O(n),空间复杂度为O(1)的算法来是实现对A的排序（要求从小到大）。123456void order(int A[],int n)&#123; int i; for(i=0;i&lt;n;++i) A[A[i]]=A[i]; //???&#125; 5.编写一个是实现在排序二叉树中将data域（整型）值小于x的结点全部删除的算法。树中存在data域为x的结点且不存在data域值相同的结点。12345678910111213141516171819202122232425void deleteBT(BTNode *&amp;t)&#123; if(t!=NULL) &#123; deleteBT(t-&gt;lChild); deleteBT(t-&gt;rChild); free(t); t=NULL; &#125;&#125;void findAndDeleteBT(BTNode *&amp;t,int x)&#123; while(t!=NULL) &#123; if(t-&gt;data==x) &#123; deleteBT(t-&gt;lChild); return; &#125; else if(t-&gt;data&lt;x) t=t-&gt;rChild; else t=t-&gt;lChild; &#125;&#125;","link":"/2018/05/23/data-structure-20/"},{"title":"归并排序","text":"arr[]存储所有待排关键字的数组，low到high的关键字为一个子表，从mid+1到high为另一个关键字的子表。所以可以看出，归并排序可以对一个序列中任意一部分的元素进行排序，通过指定范围low-high就行。int n1=mid-low+1;显然n1为low到high范围里的关键字的个数。int n2=high-mid;显然n2是mid+1到high的关键字的个数。 12345678910111213141516171819202122232425262728293031323334353637void merge(int arr[],int low,int mid,int high)&#123; int i,j,k; int n1=mid-low+1; int n2=high-mid; int L[n1],R[n2]; for(i=0;i&lt;n1;i++) L[i]=arr[low+i]; //将arr[]中的low到mid的元素赋给L[]中 for(j=0;j&lt;n2;j++) R[j]=arr[mid+1+j]; //将arr[]中的mid+1到high的元素赋给R[]中 i=0; j=0; k=low; while(i&lt;n1&amp;&amp;j&lt;n2) &#123; if(L[i]&lt;=R[j]) //L数组和R数组中相对应的元素进行大小比较 arr[k]=L[i++]; //此时L数组的元素较小，赋给arr数组中，且i加一 else arr[k]=R[j++]; // R数组中的元素较小 k++; //k指向arr数组中的元素，被赋过值了，所以加一 &#125; while(i&lt;n1) //L数组中若是比较完之后有剩余就将他加到arr数组的后面 arr[k++]=L[i++]; while(j&lt;n2) //同理是R数组中若有剩余 arr[k++]=R[j++];&#125;void mergeSort(int arr[],int low,int high)&#123; if(low&lt;high) &#123; int mid=(low+high)/2; //计算出中间位置 mergeSort(arr,low,mid); mergeSort(arr,mid+1,high); merge(arr,low,mid,high); &#125;&#125;","link":"/2018/05/22/data-structure-17/"},{"title":"堆排序","text":"逻辑结构是完全二叉树，其左右孩子结点都小于或者都大于父结点的结构叫做堆，一个叫小顶堆，还有一个叫大顶堆。 我们可以用一个数组来存储完全二叉树 建堆操作 插入结点 删除结点例如我们想要删除这个根结点，我们可以先将这个结点拿的丢在一边，然后将最后一个结点丢在这个删除的结点的位置，然后对这个堆做一个调整。 堆排序的实现，我们分为两个过程，第一个过程是我们首先要建堆，第二个过程是我们从中挑出一个最值，然后把他丢在末尾，然后对其做一次调整。这两个过程说到底都是对某个关键字进行调整的过程。所以实现这个堆排序也要两个函数，一个函数是对某个关键字进行调整的函数，还有一个函数是堆排序的主函数。1234567891011121314151617181920212223242526272829303132333435void sift(int arr[],int low,int high) //调整函数&#123; int i=low,j=2*i+1; int temp=arr[i]; while(j&lt;=high) &#123; if(j&lt;high&amp;&amp;arr[j]&lt;arr[j+1]) ++j; if(temp&lt;arr[j]) &#123; arr[i]=arr[j]; i=j; j=2*i+1; &#125; else break; &#125; arr[i]=temp;&#125;void heapSort(int arr[],int n) //主函数&#123; int i; int temp; for(i=n/2-1;i&gt;=0;--i) sift(arr,i,n-1); //生成了大顶堆 for(i=n-1;i&gt;0;--i) &#123; temp=arr[0]; arr[0]=arr[i]; arr[i]=temp; sift(arr,0,i-1); // 有序序列 &#125;&#125; 我们首先走一下这个函数，我们走到主函数中的for（i=n/2-1;i&gt;0;–i)，i=8/2-1=3,然后我们下一句，我们调用调整函数，sift（arr，i,n-1）作用arr数组里的数，范围是i到n-1，即3到7。我们到调整函数，i=low,然后j=2*i+1，这句是j指向i的左孩子（这个是完全二叉树中找其孩子结点的公式） 我们看第7行的if语句，这句话的意思就是，如果i的左右孩子结点都存在的话，那么就将j指向左右孩子中较大的那个结点。此时这里i=3,他这个结点只有左孩子没有右孩子，不满足这个条件，所以就跳过。第8行的if语句，如果temp所指结点小于arr[j]的话，那就将j位置的值赋给i位置上，然后让i指向j，j指向i的左孩子结点，如果不满足条件，直接break.执行完这个调整函数之后，我们就恢复现场，此时还在26行的for循环中，再一次循环,–i，之前的i是3，所以这一次循环的i=2，然后再进入调整函数。这样一直循环。 调整函数中两个for循环都是为了生成大顶堆，主函数中的for（i=n-1;i&gt;0;–i）就是生成有序序列。","link":"/2018/05/21/data-structure-16/"},{"title":"基数排序","text":"基数排序要求比较数字的位数要一直，所以8要写成008,83要写成083等。按照关键字的最低位进行分配得到如下图：分配过后，我们按照从左到右的循序将他们收集，在遇到有两个元素在一个桶中的时候，按照从下往上的顺序将他们收集出来。收集过后，然后再从左到右，按照关键字的第二位进行分配。然后再对其进行收集关键字。然后我们再对其按照关键字的第三位进行分配。然后再对其进行收集关键字。然后就得到了有序序列。 各个排序的稳定性问题：气泡排序是稳定的 基于交换的简单选择排序是不稳定的（默认），基于插入的简单选择排序是稳定的。 直接插入排序是稳定的 快速排序是不稳定的 希尔排序是不稳定的 归并排序是稳定的 堆排序是不稳定的 基数排序是稳定的","link":"/2018/05/22/data-structure-18/"},{"title":"多路归并排序","text":"之前有讲过一个二路归并排序 置换-选择排序：","link":"/2018/05/23/data-structure-19/"},{"title":"data structure——串","text":"生存还是毁灭，这是一个值得思考的问题。 ——莎士比亚《哈姆雷特》 特点：串的逻辑结构和线性表类似，串是限定了元素为字符串的线性表，但是，两者在操作上有很大区别：线性表的操作主要是针对的表内的某一个元素，而串操作主要是对串内的一个子串。 定义：定长顺序存储定义：12345typedef struct&#123; char str[maxsize+1]; int length;&#125;Str; 定长存储结构不需要分配和释放空间，但是如果想要改变空间大小，需要重新定义结构体。变长分配存储定义：12345typedef struct&#123; char *ch; //用malloc函数分配一个类型为char的连续存储空间, int length; //后用ch指针指向这个空间的起始地址&#125;Str; 可以通过这样来使用变长结构体123Str S; //定义一个名为S的变量S.length=L; //将长度设置为LS.ch=(char*)malloc((L+1)*sizeof(char)); //为其分配空间，指针ch指向这个空间的首地址 操作：1.赋值操作1234567891011121314151617181920212223242526272829303132int strassign(Str&amp; str,char* ch) &#123; if(str.ch) //这个我们将要赋值的串，如果已经指向某个存储空间了， free(str.ch); //那就先将他的存储空间释放掉 int len=0; char *c=ch; //定义一个指针c内容为ch的地址 while(*c) //当指针c所指的元素的值不为0就执行该循环 &#123; ++len; //c指针不为空，长度加一 ++c; //指针向后移动，再看是否为空 &#125; //求这个我们拿来赋值的数组中的字符的个数 if(len==0) &#123; str.ch=NULL; str.length=0; return 1; &#125; else &#123; str.ch=(char*)malloc(sizeof(char)*(len+1)); if(str.ch==NULL) //防止分配不到内存 return 0; else &#123; c=ch; //让c指针指向ch for(int i=0;i&lt;=len;++i,++c) str.ch[i]=*c; str.length=len; return 1; &#125; &#125;&#125; 2.取串长度1234int strlength(Str str)&#123; return str.length;&#125; 3.串比较操作 (ASCII码和长度的“数值”比较)1234567int strcompare(Str s1,Str s2)&#123; for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length,++i) if(s1.ch[i]!=s2.ch[i]) return s1.ch[i]-s2.ch[i]; //s1大于s2就返回一个大于0的数，反之同理 return s1.length-s2.length; &#125; 4.串连接操作12345678910111213141516171819202122232425int concat(Str&amp; str,Str str1,str2)&#123; if(str.ch) //如果ch指针不为空就执行if语句 &#123; free(str.ch); str.ch=NULL; &#125; str.ch=(char* )malloc(sizeof(char)*(str1.length+str2.length+1)); if (str.ch==NULL) //如果存储空间分配失败就返回0 return 0; int i=0; while(i&lt;str1.length) &#123; str.ch[i]=str1.ch[i]; ++i; &#125; int j=0; while(j&lt;=str2.length) &#123; str.ch[i+j]=str2.ch[j]; ++j; &#125; str.length=str1.length+str2.length; return 1;&#125; 5.求子串操作(以下是实现了求str串从pos位置开始，len长度的子串，由substr返回)12345678910111213141516171819202122232425262728293031int substring(Str&amp; substr,Str str,int pos,int len)&#123; if(pos&lt;0||pos&gt;=str.length||len&lt;0||len&gt;str.length-pos) return 0; if(substr.ch) &#123; free(substr.ch); substr.ch=NULL; &#125; if(len==0) //如果是空串的情况的话 &#123; substr.ch=NULL; substr.length=0; return 1; &#125; else &#123; substr.ch=(char*)malloc(sizeof(char)*len+1); int i=pos; int j=0; while(i&lt;pos+len) &#123; substr.ch[j]=str.ch[i]; ++i; ++j; &#125; substr.ch[j]='\\0'; //这里j已经移到了一个空白位置，所以在这里加上\\0就好 substr.length=len; return 1; &#125;&#125; 6.串清空操作12345678910int cleanstring(Str &amp;str)&#123; if(str.ch) &#123; free(str.ch); str.ch=NULL; &#125; str.length=0; return 1;&#125; 7.字符串模式匹配：简单模式匹配算法123456789101112131415161718192021int naive(Str str,Str substr)&#123; int i=1,j=1,k=i; //从数组下标1开始存储，下标0不存储，k为主串中第一次匹配的位置 while(i&lt;str.length &amp;&amp; j&lt;=substr.length) &#123; if(str.ch[i]==substr.[j]) &#123; ++i; ++j; &#125; else &#123; j=1; i=++k; &#125; &#125; if(j&gt;substr.length) return k; else return 0;&#125; KMP算法 在模式串j出发生不匹配时，只需要将F前移，使得F_l与F_n重合即可。假如F串的左部和右部有不止一对F_l和F-n，我们取第一个满足条件的一对（即较长的一对）。 若想直接由s_k状态跳转到s_k+1，只需要移动指针j即可，i指针可以保持不变。 next数组是用来存储，当发生模式串与主串不匹配的时候，下一需要跳转到的位置。 模式串中第j个位置与主串中的第i个位置发生不匹配的时候，应从模式串中的第next[j]个位置与主串第i个位置重新比较。 KMP算法实现：123456789101112131415161718192021int KMP(Str str, Str substr ,int next[])&#123; int i=1,j=1; while(i&lt;str.length&amp;&amp;j&lt;=substr.length) &#123; if(j==0||str.ch[i]==substr.ch[j]) &#123; ++i; ++j; &#125; else &#123; j=next[j]; &#125; &#125; if(j&gt;substr.length) return i-substr.length; else return 0;&#125; next数组的计算：","link":"/2018/04/13/data-structure-4/"},{"title":"线索二叉树","text":"线索二叉树 线索二叉树的结点定义：1234567typedef struct TBTNode&#123; char data; int ltag,rtaghy; struct TBTNode *lchild; struct TBTNode *rchild;&#125;TBTNode; 通过中序遍历对二叉树线索化的递归算法：1234567891011121314151617181920void InThread(TBTNode *p,TBTNode *&amp;pre) //p指向根结点&#123; if(p!=NULL) &#123; InThread(p-&gt;lchild,pre); //pre指针一直指向p指针指向的结点的前驱结点 if(p-&gt;lchild==NULL) &#123; p-&gt;lchild=pre; //左指针指向前驱结点， p-&gt;ltag=1; //且将ltag设为1 &#125; if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL) &#123; pre-&gt;rchild=p; //右指针指向后继结点， pre-&gt;rtag=1; //且将rtag设为1 &#125; pre=p; //p结点的要指向后继结点了，所以要将pre指向p，让他跟上来，这一句话要重点注意 p=p-&gt;rchild; //左子树全部访问完，开始访问右子树 InThread(p,pre); //递归，右子树线索化 &#125;&#125; 通过中序遍历建立中序线索二叉树的主程序：12345678910void createInThread(TBTNode *root)&#123; TBTNode *pre=NULL; if(root!=NULL) &#123; InThread(root,pre); pre-&gt;rchild=NULL; pre-&gt;rtag=1; &#125;&#125; 以p为根的中序线索二叉树中，中序序列下的第一个结点的算法：123456TBTNode *First(TBTNode *p)&#123; while(p-&gt;ltag=0) p=p-&gt;lchild; return p;&#125; 在中序线索二叉树中，结点p在中序下的后继结点的算法：1234567TBTNode *Next(TBTNode *p)&#123; if(p-&gt;ltag==0) return First(p-&gt;rchild); else return p-&gt;rchild;&#125; 中序线索二叉树上执行中序遍历的算法：12345void Inorder(TBTNode *root)&#123; for(TBTNode *p=First(root);p!=NULL;p=Next(p)) Visit(p);&#125; 通过前序遍历的二叉树线索化递归算法：123456789101112131415161718192021void preThread(TBTNode *p,TBTNode *&amp;pre)&#123; if(p!=NULL) &#123; if(p-&gt;lChild==NULL) &#123; p-&gt;lChild=pre; p-&gt;pre=1; &#125; if(pre !=NULL&amp;&amp;pre-&gt;rChild ==NULL) &#123; pre-&gt;rChild=p; pre-&gt;rTag=1; &#125; pre=p; if(p-&gt;lTag==0) //注意 preThread(p-&gt;lChild,pre); if(p-&gt;rTag==0) preThread(p-&gt;rChild,pre); &#125;&#125; 在前序线索二叉树上的遍历操作：1234567891011121314151617void preOrder(TBTNode *tbt)&#123; if(tbt !=NULL) &#123; TBTNode *p=tbt; while(p!=NULL) &#123; while(p-&gt;lTag==0) &#123; Visit(p); p=p-&gt;lChild; &#125; Visit(p); p=p-&gt;rChild; &#125; &#125;&#125; 通过后序遍历的二叉树线索化递归算法：12345678910111213141516171819void postThread(TBTNode *p,TBTNode *&amp;pre)&#123; if(p!=NULL) &#123; postThread(p-&gt;lChild,pre); postThread(p-&gt;rChild,pre); if(p-&gt;lChild==NULL) &#123; p-&gt;lChild=pre; p-&gt;pre=1; &#125; if(pre !=NULL&amp;&amp;pre-&gt;rChild ==NULL) &#123; pre-&gt;rChild=p; pre-&gt;rTag=1; &#125; pre=p; &#125;&#125;","link":"/2018/09/10/data-structure-Threaded-binary-tree/"},{"title":"图——Dijkstra算法","text":"最短路径问题 迪杰斯特拉算法求某一个顶点到其余各顶点的最短路径，也为单元最短路径算法。 dict[]数组存储了当前起点到其余各顶点的最短路径长度（是长度，数值），path[]存储了当前起点到其余各顶点的最短路径（是上一个顶点的下标）。set[]标记哪些顶点被选入了最短路径（是标记）。 dict[]数组中，将与其顶点直接相连的顶点的值直接记录下来，与其顶点没有直接相连的点就设为无穷大，自身就设为0。然后通过循环不断的更新其中的值。（存储的是起点和当前未被并入的顶点之间的距离） path[]存储了顶点到其所在最短路径上前一个顶点的信息 。如果某一个顶点的的path[]数组的值为-1，则说明，在此顶点之前没有其他顶点了。图中1,2,3对应的path[]数组的值为0，则说明1,2,3定点的前一个顶点为0。而4,5,6顶底在path[]数组中的值也为-1，是因为他们现在和当前最短路径上的顶点（现在为初始状态，此时最短路径上只有一个顶点0）没有直接关系。 set[]数组中，当前只有顶点0已经被选为最短路径中的顶点，所以将他标记为1其他的顶点还没有选择，所以暂时都是标记为0。 其中在执行过程中，例如下面这个图中的情况，当前最短路径中一共有0,1,2,3四个顶点，现在要找4,5,6三个顶点中，哪一个距离他们最短。第一个先并的0，然后并入的是1，然后并入的是2，然后并入的是3，看dist[]数组的的长度就知道了，因为都是按照哪个最短就先并哪个顶点的。此时，这里重点讲的是在并入哪一个顶点的比较过程，现在以此举例：在看4顶点，1.从根结点0到4顶点的距离为4+7（0-&gt;1-&gt;4）为11，2.从上一个顶点到4顶点的距离为无穷大（0-&gt;3-&gt;??),所以更新4顶点的dist[]数组为11，path[]数组为1，因为前一个顶点为1。然后就是再找到5顶点的路径长度是多少，同样要进行上面所说的两个比较，然后再找到6顶点的路径长度是多少，同样比较两个过程，最后，在4,5,6三个结点的路径长度之间选择一个最短的路径，并入最短路径中，将其顶点对应的set[]数组设置为1，就标志为已并入其中。这里，比较的是1.和2.这两种情况，在以后所有的选择哪一个顶点进行并入的时候都是进行这两种情况的比较。 接着，这里还有一个注意点，就是如下面的图中的过程，选的是最后一个顶点6怎么并入的过程，第一个路径是从根节点通过中间结点然后到达顶点6，第二个是通过上一个并入的顶点然后到顶点6（对应于上面的1.和2.的过程）对比这两个过程哪个路径短就并入最短路径。但是，有没有想过，第一个路径不止一种路径啊，为什么不这样走呢：0-&gt;1-&gt;4-&gt;6走呢？1,4也都是中间结点啊？？这里就是要讲的注意点就是路径的选择，我们可以以path[]数组为指引，选择路径，我们看0顶点的path[]数组是-1，为根结点的意思，1顶点的path[]数组为0，说明1顶点的前一个顶点为0，所以我们选1，顶点2的path[]为1，所以我们再选2顶点，5顶点的path[]为2，所以我们再选择5顶点，顶点4的path[]为5，所以我们就选择4，最终，选择出0-&gt;1-&gt;2-&gt;5-&gt;4这一条路径。其实以path[]作为选择路径的原因是，本来path[]中存储了之前顶点之间最短的路径，你为了保证再接入顶点的路径足够的短，当然前面的路径也要保证是短的。 可以看出来，在这个算法中一个核心的步骤就是1.和2.的两个结果的比较。我们把直接从根结点到要并入的结点v的距离记为dist[v]通过从上一个已并入的结点到要并入的结点的距离记为dist[vpre]+MGraph[vpre][v]如果dist[v]&gt;dist[vpre]+MGraph[vpre][v]则更新dist[v]=dist[vpre]+MGraph[vpre][v]更新path[v]=vpre。 代码如下：参数n为图的顶点个数，MGraph[][]为图的边信息，v0为起始顶点,dist[]存最短路径长度，path[]存最短路径。1234567891011121314151617181920212223242526272829303132333435void Dijkstra(int n,float MGraph[][n],int v0,int dist[],int path[]) &#123; int set[maxSize]; //初始化操作 int min,v; for(int i=0;i&lt;n;++i) &#123; dist[i]=NGraph[v0][i]; set[i]=0; if(MGraph[v0][i]&lt;INF) path[i]=v0; else path[i]=-1; &#125; set[v0]=1;path[v0]=-1; for(int i=0;i&lt;n-1;++i) //在没有被并入的顶点中挑一个距离最短路径最近的一个点 &#123; min=INF; for(int j=0;j&lt;n;++j) if (set[j]==0&amp;&amp;dist[j]&lt;min) &#123; v=j; min=dist[j]; &#125; set[v]=1; //然后将其设置为1 for(int j=0;j&lt;n;++j) /此循环是对dist和path数组的更新 &#123; if(set[j]==0 &amp;&amp;dist[v]+MGraph[v][j]&lt;dist[j]) &#123; dist[j]=dist[v]+MGraph[v][j]; path[j]=v; &#125; &#125; &#125;&#125;","link":"/2018/05/11/data-structure-8/"},{"title":"图——Floyd算法","text":"最短路径：弗洛伊德算法我们先看一下我们举例的图，如下图中右边的图，其中左边的Av[]数组存储的任意两个顶点之间的当前最短路径长度，pathv[]数组存储了任意两个顶点他们所在最短路径之间的中间点(v为下标)。 执行思路：对于每个顶点v，和任意一顶点对（i,j）,i不等于j,v不等于i,v不等于j，如果A[i][j]&gt;A[i][v]+A[v][j],则将A[i][j]更新为A[i][v]+A[v][j]的值，并将path[i][j]改为v。 执行过程： 首先我们一共所有的情况为{0,1}，{0,2}……初始化后，第一次，即当v=0时，发现所有情况中的{0,1}，此时i=0,j=1,v=0,v=i了，不满足条件，所以这个点跳过。很好理解，因为此时：式子”A[0][1]&gt;A[0][0]+A[0][1]”明显不成立，所以这种类型跳过，同样的{0,2}，{0,3}，{0,4}，这几个点也跳过，这也是为什么上面有说i不等于j,v不等于i,v不等于j的原因。接着我们来到{1,2},此时对应的式子为“A[1][2]&gt;A[1][0]+A[0][2]”,我们需要去判断大小，A[1][3]在A数组中为4，A[1][0]值为无穷，A[0][2]值也为无穷，所以式子不成立，不需要更新path数组。接着再看下一个情况{1，3},i=V，所以跳过，再下一个{2,0},j=v所以也跳过。再下一个{2,1}，现在对应的式子为A[2][3]&gt;A[2][0]+A[0][3],对应的值分别为2,3,7，式子不成立，也不需要更新。再下一对{3,0}，j=v跳过。再下一对{3,1},A[3][1]值为无穷，式子一定不成立，所以也不需要更新。最后看{3，2}，A[3][0]也为无穷大，所以，对于v=0这一情况，path数组不需要更新。 第二次，当v1时，也这样一个一个去比较，我就不细说了，其中，当为{0,2}时，式子为A[0][2]&gt;A[0][1]+A[1][2],其中的值分别为无穷大，5,4。明显，式子成立，所以，此时将A[0][2]更新为9，将path[0][2]更新为1，表示其中间结点为1。然后再一次一个一个的对比，不再赘述。 第三次，v=2,第四次，v=3，就这样循环比较，重复做上面的事情，更新A[]数组和path[]数组。 接着我们再看一下如何通过更新过的path[]数组去查找任意两个点的最短路径。例如：如果我们要寻找从1到0的最短路径是什么：首先查path[1][0]=3,说明1和0之间的中间点为3，所以将3标出，然后查path[1][3]=-1，说明从1到3有直接的边（这里path数组的值为-1，都说明两个点之间有直接相连的点，算是一个标记）。然后查path[3][0]=2，说明3和0之间又有中间点2，所以将2标出，然后查path[3][2]=-1,说明3和2之间也有直接的线相连，然后再查path[2][0]=-1,说明也有直接相连的边。此时从1到0的最短路径已经找出来了，就是分别这些个-1的边，为1-&gt;3-&gt;2-&gt;0。 然后这个通过path数组查找是实现任意两个点之间的额最短路径的算法为（递归）：u,v分别是从顶点u到顶点v 然后我们再看一下弗洛伊德算法的实现代码：n为图中顶点的个数，MGraph[][]是图的邻接矩阵存储。 12345678910111213141516171819void Floyd(int n,float MGraph[][n],int Path[][n])&#123; int i,j,v; int A[n][n]; for(i=0;i&lt;n;++i)//初始化 for(j=0;j&lt;n;++j) &#123; A[i][j]=MGraph[i][j]; Path[i][j]=-1; &#125; for(v=0;v&lt;n;++v) for(i=0;i&lt;n;++i) for(j=0;j&lt;n;++j) if(A[i][j]&gt;A[i][v]+A[v][j]) &#123; A[i][j]=A[i][v]+A[v][j]; Path[i][j]=v; &#125;&#125;","link":"/2018/05/15/data-structure-9/"},{"title":"data-structure-huffman树及其编码","text":"二叉树的确定： 举例：如果我们知道了先序序列abdecfgh和中序序列dbeacgfh，求确定这个二叉树的结构12345678910111213141516BTNode *createBT(char pre[],char in[],int L1,int R1,int L2,int R2) &#123; if(L1&gt;R1) return NULL; //递归出口 BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=pre[L1]; //先序序列的第一个结点是根结点 int i; //找出根结点在中序序列中的位置 for(i=L2;i&lt;=R2;++i) if(in[i]==pre[L1]) break; s-&gt;lChild=createBT(pre,in,L1+1，L1+i-L2,L2,i-1); s-&gt;rChild=createBT(pre,in,L1+i-L2+1,R1,i+1,R2); return s;&#125; 其中pre[]是先序序列，in[]是中序序列，L1,R1是先序序列的范围，L2,R2是中序序列的范围这里就使用了一个递归，分别处理根结点下的左右子树，子树下的左右子树,如此递归下去。其中12和13行的理由见下面：1234567891011pre:———————————————————————————————————————————————————————————————————— a | b | d | e | c | f | g | h |———————————————————————————————————————————————————————————————————— L1 L1+1 L1+i-L2 R1in：———————————————————————————————————————————————————————————————————— d | b | e | a | c | g | f | h |———————————————————————————————————————————————————————————————————— L2 i-1 i R2 举例：如果我们知道了中序遍历序列debghfca和后序遍历序列dbeacgfh，请确定二叉树123456789101112131415BTNode *createBT2(char post[],char in[],int L1,int R1,int L2,int R2) &#123; if(L1&gt;R1) return NULL; //递归出口 BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=post[R1]; //后序序列的最后一个结点是根结点 int i; //找出根结点在中序序列中的位置 for(i=L2;i&lt;=R2;++i) if(in[i]==post[R1]) break; s-&gt;lChild=createBT2(post,in,L1，L1+i-L2-1,L2,i-1); s-&gt;rChild=createBT2(post,in,L1+i-L2,R1-1,i+1,R2); return s;&#125; 层次遍历序列和中序遍历序列确定二叉树：12345678910111213141516171819202122232425262728293031323334353637int search(char arr[],char key,int L,int R) //查找函数，传入一个数组arr，key是要查找的值,L,R是范围&#123; int idx; //下标 for(idx=L;idx&lt;=R;++idx) if(arr[idx]==key) return idx; //找到这个值就返回下标，找不到就返回-1 return -1;&#125;void getSubLevel(char subLevel[],char level[],char in[],int n,int L,int R) //&#123; int k=0; for(int i=0;i&lt;n;++i) if(search(in,level[i],L,R)!=-1) subLevel[k++]=level[i];&#125;BTNode *CreateBT3(char level[],char in[],int n,int L,int R)&#123; if(L&gt;R) return NULL; BTNode *s=(BTNode *)malloc(sizeof(BTNode)); s-&gt;lChild=s-&gt;rChild=NULL; s-&gt;data=level[0]; int i=search(in,level[0],L,R); //要在中序遍历序列in中查找level[0]这个结点的位置，在范围L,R中 int LN=i-L;char LLevel[LN]; //LN,RN是数组长度 int RN=R-i;char RLevel[RN]; getSubLevel(LLevel,level,in,n,L,i-1); getSubLevel(RLevel,level,in,n,i+1,R); s-&gt;lChild=createBT3(LLevel,in,LN,L,i-1); //递归处理 s-&gt;rChild=createBT3(RLevel,in,Rn,i+1,R); return s;&#125; 在先序和中序序列来确定儿二叉树的情况时，知道了根结点之后，就可以在中序序列中，划分出左右子树是什么，因为他们是连续的，而在层次遍历中，他们是分散开来的，所以就有了getsubLevel函数，去查找他们，然后放到LLevel和RLevel数组中。这个函数具体是怎么做的呢，如图： 首先i将in数组（中序遍历序列）分成了左右不同的两个部分，分别是左右子树，下面是左右部分的元素在level数组中的分布情况，互相交错。我们是这样做的：在in数组中的L-i-1范围，用关键字t在level中扫描，看有和在数组in中L到i-1相同的值，有就把他们存到LLevel中。 getsublevel中sublevel是存储结果的数组，n是代表level的长度，L,R是要取的元素的范围。k是辅助从sublevel中插入元素。","link":"/2018/10/15/data-structure-huffman/"},{"title":"html小笔记","text":"准备考试之余，看点html吧吧吧。。。这里写点小笔记。。。唤起沉睡中的记忆。。。 唤醒记忆三部曲——html(Hypertext Markup Language) &lt;html&gt;标签：这个标签是一张网页的最外层的标签，包含一个网页的所有内容。 &lt;html&gt; ... &lt;/html&gt; &lt;body&gt;标签：页面中所有可见元素都应该包含在其中。 &lt;html&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;head&gt;标签：存放一些关键字等给浏览器和搜索引擎所用，不显示出来，一个页面只能有一个head标签。 &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;keywords&quot; content=&quot;..&quot;&gt; &lt;/head&gt; &lt;/html&gt; &lt;title&gt;标签：用于指定页面的标题，不显示在页面里，显示在浏览器上面的页面一行里。 &lt;html&gt; &lt;head&gt; &lt;title&gt;..标题名..&lt;/title&gt; &lt;/head&gt; &lt;/html&gt; 标题标签：有&lt;h1&gt;,&lt;h2&gt;,&lt;h3&gt;,…&lt;h6&gt;六个标题，可以渲染，也有&lt;h7&gt;,&lt;h8&gt;,等，不过不渲染了。没有嵌套关系和并列关系，只是代表优先级不一样。 &lt;html&gt; &lt;body&gt; &lt;h1&gt;..标题..&lt;/h1&gt; &lt;h2&gt;..标题..&lt;/h2&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;p&gt;标签：段落标签，一对p标签可以分一个段落,你在html中键入一个换行键是不会换行的，需要用段落标签。 &lt;html&gt; &lt;body&gt; ...文字.. &lt;p&gt; ....接上的文字... &lt;/p&gt; .... &lt;/body&gt; &lt;/html&gt; &lt;div&gt;标签：division（区域）容纳其他的元素，很常用，常见，简单，区分容纳,可嵌套，可以看成目录这各功能。 &lt;html&gt; &lt;body&gt; &lt;div&gt; .. &lt;/div&gt; &lt;div&gt; .. &lt;/div&gt; .. &lt;/body&gt; &lt;/html&gt; &lt;a&gt;标签：用于指定网页中的链接，锚链接（anchor)。其中，target=self表示在当前页打开网址，target=blank表示新打开一网页显示链接网址。 &lt;html&gt; &lt;body&gt; &lt;a href=&quot;http:www....&quot; target=&quot;self&quot;&gt;替换的文字&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; &lt;img&gt;标签：图片标签（image）指定图片。没有结束标签&lt;/img&gt;，支持jpg，png，svg，gif等。 &lt;html&gt; &lt;body&gt; &lt;img src=&quot;要插入图片的本地地址或网络地址&quot; alt=&quot;图片加载失败显示的内容&quot;&gt; &lt;/body&gt; &lt;/html&gt; 表格类标签：&lt;table&gt;指创建表格,&lt;tr&gt;指行,&lt;td&gt;指单元格，&lt;th&gt;指定表格的属性。&lt;thead&gt;存放表格属性名，&lt;tbody&gt;存放表格中的值，这里的&lt;thead&gt;指的是存放表格属性的地方，表格属性指列如姓名，年龄这些。&lt;tbody&gt;指的是存放这些属性的值得地方，列如lifan，13这些。建议建表最好用css来完成。 &lt;html&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; name &lt;/th&gt; &lt;th&gt; age &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; lifan &lt;/td&gt; &lt;td&gt; 13 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;header&gt;标签，&lt;footer&gt;标签：指标题相关的内容，概括整个页面的内容,footer标签，指指定页脚的相关内容。例如联系方式，自我介绍，联系地址等。他们也是一个容器，和div的区别就在于里面的内容是有一定的语义的，方便搜索引擎等的收集，而div里可以放任何东西，且没有语义。 &lt;html&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;..hello world..&lt;/h1&gt; &lt;small&gt;... &lt;/header&gt; ....正文.... &lt;footer&gt; ...contact...privacy.. &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; &lt;link&gt;,&lt;script&gt;标签：既可以写在&lt;head&gt;里也可以写在&lt;body&gt;里。不能直接在浏览器中显示。&lt;link&gt;标签加载外部资源，列如样式表等，script标签主要用于加载脚本，列如javascript。 &lt;html&gt; &lt;head&gt; ... &lt;link href=&quot;..xx.css&quot;&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;script src=&quot;..yy.js&quot;&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;button&gt;标签：按钮标签，是一个触发机制，一般需要和其他东西共同使用，列如和表单使用和javascript使用。 &lt;html&gt; &lt;body&gt; ... &lt;buttom&gt;signup&lt;/button&gt; ... &lt;/body&gt; &lt;/html&gt; &lt;abbr&gt;标签：缩写（abbrevitation）,用于显示缩写的内容的所有内容。 &lt;html&gt; &lt;body&gt; &lt;abbr tittle=&quot;hyper text markup language&quot;&gt;html&lt;/abbr&gt;is interesting &lt;/body&gt; &lt;/html&gt; &lt;code&gt;,&lt;pre&gt;标签：用于包含代码，显示代码。&lt;code&gt;标签是行内元素，一般都是镶嵌在所在行里的，适合小段代码；&lt;pre&gt;标签适合用于大段代码。还可以设置代码的属性等。 &lt;html&gt; &lt;head&gt; &lt;style media=&quot;..&quot;&gt; code{ background: rgba(0,0,0,0); border-radius: 11px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; .....&lt;code&gt;a==2&lt;/code&gt; ... &lt;pre&gt; ... ... &lt;/pre&gt; &lt;/body&gt; &lt;/html&gt; &lt;input&gt;标签：用于接收用户输入。&lt;input&gt;标签类型比较多：有： &lt;input type=&quot;text&quot;&gt; 默认值 &lt;input type=&quot;password&quot;&gt; 密码输入 &lt;input type=&quot;radio&quot;&gt; 单选框输入 &lt;inout type=&quot;checkbox&quot;&gt; 多选框 &lt;input type=&quot;file&quot;&gt; 选择文件 &lt;input type=&quot;reset&quot;&gt; 重置表单 ... 嗯。。。暂时先整理在这里，有空在网上找点小例子，有补充的再补充。。。","link":"/2018/03/18/html-learning-1/"},{"title":"纪念一下~","text":"//2019.04.21更新，原内容删除，以后都在这放一下生活上的小感悟把。 4.21之前：沉潜下来去做一些事情，不浮躁，也要能做到有所取舍。 5.9：在处理问题上发生错误，是你通向成功道路上的加速器。 5.15:之前的半个月时间，好像就只练了两次钢琴吧，忙是一方面原因，感觉更多的原因是自己看着漫漫的路程有点气馁了吧，还有一方面的原因是觉得钢琴毕竟不是我的主线任务？？不管如何，当我听到美丽的钢琴曲时，心情还是会变的很好，很想学钢琴。 6.18：还是由学钢琴引起的思考。决定要刻意改掉自己徘徊踌躇，优柔寡断的缺点。","link":"/2018/03/07/life-1/"},{"title":"data structure——树的例题","text":"1.假设二叉树采用二叉链表存储结构，设计一个算法，计算一棵给定二叉树的所有结点数。1234567891011int n=0;void count(BTNode *p)&#123; if(p!=NULL) &#123; ++n; count(p-&gt;lChild); count(p-&gt;rChild); &#125;&#125; 2.假设二叉树采用二叉链表存储形式，设计一个算法，计算一棵给定二叉树的所有叶子结点数。123456789101112int n=0;void count(BTNode *p)&#123; if(p!=NULL) &#123; if(p-&gt;lChild&amp;&amp;p-&gt;rChild==NULL) ++n; count(p-&gt;lChild); count(p-&gt;rChild); &#125;&#125; 3.假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针rchild将一棵二叉树的叶子结点按照从左往右的顺序串成一个单链表（在题目中定义两个指针，head与tail，其中head指向第一个叶子结点，head初值为null,tail指向最后一个叶子结点）。1234567891011121314151617181920void link(BTNode *p,BTNode *&amp;head,BTNode *&amp;tail)&#123; if(p!=NULL) &#123; if(p-&gt;rchild==NULL&amp;&amp;p-&gt;lChild==NULL) if(head==NULL) //如果head=null,则说明当前是遇到的是第一个叶子结点 &#123; head=p; tail=p; &#125; else //接着再将其他的叶子结点串在其后面 &#123; tail-&gt;rchild=p; tail=p; &#125; link(p-&gt;lchild,head,tail); link(p-&gt;rchild,head,tail); &#125; &#125; 4.在二叉树的二叉链表存储结构中，增加一个指向双亲结点的parent指针，设计一个算法，给这个指针赋值，并输出所有结点到根结点的路径。1234567891011121314151617181920212223242526272829303132333435363738typedef struct BTNode //修改数据结构&#123; char data; struct BTNode *parent; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode;void triBtree(BTNode *p,BTNode *q) //将各个结点的parent赋值&#123; if(p!=NULL) &#123; p-&gt;parent=q; q=p; triBtree(p-&gt;lchild,q); triBtree(p-&gt;rchild,q); &#125;&#125;void printPath(BTNode *p) //打印一个结点到根结点的路径&#123; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;\" \"&lt;&lt;endl; p=p-&gt;parent; &#125;&#125;void allPath(BTNode *p) //打印所有结点到根结点的路径&#123; if(p!=NULL) &#123; printPath(p); allPath(p-&gt;lchild); allPath(p-&gt;rchild); &#125;&#125; 5.假设满二叉树b的先序遍历序列已经存放在于数组中（在解题过程中，此数组名称可以自己定义，长度为n），设计一个算法将其转化为后序遍历序列。123456789void change(char pre[],int L1,int R1,char post[],int L2,int R2)&#123; if(L1&lt;=R1) &#123; post[R2]=pre[L1]; //这里是将pre[]中的第一个放在post[]的最后一个 change(pre,L1+1,(L1+1+R1)/2,post,L2,(L2+R2-1)/2); //将pre[]中的前一半存在post[]中的前一半中，递归处理 change(pre,(L1+1+R1)/2+1,R1,post,(L2+R2-1)/2+1,R2-1); //将pre[]的后一半存在post[]中的后一半中 &#125;&#125; 7.假设二叉树采用二叉链表存储结构存储，设计一个算法，求二叉树b中值为x的结点的层号。12345678910111213141516int L=1;void leno(BTNode *p,char x)&#123; if(p!=NULL) &#123; if(p-&gt;data==x) &#123; cout&lt;&lt;L&lt;&lt;endl; &#125; ++L; leno(p-&gt;lchild,x); leno(p-&gt;rchild,x); --L; &#125;&#125; 这里用到了一个我们发现遍历序列时候的共性：在遍历结点的时候，总是由指针p从一层往下面一层去走，一直走到最底层，(++L)然后由下层往上层走（–L）,而且，第一次遇见一个结点，是往下走，此时是先序遍历，（第二次遇见也是往下走），第三次遇见是往上走，是后序遍历，所以，我们在第10行加入++L,在递归处理左右子树后，在第14行加入--L（这里说的比较个人化。。不好理解） 8.二叉树的双序遍历是指：对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树。试写出执行这种双序遍历的算法。12345678910void Double_order(BTNode *t)&#123; if(t!=NULL) &#123; Visit(t); Double_order(t-&gt;lchild); Visit(t); Double_order(t-&gt;rchild); &#125;&#125; 9.设中序线索二叉树的类型为TBTNode*InThree;设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点。设计算法，在一棵中序线索二叉树中寻找结点t的中序下的前驱。设计算法，在一棵中序线索二叉树中寻找结点t的前序下的后继。12345678910111213141516171819202122232425262728293031323334TBTNode* inLast(TBTNode *t) //一直往右子树链走下去即为最后一个结点&#123; TBTNode *p=t; while(p&amp;&amp;!p-&gt;rtag) p=p-&gt;rchild; return p;&#125;TBTNode inPrior(TBTNode *t)&#123; TBTNode *p=p-&gt;lchild; if(p&amp;&amp;!t-&gt;ltag) p=inLast(p); return p;&#125;TBTNode * treNext(TBTNode *t)&#123; TBTNode *p; if(!t-&gt;ltag) p=t-&gt;lchild; else if(!t-&gt;rtag) p=t-&gt;rchild; else &#123; p=t; while(p&amp;&amp;p-&gt;rtag) p=p-&gt;rchild; if(p) p=p-&gt;rchild; &#125;&#125; 10.假设二叉树采用二叉链存储结构，设计一个算法，输出根结点到每个结点的路径。12345678910111213141516171819int i ;int top=0;char pathstack[maxsize];void allPath(BTNode *p)&#123; if(p!=NULL) &#123; pathstack[top]=p-&gt;data; ++top; if(p-&gt;lchild=NULL&amp;&amp;p-&gt;rchild=NULL) //如果当前为叶子结点就打印路径 &#123; for(i=0;i&lt;top;++i) cout&lt;&lt;pathstack[i]; &#125; allPath(p-&gt;lchild); allPath(p-&gt;rchild); --top; &#125;&#125;","link":"/2018/04/28/data-sturcture-practise-1/"},{"title":"函数和递归例题","text":"（持续更新）list:1：救济金发放（The Dole Queue, UVa 133） 2：刽子手问题（Hangman Judge, UVa 489） ================================================================= 1：救济金发放（The Dole Queue, UVa 133） n(n&lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开 始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个 官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。 分析：很明显，可以用数组去存储编号。用+1和-1来实现顺时针和逆时针的效果。将选择过的编号设为0，在继续选择编号的时候如果数组值为0的话就继续选择，这样就可以实现离开队伍的效果。 代码：1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#define maxn 25int n,k,m,a[maxn];//n为人数，k为a数的人数，m为b数的人数int go(int p,int d,int t)&#123;//步长不太好想到 //逆时针走t 步长是d,-1是顺时针 while(t--)&#123;//当还有步数的时候 do&#123; p=(p+d+n-1)%n+1;//循环移动的实线 &#125;while(a[p]==0);//当为0的时候就继续移动 &#125; return p;&#125;int main()&#123; while (scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;m)==3&amp;&amp;n)&#123; for(int i=1;i&lt;=n;i++) a[i]=i;//先给数组赋值 int left=n;//剩余人数 int p1=n,p2=1; while(left)&#123; p1=go(p1,1,k); p2=go(p2,-1,m); printf(\"%3d\",p1); left--; if(p1!=p2)&#123;printf(\"%3d\",p2);left--;&#125;//如果p1和p2指向不同的话，两者都输出 a[p1]=a[p2]=0;//设他们为0 if(left) printf(\",\"); //如果还有就要输出一个逗号 &#125; printf(\"\\n\"); &#125; return 0; &#125; 注意：步长的方式可能不容易想到，经常通过取余的形式实现环形取数的效果，逻辑还是需要自己多调试。 2：刽子手游戏（Hangman Judge, UVa 489） 游戏规则是这样的：计算机想一个单词 让你猜，你每次可以猜一个字母。如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一 笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。在本题中，你的任务是编写一个“裁判”程 序，输入单词和玩家的猜测，判断玩家赢了 （You win.）、输了（You lose.）还是放弃了 （You chickened out.）。每组数据包含3行，第1 行是游戏编号（-1为输入结束标记），第2行是 计算机想的单词，第3行是玩家的猜测。后两行 保证只含小写字母。样例输入：1cheesechese2cheeseabcdefg3cheeseabcdefgij-1样例输出:Round 1You win.Round 2You chickened out.Round 3You lose. 分析：用数组去存储猜测的字母和目标字母用变量（如这里的win,lose）去表示一些状态，从而更好的操作 代码：1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 100int left,chance;//left是还需要猜测的位置个数，chance是能猜测的剩余次数char s[maxn],s2[maxn];int win,lose;void guess(char ch)&#123; int bad=1; for(int i=0;i&lt;strlen(s);i++) if(s[i]==ch)&#123; left--;s[i]=' ';bad=0;&#125; if(bad) --chance; if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(\"%d%s%s\",&amp;rnd,s,s2)==3&amp;&amp;rnd!=-1)&#123; printf(\"Rounf %d\\n\",rnd); win=lose=0;//表示状态的变量 left=strlen(s); chance=7; for(int i=0;i&lt;strlen(s2);i++)&#123; guess(s2[i]); if(win||lose) break; &#125; if(win) printf(\"You win.\\n\"); else if(lose) printf(\"You lose.\\n\"); else printf(\"You chickened out.\\n\"); &#125; return 0;&#125; 注意：使用全局变量的时候注意作用域，这些变量的使用都比较灵活，如bad,left,chance等，还是需要自己多动手。","link":"/2019/04/18/function-and-recursive/"},{"title":"洛谷p1038-统计单词数","text":"题目链接 思路一：首先，最直接的思路是分别用两个数组取存储输入的数。因为题目要求是不需要区分大小写的，所以最好先将这些字母的大小写统一一下。最关键的是其中的for循环的理解，if(b[i]==’ ‘)这句话是先让i走到b数组的一个完整单词的后面，限定j一次循环的位置。k=0,k要每次都等于0，因为每一个新的循环，对于j来说是从n开始，对于k来说总是从数组k的第一个位置开始。n就是配合着j，确定每一次循环，j开始的位置，都是从n开始。 注意：下面代码总是有三个测试点不通过，用O2优化就能通过…看了半天也没看出来哪里没思考到位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[11],b[1000001]; gets(a); gets(b); strcat(a,\" \");//为每个数组的最后面添加上空格，这样更方便后面的操作 strcat(b,\" \"); for(int i=0;a[i]!='\\0';i++)&#123;//全都变为大写，方便比较 if(a[i]&gt;='a')&#123;//变为大写 a[i]-='a'-'A'; &#125; &#125; for(int i=0;b[i]!='\\0';i++)&#123; if(b[i]&gt;='a')&#123;//变为大写 b[i]-='a'-'A'; &#125; &#125; int s; int i; int n=0;//n是用来配合j，循环数组b用的，即下面的for循环中的j=n， int j,k;//分别用来遍历两个数组用 int rec;//记录第一次匹配字符串的位置（和n配合使用） int geshu=0;//统计b数组中有多少个和a匹配 for(i=0;b[i]!='\\0';i++)&#123; if(b[i]==' ')&#123;//这是为了要让数组b的j先跑到一个空格处停下来， //以次作为下面的一次循环，j的停止的位置，即下面的for循环中，j&lt;=i的原因 s=1;//用来表示各个位能够对应相等， //如果最后s是1，说明全都对应相等， //如果有一位不等，s就会为0，即不全部对应相等 for(j=n,k=0;j&lt;=i,a[k]!='\\0';j++,k++)&#123; if(a[k]==b[j])&#123; s*=1;//用一直乘的方法 &#125;else&#123; s*=0; &#125; &#125; if(s==1)&#123; geshu++;//这个是相对应的次数 &#125; if(s==1&amp;&amp;geshu==1)&#123; rec=n;//这是用来记录第一次符合的位数 &#125; n=i;//n直接变为i， n++;//因为现在所指处为空格，所以要加一，跳过这个空格 &#125; &#125; if(geshu==0)&#123; geshu=-1; printf(\"%d\",geshu); &#125;else if(geshu&gt;=1)&#123; printf(\"%d %d\",geshu,rec); &#125; return 0;&#125;","link":"/2019/06/10/luogu-p1038/"},{"title":"洛谷p1464-Function","text":"题目链接 题解一：思路：题意是输入若干行，其结束标识是输入”-1 -1 -1”。关键思想是使用：记忆化搜索，即开一个数组来存储一些数据。所谓记忆话搜索，就是对于你求的解，将他们的值都存在数组中，如果在搜索的过程中，这个解已经被计算过存储在了数组中，就不再需要计算了，直接返回f数组中对应的存储好的解。如果没有既定存储好的，就计算，存在f数组中。 由题意可以知道：如果a,b,c有一个小于0，就返回1; (case 1)如果a,b,c有一个大于20，就返回w(20，20，20); (case 2)如果a&lt;b且b&lt;c就返回w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c); (case 3)如果其他的情况就返回w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c) (case 4)可以发现，要开一个数组来存储这些返回值的话：这个数组的大小只要f[25][25][25]足够，就可以把所以的不同的情况都保存起来。 代码：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long f[25][25][25];long long w(long a,long b,long c)&#123; if(a&lt;=0||b&lt;=0||c&lt;=0) return 1;//case 1 if(a&gt;20||b&gt;20||c&gt;20) return w(20,20,20); //case 2 else if(a&lt;b&amp;&amp;b&lt;c)&#123; //case 3 if(f[a][b][c]==-1)//判断这个记忆数组有没有已经存储， f[a][b][c]=w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c);//就将结果存在对应的f数组中 &#125; else if(f[a][b][c]==-1)&#123;//case 4 f[a][b][c]=w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1); &#125; return f[a][b][c];//已经通过计算存在了f数组中，不需要计算，直接返回就行&#125;int main()&#123; memset(f,-1,sizeof(f));//先将f数组初始化全为-1 long long a,b,c; do&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;//输入三个数字 if(a!=-1||b!=-1||c!=-1)//这里检验一下是否为结素标志是因为，do-while循环会直接循环一次，//这里写这句话是为了如果输入第一行时就输入：-1 -1 -1，就一次循环都不做。 printf(\"w(%lld, %lld, %lld) = %lld\\n\",a,b,c,w(a,b,c)); &#125;while(a!=-1||b!=-1||c!=-1);//只要有一个不为-1，说明就不是结束标识，就可以继续输入 return 0;&#125;","link":"/2019/06/14/ruogu-p1464/"},{"title":"洛谷p1478-陶陶摘苹果（升级版）","text":"题目链接 题解一：可以使用动态规划来解决此类问题。 123456789101112131415161718#include&lt;iostream&gt; using namespace std;int dp[5005][1001];int xi[5005],yi[5005],n,s,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;xi[i]&gt;&gt;yi[i]; &#125; for(int i=1;i&lt;=n;i++)//枚举考虑每一个苹果 for(int j=0;j&lt;=s;j++)&#123;//枚举背包大小 dp[i][j]=dp[i-1][j];//不能取就直接转移考虑之前苹果的最大值 if(xi[i]&lt;=a+b&amp;&amp;j&gt;=yi[i])//如果能够取 dp[i][j]=dp[i-1][j-yi[i]]+1&gt;dp[i][j]?dp[i-1][j-yi[i]]+1:dp[i][j];//动态转移方程 &#125; cout&lt;&lt;dp[n][s];//因为是从前向后递推，因此接收最终答案的位置也从最前面转到了最后面 return 0;&#125; 其中的动态转移方程，如果能够取苹果的话，判断:dp[i][j]=dp[i-1][j-yi[i]]+1&gt;dp[i][j]?dp[i-1][j-yi[i]]+1:dp[i][j] 首先：取苹果是：dp[i-1][j-yi[i]]+1。取苹果了，那么力气就减少对应摘这个苹果需要消耗的体力，即j-yi[i]。空间也减小了，即i-1(因为题目中没有说不同苹果所占空间不一样，所以每个苹果人为占1空间)。取苹果了，那么现在的背包中的苹果的总价值也要加一，即dp[][]+1(因为题目中只问了能取多少个苹果，所以，就相当于每个苹果的价值为都为1)。 不取苹果是：dp[i][j]，即不需要更新这个数组。 其中，不仅枚举考虑每一个苹果的大小，还枚举了背包的大小，这是为什么呢？？？","link":"/2019/06/15/ruogu-p1478/"},{"title":"洛谷p1036-选数","text":"题目链接 题解一：此题是从n个数中选出k个不同的数字出来，然后按要求计算，看k个数的和有多少个数素数。思考一下，无非难点就是，如何在n个数字中取出k个不同的数字，且不能重复。这里不能重复，一是说取出的数字不能相同，二是说取得方案不能重复。比如：4 33 7 12 19是说4个数字中取出3个数字，可以这样取3 7 123 7 193 12 197 12 19但是不能这样取：3 3 7之类，也不能这样取：3 7 123 7 193 7 193 12 197 12 19即：一组内不能有相同得数字，且不能有相同得两组。 好了，重点是：如何去重！如果我们有规律得枚举，就能有效得避免重复列举得出现。也即达到了去重得目的。 我们要这样：3 7 123 7 193 12 197 12 19这样取，第一个位置，先取最小得数字3，后面递增取出。第一个位置选择为3得排列选完了，那么：第一个位置换为第二小得数字，再进行排列。即选7排列。这样枚举，就有秩序了。 题解思路是用dfs，和上述文章中提到得降重得方法。其中startx参数是用来储存当前升序排序时的初始值。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;bool isprime(int a)&#123;//判断素数 for(int i=2;i*i&lt;=a;i++)&#123; if(a%i==0) return false;//如果能整除，说明不是素数 &#125; return true;//若能走到这里了，就说明不能整除，说明是素数&#125;int n,k;//n为n个数，k为要选取的个数int a[25];//存储输入的每个数字bool vis[25];//标记这个数是否有没被选中long long ans=0;//统计部分和为素数的情况个数void dfs(int m,int sum,int startx)&#123;//递归处 //m代表了select了多少个数 //sum表示当前的和 //startx表示升序排列的起始值，就是用上面所说得按一定规律有序得枚举 if(m==k)&#123;//如果选完了的情况 if(isprime(sum)) ans++;//如果选取的数的和不为素数，那么就ans++ return ; &#125; for(int i=startx;i&lt;n;i++)&#123; //这里就为上述中写的有规律的排列的实现 if(vis[i]) continue;//如果被选过，直接进入下一次循环 vis[i]=true;//如果没有被选过，选择之，即标记为选过 dfs(m+1,sum+a[i],i+1);//递归//m+1为被选择了的数的个数加一，sum+a[i]计算被选中的数字的和，i+1升序初始值加一，以防止重复排列 vis[i]=false;//递归出来后，让这个数的标记重新设为未选择状态 &#125; return ;//这里，所有都已枚举完，直接返回&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];//读入输入的数 dfs(0,0,0); cout&lt;&lt;ans;//输出结果 return 0;&#125;","link":"/2019/06/10/ruogu-p1036/"},{"title":"由一个模板题引出的小总结-洛谷p1777快速排序","text":"题目描述：利用快速排序算法将读入的N个数从小到大排序后输出。题目链接快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++C++选手请不要试图使用STL，虽然你可以使用sort一遍过，但是你并没有掌握快速排序算法的精髓。） 输入输出格式输入格式：第1行为一个正整数N，第2行包含N个空格隔开的正整数ai ,为你需要进行排序的数，数据保证了Ai不超过1000000000. 输出格式：将给定的N个数从小到大输出，数之间空格隔开，行末换行且无空格。 输入输出样例输入样例#1：54 2 4 5 1输出样例#1：1 2 4 4 5 说明:对于20%的数据，有N≤1000； 对于100%的数据，有N≤100000。 题解：123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;int a[100010];void quick_sort(int x,int y)&#123; int i=x,j=y,t; int k=a[x];//选取最左边一个书为基准数,这样数据量太大的时候就会超时 if(i&gt;=j) return; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[j]&gt;=k) j--; t=a[i]; a[i]=a[j]; a[j]=t; while(i&lt;j&amp;&amp;a[i]&lt;k) i++; t=a[i]; a[i]=a[j]; a[j]=t; &#125; quick_sort(x,i-1); quick_sort(i+1,y); return;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n);//个数 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]);//将输入的数据用数组存储起来 &#125; quick_sort(0,n-1); for(int i=0;i&lt;n;i++)&#123; printf(\"%d \",a[i]); &#125; return 0;&#125; 如果用上面的快速排序，有些测试数据此程序会运行超时，过不了。基于此，我们可以对快速排序进行优化： 方法一：随机化上面的快排中总是选择第一个元素作为基准数，在数字已经有序的情况下每次划分都将得到最坏的结果，时间复杂度退化为O(n^2)因为子序列比原序列只少一个元素，这样的话，递归深度就很大。快排的分治思想的优势一点都没有了。所以，我们可以随机的选择一个元素作为基准数，然后让这个元素与第一个元素交换位置，这样就可以继续用原来的方法来处理。如下：123456789101112131415161718192021void swap(int &amp;a,int &amp;b)&#123;//交换函数 int temp=a; a=b; b=temp;&#125;void quicksort(int left,int right)&#123; if(left&gt;right) return; int i=left,j=right; int ranw=rand()%(right-left+1)+left;//此处为随机化 swap(a[left],a[ranw]);//此处为将随机取得元素与第一个元素互换位置 while(i&lt;j)&#123; while(j&gt;i&amp;&amp;a[j]&gt;=a[left]) j--; while(i&lt;j&amp;&amp;a[i]&lt;=a[left]) i++; swap(a[i],(i==j)?a[left]:a[j]);//如果i==j说明，i，j相遇，//此时要将基准元素与此位置交换，即swap(a[i],a[left])或者swap(a[j],a[left])//（因为这个时候i，j都指向同一个位置） //如果i不等j，说明还没有相遇，此时只要转换swap(a[i],a[j]) &#125; quicksort(a,left,i-1);//递归 quicksort(a,j+1,right);&#125; 方法二：小区间使用插入排序当递归到了一定程度之后，序列长度足够小了，我们就可以对其较小的序列改用插入排序，因为长度较好后，分治递归的处理速度比直接插入慢。如下：123456789101112131415161718192021void insertsort(int left,int right)&#123;//直接插入排序 for(int i=left+1;i&lt;=right;i++)&#123; for(int j=i;j&gt;0&amp;&amp;a[j]&lt;a[j-1];j--) swap(a[j],a[j-1]); &#125;void quicksort(int left,int right)&#123; if(left&gt;=right) return; if(right-left+1&lt;10)&#123; //这里就是如果长度小于10，就使用直接插入排序 insertsort(left,right); return; &#125; int ranw=rand()%(right-left+1)+left;//此处为随机化 swap(a[left],a[ranw]);//此处为将随机取得元素与第一个元素互换位置 while(i&lt;j)&#123; while(j&gt;i&amp;&amp;a[j]&gt;=a[left]) j--; while(i&lt;j&amp;&amp;a[i]&lt;=a[left]) i++; swap(a[i],(i==j)?a[left]:a[j]); &#125; quicksort(a,left,i-1);//递归 quicksort(a,j+1,right);&#125; 方法三：聚拢重复元素待补充===========================================我是可爱的分割线===========================================除了上述三种对快速排序的优化，我们还可以使用堆排序。方法四：堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int num=0;int n;int a[1000100];void up(int x)&#123;//上浮操作 while(a[x/2]&gt;a[x]&amp;&amp;x!=1)&#123; swap(a[x],a[x/2]); x/=2; &#125;&#125;void down(int x)&#123;//下沉操作 while((a[x*2]&lt;=a[x]&amp;&amp;x*2&lt;=num)||(a[x*2+1]&lt;=a[x]&amp;&amp;x*2+1&lt;=num))&#123; if(a[x*2]&lt;=a[2*x+1])&#123; swap(a[x],a[x*2]); x*=2; &#125;else&#123; swap(a[x],a[x*2+1]); x=x*2+1; &#125; &#125;&#125;void insert(int x)&#123;//向堆中插入元素，建堆的核心操作所在 num++; a[num]=x;//数组a是从下标1开始存储数据 up(num);&#125;void work()&#123;//建堆成功后，将堆顶元素和最后一个元素互换位置//堆顶元素先输出，然后被最后一个元素覆盖，//就相当于将堆顶元素删除了，（即不再参与排序） printf(\"%d \",a[1]);//打印堆顶元素 a[1]=a[num--];//堆顶元素被覆盖 //上面一句话可以这样写,更好理解 //a[1]=a[num]; //num--; //因为堆顶元素被覆盖了，自然的堆中元素的个数要减一，即num-- down(1);//元素变化后，重新通过下沉，排序成一个新的堆&#125;void build()&#123;//输入数字，调用插入函数，建堆 for(int i=1;i&lt;=n;i++)&#123; int z; scanf(\"%d\",&amp;z); insert(z); &#125;&#125;void shuchu()&#123; while(num!=1) work(); printf(\"%d\",a[1]);&#125;int main()&#123; scanf(\"%d\",&amp;n); build(); shuchu(); return 0;&#125;","link":"/2019/06/18/ruogu-quicksort/"},{"title":"web scraping with python","text":"之前就有对网络爬虫很感兴趣，觉得这是一件比较有意思的事情，奈何前段时间有接触过，学到后面的时候有点吃力，总结了一下原因之后觉得最直接的原因就是在前端方面自己接触的还是太少了，现在在准备论文之余。。。（为何总对论文的内容不感兴趣呢-_-！）再来重新看一遍爬虫吧。。哈哈，突然觉得保持一整天学习的热情的秘诀就是:把每一天的早晨的时间都用在自己感兴趣的事情上。 好了，进入正题，直接来看代码： 1234567891011121314151617181920from urllib.request import urlopenfrom urllib.error import HTTPError,URLErrorfrom bs4 import BeautifulSoupdef getTitle(url): try : html=urlopen(url) except (HTTPError,URLError) as e: return None try: bsObj=BeautifulSoup(html.read()) title=bsObj.body.h1 except AttributeError as e: return None return title title=getTitle(\"http://aisleep.xyz\")if title ==None: print(\"Title could not be found\")else: print(title) 首先是引入几个需要用到的库，request中的urlopen，beautifulsoup，是爬虫经常需要用到的库（这里代码中的BeautifulSoup是BeautifulSoup库中的BeautifulSoup对象，不是指的BeautifulSoup库），前者是自带的，能够直接获取网页中的html代码，而后者是第三方库，需要自己安装，他是用来转换我们得到的html代码的结构，使其能够只要目标信息的旁边或附近有标记（这里说的标记是HTML中的标记）我们就能够提取出来。HTTPError和URLError则是对异常的处理所需要的。 我们这里首先定义了一个名为getTitle的函数。我们在进行这个语句的时候：html=urlopen(&quot;http://aisleep.xyz&quot;)这行代码可能会发生两种异常：1、网页不在服务器上；2、服务器不存在。发生第一种异常，程序会抛出HTTpError异常，发生第二种异常，程序会返回一个None对象。所以getTitle函数中的第一个异常处理针对于HTTPError，还增加了一个防止url地址输入错误引起的URLError。 然后，我们在使用BeautifulSoup去提取我们所需要的信息时也会出错：如果我们想要调用的标签不存在，BeautifulSoup会返回一个None对象；如果再去调用这个None对象下面的子标签，还会发生AttributeError错误。 所以第二个异常处理针对于：1、因为服务器不存在而返回一个None值，后再调用这个None值（通过html.read()调用）引起的AttributeError异常。2、因为我们使用BeautifulSoup调用一个不存在的标签的时候返回了一个None值，后再调用这个None值下面的子标签而造成的AttributeError异常。 针对于爬虫中比较常见的异常处理，这样一来就会很简单的使自己的代码更稳定一点。 上面的是采集一个页面中需要的信息，下面再看一个代码，实现随机的从一个页面跳转到另一个页面： 12345678910111213141516171819from urllib.request import urlopenfrom bs4 import BeautifulSoupimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(articleUrl)： html=urlopen(\"http://en.wikipedia.org\"+articleUrl) bsObj=BeautifulSoup(html) return bsObj.find(\"div\",&#123;\"id\":\"bodyContent\"&#125;).findAll(\"a\",href=re.compile(\"^(/wiki/)((?!:).)*$\"))links=getLinks(\"/wiki/Kevin_Bacon\")while len(links)&gt;0: newArticle=links[random.randint(0,len(links)-1)].attrs[\"href\"] print(newArticle) links=getLinks(newArticle) 首先这里导入了一些需要的库，datetime和random分别是为了生成一个随机数生成器。第7行中就是通过当前时间为值实现了一个随机数生成器。接着定义了一个函数getLitle我们传入的是以http://en.wikipedia.org为开头的url然后传入Beautifulsoup，最后返回在当前网页（用的是find）中的在div标签下的id是bodyContent的，且不包含:的以/wiki/开头的所有url链接（返回的是一个列表，这里用了正则表达式来匹配所要满足条件的链接）。 第14行写到以Kevin_Bacon为开始页面，调用getLinks函数。16行往下是指在返回的列表不为空的情况下，以随机数生成器生成的随机数作为列表的序号，去访问另一个链接，跳转到另一个页面，打印这个链接，最后又将此链接传给getLitle函数。 接下面再看一个代码： 1234567891011121314151617from urllib.request import urlopenfrom bs4 import BeautifulSoupimport repages=set()def getLinks(pageUrl): global pages html = urlopen(\"http://wikipedia.org\"+pageUrl) bsObj=BeautifulSoup(html) for link in bsObj.findAll(\"a\",href=re.compile(\"^(/wiki/)\")): if 'href' in link.attrs: if link.attrs['href'] not in pages: newPage=link.attrs['href'] print(newPage) pages.add(newPage) getLinks(newPage)getLinks(\"\") 由于链接之间很多都是重复的，所以自然就会有需要“链接去重”的功能。首先定义了一个set集合类型的变量pages，接着我们看getLinks函数，第7行是定义全局变量pages，然后找到以/wiki/开头的链接。第12行是判断这个链接是否在pages中，如果不在就说明是新链接，打印且将他增加到pages中，最后将这个newPage又传入getLinks函数,递归处理。 var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/03/23/scraping-with-python/"},{"title":"data-structure———查找","text":"注意一下有一个概念：平均查找长度：ASL 顺序查找：举例如果从一个无序数组a（数组下标从1开始）中找到值为k的元素，查找成功就返回1，不成功就返回0，采用顺序查找的话：12345678int Search(int a[] ,int n ,int k)&#123; int i ; for(i=1;i&lt;=n;i++) if(a[i]==k) return 1; return 0;&#125; 以上是使用顺序表的时候的情况，下面再看一下链式结构的情况：1234567891011LNode* search(LNode* head,int key)&#123; LNode* p = head-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==key) return p; p=p-&gt;next; //注意一下 &#125; return 0; //注意一下这个没有找到所要值得情况的位置&#125; 一个是使用循环递增i数组下标，还有一个是使用p=p-&gt;next，一个一个的顺序访问。折半查找：折半查找的要求是表中记录是按关键字有序的。用到的是递归的思想。123456789101112131415int Bsearch(int R[],int low,int high,int k)&#123; int mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(R[mid]==k) return mid; else if(R[mid]&gt;k) high=mid-1; else if(R[mid]&lt;k) low=mid+1; &#125; return 0;&#125; 这里的low，high，mid是下标，不是值的大小分块查找： 索引表：12345678typedef struct //索引表结构体&#123; int key; //存放这个表中的最大的关键字 int low,high; //存放这个块中的第一个和最后一个元素的位置&#125;indexElem;indexElem index[maxsize]; //定义索引表 查找过程是先使用二分查找法找到带查找元素在哪一个块中，然后在块中使用顺序查找就好，因为在一个块中的元素的个数就已经很少了。 二叉排序树和平衡二叉树： 二叉排序树的定义： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 二叉排序树的存储结构：采用二叉链表存储123456typedef struct BTNode&#123; int key; struct BTNode *rchild; struct BTNode *lchild;&#125;BTNode; 二叉排序树中查找关键字的算法：1234567891011121314BTNode *BSTSearch(BTNode *bt,int key)&#123; if(bt==NULL) return NULL; else &#123; if(bt-&gt;key==key) return bt; else if(key&lt;bt-&gt;key) return BSTSearch(bt-&gt;lChild,key); else if(key&gt;bt-&gt;key) return BSTSearch(bt-&gt;rchild,key); &#125;&#125; 可以看到这里的查找的过程和折半查找的过程非常相似，其实，实质上折半查找（判定树是二叉排序树）就是二叉排序树的查找过程。 二叉树的插入关键字的算法：1234567891011121314151617181920int BSTInsert(BTNode *&amp;bt,int key)&#123; if(bt==NULL) //对应的是空树的情况 &#123; bt=(BTNode *)malloc(sizeof(BTNode)); bt-&gt;rchild=NULL; bt-&gt;lchild=NULL; bt-&gt;key=key; return 1; &#125; else &#123; if(bt-&gt;key==key) //对应的是待插入的值已经在树中 return 0; else if(bt-&gt;key&gt;key) //这里往后就很像查找算法 return BSTInsert(lchild,key); else return BSTInsert(rChild,key); &#125;&#125; 不管什么情况，插入关键字都是在新创建的结点上，最后的递归处理对应的是，找到合适的插入的位置，一层一层的递归，最后还是会创建新结点，将要插入的值插入到新创建的结点处。 二叉树的构造算法：假设所要构造的值都已经存储在了数组中1234567void CreateBST(BTNode *&amp;bt,int key[],int n)&#123; int i; bt=NULL; //将树置空 for(i=0,i&lt;n,i++) BSTInsert(bt,key[i]);&#125; 这里使用了上面的插入算法。","link":"/2018/09/16/search-1/"},{"title":"The Art of Unhappiness","text":"Sunday, Jan. 09, 2005 By James Poniewozik Many things make people think artists are weird–the odd hours, the nonconformity, the clove cigarettes. But the weirdest may be this: artists’ only job is to explore emotions, and yet they choose to focus on the ones that feel lousy. Art today can give you anomie, no problem. Bittersweetness? You got it. Tristesse? What size you want that in? But great art, as defined by those in the great-art-defining business, is almost never about simple, unironic happiness. This wasn’t always so. The earliest forms of art, like painting and music, are those best suited for expressing joy. But somewhere in the 19th century, more artists began seeing happiness as insipid, phony or, worst of all, boring–in Tolstoy’s words, “All happy families are alike.” We went from Wordsworth’s daffodils to Baudelaire’s flowers of evil. In the 20th century, classical music became more atonal, visual art more unsettling. Artists who focused on making their audiences feel good, from Usher to Thomas Kinkade, were labeled “pop.” Sure, there have been exceptions (say, Matisse’s The Dance), but it would not be a stretch to say that for the past century or so, serious art has been at war with happiness. In 1824, Beethoven completed the “Ode to Joy.” In 1962, novelist Anthony Burgess used it in A Clockwork Orange as the favorite piece of his ultraviolent antihero. If someone titles an art movie Happiness, it is a good bet that it will be–as the 1998 Todd Solondz film was–about deeply unhappy people, including a telephone pervert and a pedophile. You could argue that art became more skeptical of happiness because modern times have seen such misery. But it’s not as if earlier times didn’t know perpetual war, disaster and the massacre of innocents. The reason, in fact, may be just the opposite: there is too much damn happiness in the world today. After all, what is the one modern form of expression almost completely dedicated to depicting happiness? Advertising. The rise of anti-happy art almost exactly tracks the emergence of mass media, and with it, a commercial culture in which happiness is not just an ideal but an ideology. People in earlier eras were surrounded by reminders of misery. They worked gruelingly, lived with few protections and died young. In the West, before mass communication and literacy, the most powerful mass medium was the church, which reminded worshippers that their souls were in peril and that they would someday be meat for worms. On top of all this, they did not exactly need their art to be a bummer too. Today the messages your average Westerner is bombarded with are not religious but commercial, and relentlessly happy. Fast-food eaters, news anchors, text messengers, all smiling, smiling, smiling, except for that guy who keeps losing loans to Ditech. Our magazines feature beaming celebrities and happy families in perfect homes. (Tolstoy clearly never edited a shelter mag.) And since these messages have an agenda–to pry our wallets from our pockets–they make the very idea of happiness seem bogus. “Celebrate!” commanded the ads for the arthritis drug Celebrex, before we found out it could increase the risk of heart attacks. It gets exhausting, this constant goad to joy. If you’re not smiling–after we made all those wonderful pills and cell-phone plans!–what’s wrong with you? Not to smile is un-American. You can pick out the Americans in a crowd of tourists by their reflexive grins. The U.S. enshrined in its founding document the right to the pursuit of happiness. So we pursued it and–at least as commerce defines it–we caught it. Now, like the dog that chased and finally caught the car, we don’t know what the hell to do with it. We feel vaguely dissatisfied though we have what we should want, vaguely guilty for wanting it, vaguely angry because it didn’t come as advertised. People tsk-tsked over last month’s study in which women reported being happier having sex or watching TV than playing with their kids. But why shouldn’t they? This is how the market defines happiness. Happiness is feeling good. Kids, those who exist outside ads, make you feel bad–exhausted, frustrated, bored and poor. Then they move away and break your heart. What we forget–what our economy depends on us forgetting–is that happiness is more than pleasure sans pain. The things that bring the greatest joy carry the greatest potential for loss and disappointment. Today, surrounded by promises of easy happiness, we need someone to tell us that it is O.K. not to be happy, that sadness makes happiness deeper. As the wine-connoisseur movie Sideways tells us, it is the kiss of decay and mortality that makes grape juice into Pinot Noir. We need art to tell us, as religion once did, Memento mori: remember that you will die, that everything ends, and that happiness comes not in denying this but in living with it. It’s a message even more bitter than a clove cigarette, yet, somehow, a breath of fresh air. article link","link":"/2019/05/13/some-articles/"},{"title":"tcp协议概念辨析","text":"之前学的网络这块的知识感觉都忘得差不多了，加之网络本来也比较理论抽象的。。。概念都有点模糊了。。趁复习之余就整理一下~暂时先准备从几个方面谈一下tcp协议吧。。。这个太多了，一点一点写吧~想到再加。 主要从：特点，握手协议，arq协议，流量控制，拥塞控制，可靠传输的原理等方面去谈起。首先： tcp协议的特点:(这里只主要讲解tcp是面向字节流的这一特点) 首先tcp是面向连接的。在使用tcp协议之前一定要先建立tcp连接，传输数据完毕之后也要释放tcp的连接。 每一条tcp的连接只能有两个端点，每一个tcp的连接都是点对点的连接。 tcp连接是可靠交付的连接。目的是无差错，不丢失，不重复。 tcp提供全双工通信。tcp的两端都设有“接收缓存”和“发送缓存”，在发送时，应用程序把数据传送给tcp的缓存后就可以去做自己的事情，tcp在合适的时间再从缓存中去取自己需要的数据发送出去。在接收时，tcp将收到的数据放入缓存，上层的应用在合适的时间从缓存中取走自己需要的数据就好。 tcp是面向字节流的。这里详细讲一下“字节流”和“tcp报文段”的区别与联系。“tcp传送数据的单元是“tcp报文段””，这句话的意思准确来说是：tcp与应用进程在交互的时候的数据单元是“报文段”。从某种方面上来说字节流组成相应的报文段。应用程序和tcp进行交互的时候是按照一段一段的“报文段”，但是，tcp自身在接收到后，在处理这些“报文段”的时候是又将其分成一个一个的“字节流”去发送的。tcp不关心应用进程一次把多长的“报文段”发送到tcp的缓存中，他会将其分成更小的“字节流”，根据对方的窗口值和网络拥塞情况去决定选择多少“字节流”组成“报文段”再发送出去。（udp则是进程发送了多大的报文段他就传送多大的报文段）。再啰嗦一句，tcp和应用进程在接收和发送的时候都是以“报文段”为传送的数据单元，而tcp自己在处理这些“报文段”的时候，又会将其分成“字节”，整体上看就有了所谓的“字节流”，所以，“字节流”是tcp自身在处理时的数据单元。 tcp的三次握手：（这里依然一样，不讲解主要的细节流程，只讲解为什么要三次握手，为什么不是两次握手，四次握手？） （图片来源：Michael Kerrisk） 这里，在客户机（client）收到服务器(server)发送的确认报文段后（SYN N,ACK M+1）,客户机还需要再发送一条确认报文段。为什么要再发送一条？假定之前，客户机向服务器发送一条请求报文段1（SYN M），由于某种原因这条请求报文段1没有及时送达，服务器自然就不会发送确认报文段，这时，客户机就会重新发送一条请求报文段2，后来成功建立了连接。但是，再重新建立连接后，假定之前发送的请求报文段1突然又成功的传到了服务器那里，那么服务器会误认为是客户机给他发送的请求报文段，这时他就会发送一个确认报文段给客户机，而客户机是不会响应这个确认报文段的（因为这个确认报文段是由先前认为他已经丢失的请求报文段1的回应），客户机还是会自己干自己的事情，而服务器却在那等待着客户机传送报文段。浪费了服务器的资源。 考完试了更新一下网络中的各个数据报的结构吧，嗯。。挖个坑。","link":"/2018/03/15/tcp-introduction/"},{"title":"线性表问题总结","text":"逆置问题：例1：1、将一长度为n的数组的前端K（k&lt;n）个元素逆序后移动到数组后段，要求原数组总数据不丢失。2、将一长度为n的数组的前端K（k&lt;n）个元素保持原序后移动到数组后段，要求原数组总数据不丢失。3、将数组中的元素循环左移p（0&lt;p&lt;n）个位置。1234567891011void reverse(int a[],int left,int right,int k)&#123; int temp; for (int i=left,j=right;i&lt;left+k &amp;&amp; i&lt;j;++i,--j) //因为k的长度有可能超过数组长度的一半 &#123; //所以i&lt;j这个条件还是要加上去的 temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 12345void moveToEnd(int a [],int n ,int k)&#123; reverse(a,0,k-1,k); reverse(a,0,n-1,k);&#125; 123456void moveP(int a [],int n,int p)&#123; reverse(a,0,p-1,p); reverse(a,p,n-1,n-p); reverse(a,0,n-1,n);&#125; 最值问题：1：在线性表中找最值 12345678910int max=a[0]; int maxIdx=0;for(int i=0;i&lt;n;++i)&#123; if (max&lt;a[i]) &#123; max=a[i]; //max值 maxIdx=i; //最大值的位置 &#125;&#125; 这个是最大值，最小值同理。 2：在链表中找最小值： 123456789101112LNode *p,*q;int min=head-&gt;next-&gt;data;q=p=head-&gt;next;while(p!=NULL)&#123; if(min&gt;p-&gt;data) &#123; min=p-&gt;data; q=p; &#125; p=p-&gt;data;&#125; 在链表中找最大值同理。 例：一双链表非空，有head指针指出，结点结构为{llink,data,rlink},请设计一个将结点数据域data值最大的那个结点（最大值结点只有一个）移动到链表最前边的算法，要求不得申请新结点空间。12345678910111213141516171819202122232425void maxFirst(DLNode *head)&#123; DLNode *p=head-&gt;rlink,*q=p; int max=p-&gt;data; while(p!=NULL) &#123; if(max&lt;p-&gt;data) &#123; max=p-&gt;data; q=p; &#125; p=p-&gt;rlink; &#125; DLNode *l=q-&gt;llink; *r=q-&gt;rlink; l-&gt;rlink=r; if(r!=NULL) //防止最大值为最后一个结点 r-&gt;llink=l; q-&gt;llink=head; q-&gt;rlink=head-&gt;rlink; head-&gt;rlink=q; q-&gt;rlink-&gt;llink=q;&#125; 归并问题：1：顺序表归并12345678910111213141516void mergearray(int a [],int m,int b[],int n,int c[])&#123; int i=0,j=0; int k=0; while(i&lt;m&amp;&amp;j&lt;n) &#123; if(a[i]&lt;b[j]) c[k++]=a[i++]; //c[k]=a[i];k++;i++ else c[k++]=b[j++]; &#125; while(i&lt;m) c[k++]=a[i++]; while(j&lt;n) c[k++]=b[j++];&#125; 分别将a[]和b[]的数组有小到大的归并为数组c[]，m,n分别为两个数组的长度，c数组的长度为两个长度的之和，所以不需要再来一个变量来存储了。i,j分别是数组下标用来指出哪个元素在进行比较，k是指向c数组的下标。如果a[i]&lt;b[j]则将a[i]赋值给c[k]，且k向后移一位，i也向后移一位。下一个while是在一个数组全部比较完而另一个数组还有剩余的时候，将剩余的数组中的每一个元素都移动到数组c中去。 2：链表归并–顺序归并123456789101112131415161718192021222324252627282930void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *r; C=A; C-&gt;next=NULL; free(B); r=C; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; r-&gt;next=p; p=p-&gt;next; r=r-&gt;next; &#125; else &#123; r-&gt;next=q; q=q-&gt;next; r=r-&gt;next; &#125; if(p!=NULL) r-&gt;next=p; if(q!=NULL) r-&gt;next=q; &#125;&#125; p,q是指向两个链表的指针，C是指向新链表的指针，r是指向新链表表尾的指针。C=A是以A链表的头结点作为新链表的头结点。然后释放B结点（头结点）。此时新链表为空链表，所以r指针指向此时的头结点r=C。 –逆序归并123456789101112131415161718192021222324252627282930313233343536373839404142void mergeR(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *s; C=A; C-&gt;next=NULL; free(B); while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; else &#123; s=q; q=q-&gt;next; s-&gt;nexr=C-&gt;next; c-&gt;next=s; &#125; while(p!=NULL) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; while(q!=NULL) &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; &#125;&#125; 用头插法的形式重新进行归并，这样就得到了逆序。在一个链表的元素全部取完之后，逆序的话剩余的元素就不能直接修改指针了，要用循环将剩余的元素一个一个的以头插法的形式插入到新链表中。 划分问题：取什么数作为树轴，这个数的大小是关键，这个数的由来不是关键。1：以数组中的第一个元素为树轴，左边的元素为小于树轴的元素，右边的元素为大于树轴的元素。1234567891011121314151617181920212223242526void partition(int arr[],int n)&#123; int temp; int i=0;j=n-1; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 2：以任意一个数作为树轴，左边的元素为小于树轴的元素，右边的元素为大于树轴的元素。1234567891011121314151617181920212223242526void partition(int arr[],int n,int comp)&#123; int temp; int i=0;j=n-1; temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=comp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;comp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 这里i和j共同指向的还是temp，comp只是一个比较大小的标准，comp都不一定是数组中存在的元素。理解最前面的黑体字就懂这个类型了。3：以数组元素中的任意一个元素作为树轴，左边小于树轴，右边大于树轴。 1234567891011121314151617181920212223242526272829void partition(int arr[],int n ,int k)&#123; int temp; int i=0;j=n-1; temp=arr[0]; //区别就在这三句话，1 arr[0]=arr[k]; //2 arr[k]=temp; //3 temp=arr[i]; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;arr[j]&gt;=temp) --j; if(i&lt;j) &#123; arr[i]=arr[j]; ++i; &#125; while(i&lt;j&amp;&amp;arr[i]&lt;temp) ++i; if(i&lt;j) &#123; arr[j]=arr[i]; --j; &#125; &#125; arr[i]=temp; &#125; 将这个数组中k位置的值直接放在数组中的第一个位置那就行。之所以放在第一个那，只是后面的代码和第一种情况的一个统一，更方便的去操作。","link":"/2018/08/03/xianxingbiao-prac1/"},{"title":"css小笔记","text":"唤醒记忆三部曲——css(Cascading Style Sheets) css简单介绍： 众所周知，css是帮助人们将文档信息的内容和如何展现它的细节相分离。以便人们更好的处理文档的“内容”和“样式”。 那么浏览器是怎么处理标志语言和css的呢？ 浏览器首先将标记语言和css转换成dom（文档对象模型）结构。之后，浏览器将dom的内容展现出来。 这里再讲一下dom结构和标记语言中的元素的区别：首先，我们可以将标记语言如html中的&lt;p&gt;标签称为“元素”。这里的元素可以允许我们把它作为一个容器去存储信息： 12345&lt;p&gt; &lt;strong&gt;C&lt;/strong&gt;ascading &lt;strong&gt;S&lt;/strong&gt;tyle &lt;strong&gt;S&lt;/strong&gt;heets&lt;/p&gt; 这里就用&lt;p&gt;和&lt;/p&gt; 构造了一个容器。而dom结构是一个树形结构，每个元素和非空文本都可以看做是树形结构上的一个结点。dom不再是一个容器，但是，它可以看做为子节点的父节点而存在。可以看： P ├─STRONG │ └─&quot;C&quot; ├─&quot;ascading&quot; ├─STRONG │ └─&quot;S&quot; ├─&quot;tyle&quot; ├─STRONG │ └─&quot;S&quot; └─&quot;heets&quot; 针对上面的html标记语言，dom模型可以这样去理解其结构。 层叠和继承: 一个元素的样式，有很多种定义的方式，对于层叠来说，主要有三种样式的来源： 浏览器对HTML定义的默认样式 用户定义的样式 开发者定义的样式：1、定义在外部文件（外链样式）2、在页面的头部定义（内联样式）3、定义在特定的元素身上（行内样式） 他们之间的优先级是：浏览器默认定义&lt;用户定义&lt;开发者定义。我们这里主要是针对于开发者定义。css还提供了使用!important关键字，使关键字处的样式立马成为最高级别的优先级。 选择器: 元素选择器 请看下面这个例子： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;a&lt;/div&gt; &lt;p&gt;b&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这里是一段html的代码，我在body中分别写了两个标签，然后请看index.css代码： 123div &#123; color: red;&#125; index.css中，这个代码的意思是以&lt;div&gt;标签为选择器，括号中是对其进行的申明（declaration），其中的color是“属性”，red是对应的“值”。&lt;div&gt;标签中的a就会被变为红色。如果想同时选择多个标签作为选择器，那么他么之间只需要加一个英文的逗号即可。这种以标签类型作为选择条件的方法我们就称为类型选择器。 类选择器（class selectors） 类选择器主要是通过设置元素的class属性，然后通过“类”（class）对其进行选择，请看： 1234567891011!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;a&lt;/div&gt; &lt;p class=\"afv\"&gt;bab&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这里我们将&lt;p&gt;标签添加了class=&quot;afv&quot;这个“类”，然后请看index.css代码： 123.afv &#123; color: red;&#125; 这里我们通过.afv这样的格式，选定了有类为afv的元素，然后就可以将bab变为了红色。注意，其中的&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;这句话的意思是链接一个名为index的外部样式表，这句话不能省略。如果，同时定义两个类，那么类之间需要添加一个空格就好： 123...&lt;p class=\"afv xcs\"&gt;... 此时想要选择同时有afv和xcs的类时，index.css就可以这样： 123.afv.xcs &#123; color: red;&#125; 如果在定义类时是这样的：（span是用来组合文档中的行内元素） 123&lt;p class=\"afv\"&gt; &lt;span class=\"xcs\"&gt;&lt;/span&gt;&lt;/p&gt; index.css文件就要这样 123.afv .xcs &#123; font-weight:bolder;&#125; 在两个属性之间要有一个空格。 id选择器 一般id选择器只用于页面中的唯一的元素，例如： 1&lt;p id=\"principal\"&gt;logo&lt;/p&gt; 在index.css文件中这样来选择： 123#principal &#123; color:bolder; &#125; 属性选择器 例如此段代码： 123&lt;body&gt; &lt;button title=\"提交此文件\"&gt;提交&lt;/button&gt;&lt;/body&gt; 可以通过属性“title”去选择：看index.css文件： 123[title] &#123; color: blue;&#125; 此时就可以将含有title元素的button的字体“提交”改为了蓝色。如果我们想特定的选择属性值为xx的，可以直接这样书写： 123[title=\"提交此文件\"] &#123; color: blue;&#125; 这样选择控制就更加的精确。 如果，index.css文件是这样： 123[title*=\"提交\"] &#123; color: blue;&#125; 这个的意思是选择只要属性中包含“提交”两字的所有元素。上面的直接等号是指完全匹配，注意区分。 如果，index.css文件是这样的： 123[title^=\"提交\"] &#123; color: blue;&#125; 这里的意思是选择那些元素中包含“提交”两字的，且必须是以“提交”两字开头的元素。 如果想选择以“提交”两个字结束的元素，那么可以这样： 123[title$=\"提交\"] &#123; color: blue;&#125; 如果想选择特定标签的特定属性的元素，那么可以这样： 123a[title] &#123; color: blue;&#125; 后代选择器 例如看下面这个例子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"a\"&gt;a &lt;div class=\"b\"&gt;b &lt;div class=\"c\"&gt;c &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里嵌套了三个div标签，然后请看asd.css：123.a .b .c &#123; border: 2px solid black;&#125; 这里因为我们是对“类”进行选择，所以要加一个点号，这里.a .b .c（.a前面没有空格）的意思是在a的下面去找b再在b的下面去找c，中间用空格去隔开。也可以.a .c依然可以定位到类c，所以说，只要类a下面有类c就可以。也可以.a *（.a和*之间有空格）选择类a下面的所有类，以此类推。总的来说，注意他们之间的嵌套关系，使用空格，*号去操作就可以，要灵活使用。 相邻选择器 例如请看： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"a\"&gt;a&lt;/div&gt; &lt;div class=\"b\"&gt;b&lt;/div&gt; &lt;div class=\"c\"&gt;c&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里有三个并行的div标签。然后我们可以这样对其选择： 123.a + div &#123; background: rgba(220,0,0,.4);&#125; 这里因为我们是选择类a，所有要加一个点号，然后使用+号，意思是选择类a的相邻的（准确的来说是选择类a下面的一个，因为相邻选择器只会至下选择）一个div标签。如果想要选择类a下面的所有的标签，可以这样： 123.a ~ div &#123; background: rgba(220,0,0,.4);&#125; 当然上面两个中的div都可以直接写成.b这里之所以写.div就是假如类a的弟弟没有“类”呢。也当然，我也可以直接写.b直接选择到了类b的元素，这里之所以这样写只是为了说明相邻选择器的工作方式，不要误会~~ 伪类选择器 同样看例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://google.com\"&gt;google&lt;/a&gt; &lt;input type=\"text\"&gt; &lt;button&gt;进入&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 这里分别有一个链接，一个输入框，一个按钮，接着看asd.css： 12345678910111213141516171819a:link &#123; color: red;&#125;a:visited &#123; color: blue;&#125;button:hover &#123; background: #fff;&#125;button:active &#123; background: #111;&#125;input:focus &#123; outline: none;&#125; 这里第1行是选择a标签，且网址链接没有点击的话就显示为红色，第5行的意思是如果网址被点击过，那么就显示为蓝色。第8行是选择button标签，hover的作用是在鼠标悬停在按钮上时的效果，这里为背景色为#fff。hover同样可以在&lt;a&gt;标签中使用。button:active的作用是设置按钮在被触发时候的效果。input:focus的作用是设置选定输入框时的效果。这里只例举了几个常用的伪类选择器。 伪元素选择器 直接看例子：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"stylesheet\" href=\"asd.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;a class=\"comm\"&gt;查看目录&lt;/a&gt; &lt;a class=\"comm\"&gt;查看目录&lt;/a&gt; &lt;p&gt;i love learning css! &lt;/p&gt; &lt;div&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt; &lt;/div&gt; &lt;/html&gt; 这里写了两个链接，一个段落，一个div里面有三个p标签，现在使用伪元素选择器对其进行修改： 12345678910111213141516171819202122232425p:first-letter &#123; font-size: 25px;&#125;.comm:before &#123; content: \"-\"; color: blue;&#125;.comm:after &#123; content: \"@\"; color: red;&#125;div p:first-child &#123; color: blue;&#125;div p:last-child &#123; color: red;&#125;div p:nth-child(2) &#123; color: green;&#125; 这里第1-3行的意思是选择p标签且对他的第一个字母改变字体大小，使用first-letter。第5-8行分别是选择了类comm，所以要加一个点号，接着使用before在其前面添加了一个-，第10-13行一个意思，只是是在最后加。（这里使用了content，一般css只对样式进行修改，不会改变其中的内容，而这里是为数不多的css中增加了内容的用法，注意）第15-17行，是先选择div标签后再选择p标签，后对其中的“第一个孩子”进行修改。第19-21行是对“最后一个孩子”，第23-25是通过传值来指定选择“哪一个孩子”。不难类推。","link":"/2018/03/21/css-learning/"},{"title":"data structure——栈和队列","text":"栈和队列的特点是：栈(stack)是先进后出，而队列是先进先出。 栈的不同形式的定义： 顺序栈的定义： 12345typedef struct&#123; int data[maxsize]; //存放栈中元素 int top; //注意这是栈顶指针，这个指针是用来指数组中的元素的，不是在结点中的指针域&#125; 链栈结点定义：(即用链表来存储栈) 12345typedef struct LNode&#123; int data; //数据域 struct LNode *next; //指针域&#125;LNode; 顺序栈的一些操作： 初始化栈1234void initStack(SqStack &amp;st)&#123; st.top=-1; //栈顶指针设置为-1&#125; 或者可以简写：int stack[maxsize-1];int top==-1; 判断栈空 1234567int isEmpty(SqStack st)&#123; if(st.top==maxsize-1) return 1; else return 0;&#125; 进栈 12345678int push(SqStack &amp;st,int x)&#123; if(st.top==-1) return 0; ++(st.top); st.data[st.top]=x; return 1;&#125; 或者也可以简写：stack[++top]=x; 出栈12345678int pop(SqStack &amp;st, int x)&#123; if(st.top==-1) return 0; x=st.data[st.top]; --(st.top); return 1;&#125; 或者也可以简写：x=stack[top--]; 链栈的一些操作: 初始化链栈 12345void initStack(LNode *&amp;lst)&#123; lst=(LNode* )malloc(sizeof(LNode)); //制造一个头结点 lst-&gt;next=NULL;&#125; 判断栈空 1234567int isEmpty(LNode *lst)&#123; if(lst-&gt;next=NULL) return 0; else return 1;&#125; 进栈操作 123456789void push(LNode *lst,int x)&#123; LNode *p; p=(LNode *)malloc(sizeof(LNode)); p-&gt;next=NULL; p-&gt;data=x; p-&gt;next=lst-&gt;next; lst-&gt;next=p;&#125; 出栈操作 1234567891011void pop(LNode *lst, int &amp;x)&#123; LNode *p; if(lst-&gt;next==NULL) return 0; p-&gt;next=lst-&gt;next; p-&gt;data=x; lst-&gt;next=p-&gt;next; free(p); return 1;&#125; 队列的不同形式的定义： 顺序队列的定义： 123456typedef struct&#123; int data[maxsize]; //用一个数组存储数据 int front; //队首指针 int rear; //队尾指针&#125;sqQueue; 链队定义：队结点类型定义： 12345typedef struct QNode&#123; int data; //数据域 struct QNode *next; //指针域&#125;QNode; 链队类型定义： 12345typedef struct&#123; QNode *front; //队头指针 QNode *rear; //队尾指针&#125;LiQueue; 循环队列的一些操作: 初始化 1234void initQueue(SqQueue &amp;qu)&#123; qu.front=qu.rear=0;&#125; 判断队空： 1234567void isQueueEmpty(sqQueue qu)&#123; if(qu.rear=qu.front) return 1; else return 0;&#125; 进队： 1234567891011void enQueue(sqQueue &amp;qu,int x)&#123; if((qu.rear+1)%maxsize==qu.front) return 0; else &#123; qu.rear=(qu.rear+1)%maxsize; qu.data[qu.rear]=x; return 1; &#125;&#125; 出队： 1234567891011void deQueue(sqQueue &amp;qu,int x)&#123; if(qu.front==qu.rear) return 0; else &#123; qu.front=(qu.front+1)%maxsize; x=qu.data[qu.front]; return 1; &#125;&#125; 链队的一些操作： 初始化 12345void initQueue(LiQueue *&amp;lqu)&#123; lqu=(LiQueue *)malloc(sizeof(LiQueue)); lqu-&gt;front=lqu-&gt;rear=NULL;&#125; 判断队空 1234567int isQueueEmpty(LiQueue *lqu)&#123; if(lqu-&gt;front==NULL||lqu-&gt;rear==NULL) return 1; else return 0;&#125; 入队 123456789101112131415void enQueue(LiQueue *lqu,int x)&#123; QNode *p; //指针p是另一个结构体而来的 p=(QNode *)malloc(sizeof(QNode)); p-&gt;data=x; p-&gt;next=NULL; if(lqu-&gt;rear==NULL) lqu-&gt;front=lqu-&gt;rear=p; else &#123; lqu-&gt;rear-&gt;next=p; //将新节点连接至队尾，rear指向它 lqu-&gt;rear=p; &#125;&#125; 出队 123456789101112131415void deQueue(LiQueue *lqu ,int &amp;x)&#123; QNode *p; if(lst-&gt;rear=NULL) return 0; else p=lst-&gt;front; if (lqu-&gt;front==lqu-&gt;rear) lqu-&gt;front=lqu-&gt;rear==NULL; else lqu-&gt;front=lqu-&gt;front-&gt;next; x=p-&gt;data; free(p); return 1;&#125; 应用 顺序栈的应用 1.设计一个算法，判断一个表达式中的括号是否正确的配对，表达式已经存入字符数组exp[]中，表达式中的字符个数是n。 12345678910111213141516171819202122int match(char exp[],int n)&#123; char stack[maxsize-1]; int top==-1; int i; for(i=0;i&lt;n;++i) &#123; if(exp[i]=='(') stack[++top]='('; if(exp[i]==')') &#123; if(top==-1) return 0; else --top; &#125; &#125; if(top==-1) return 1; else return 0;&#125; 此列题很好的说明了栈是一种有效处理”先进后出”的一种数据类型，也就是说，当以后遇到一种问题，在处理问题的过程中如果出现了一个子问题，那么先解决了这个子问题再来处理这个问题的处理思路可以使用栈这个模型去解决问题。 2.编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中，exp中最后一个字符为\\0，作为结束符，并假设后缀式中的数字都只有一位。（出现的除法的结果都按一位存储） 12345678910111213141516171819202122232425262728293031323334353637383940int jisuan(int a,char jisuan,int b)&#123; if('jisuan'='+') return a+b; if('jisuan'='-') return a-b; if('jisuan'='*') return a*b; if('jisuan'='/') &#123; if(b==0) &#123; cout&lt;&lt;\"error\"&lt;&lt;endl; return 0; &#125; else return a/b; &#125;&#125;int houzhui(char exp[])&#123; int i,a,b,c; char yunsuanfu; int stack[maxsize-1]; int top=-1; for(i=0;exp[i]!='\\0;++i) &#123; if(exp[i]&gt;='0'&amp;&amp;exp[i]&lt;='9') stack[++top]=exp[i]-'0'; else &#123; yunsuanfu=exp[i]; b=stack[top--]; a=stack[top--]; c=jisuan(a,yuansuanfu,b); stack[++top]=c; &#125; &#125; return stack[top]; //这句话有点不能理解&#125; 3.用不带头结点的单链表存储链栈，设置初始化栈，判断栈是否为空，进栈和出栈等相应的算法 123456789101112131415161718192021222324252627282930313233void initStack1(LNode *&amp;lst) //初始化栈&#123; lst=NULL;&#125;int isEmpty1(LNode *lst) //判断是否为空&#123; if (lst==NULL) return 1; else return 0;&#125;void pop1(LNode *lst,int x) //进栈&#123; LNode *p; p=(LNode *)malloc(sizeof(LNode)); p-&gt;next=NULL; p-&gt;data=x; p-&gt;next=lst; lst=p;&#125;void push1(LNode *lst,int x) //出栈&#123; LNode *p; if (lst==NULL) return 0; x=p-&gt;data; lst=p-&gt;next; free(p); return 1;&#125; 下面是例题：1.顺序栈s0和s1共享了一个存储区elem[0,1,..,maxsize-1]。是设计共享栈s0,s1以及有关共享栈的入栈和出栈操作的算法，假设元素为int型。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct //结构体定义&#123; int elem[maxsize]; int top[2]; &#125;sqstack;int push(sqstack &amp;st,int stNo,int x)&#123; if(st.top[0]+1&lt;st.top[1]) //判断是否栈满 &#123; if(stNo==0) &#123; ++(st.top[0]); st.elem[st.top[0]]=x; return 1; &#125; else if(stNo==1) &#123; --(st.top[1]); st.elem[st.top[1]]=x; return 1; &#125; return -1; //如果栈的编号既不是0也不是1的话就返回-1 &#125; else return 0;&#125;int pop(sqstack &amp;st ,int x)&#123; if(stNo==0) &#123; if(st.top[0]!=-1) &#123; x=st.elem[st.top[0]]; --(st.top[0]); return 1; &#125; else return 0; &#125; else if(stNo=1) &#123; if(st.top[1]!=maxsize) &#123; x=st.elem[st.top[1]]; ++(st.top[1]); return 1; &#125; return 0; &#125; else return -1;&#125; 2.利用两个站s1,s2来模拟一个队列，假设栈中的元素为int型，栈中元素最多为maxsize。已知栈的3个运算定义如下：push(ST,x):元素x入st栈pop(ST,&amp;x):st栈顶元素出栈，赋给元素xisEmpty(ST):判断st栈是否为空如何利用栈的运算来实现队列的3个运算，（元素入队列）enQueue,（元素出队列）deQueue,（判断栈是否为空）isQueueEmpty。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int enQueue(sqstack &amp;s1,sqstack &amp;s2,int x)&#123; int y; //这里为什么还要一个y if(s1.top==maxsize-1) &#123; if(!isEmpty(s2)) return 0; else if(isEmpty(s2)) &#123; while(!isEmpty(s1)) &#123; pop(s1,y); push(s2,y); &#125; push(s1,x); return 1; &#125; &#125; else &#123; push(s1,x); return 1; &#125;&#125;int deQueue(SqStack &amp;s2,sqstack &amp;s1,int &amp;x)&#123; int y; if(!isEmpty(s2)) &#123; pop(s2,y); return 1; &#125; else &#123; if(isEmpty(s1)) return 0; else &#123; while(!isEmpty(s1)) &#123; pop(s1,y); push(s1,y); &#125; pop(s2,x); return 1; &#125; &#125;&#125;int isQueueEmpty(sqstack s1,sqstack s2)&#123; if(isEmpty(s1)&amp;&amp;isEmpty(s2)) return 1; else return 0;&#125; 其实本题其实主要的工作是将栈的”先进后出”的特性变为”先进先出”。 3.假设一I,O分别表示入栈和出栈的操作，写出一个算法，判定给出的操作序列是否合法，若合法则返回1否则返回0假定被判定的操作序列已经存入一维数组ch[]中，操作序列以“\\0”为结束符。12345678910111213141516171819int judge(char[])&#123; int i=0; int I=0,O=0; while(ch[i]!='\\0') &#123; if(ch[i]='I') ++I; if(ch[i]='O') ++O; if(O&gt;I) return 0; ++i; &#125; if(I!=O) //判断入栈和出栈的操作次数是否相同，如果不同就不合法 return 0; else return 1;&#125; 4.假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针，请写出相应的入队和出队的算法。12345678910111213141516171819202122232425void enQueue(LNode *&amp;rear,int x)&#123; LNode *s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=x; s-&gt;next=rear-&gt;next; //有疑问。。。 rear-&gt;next=s; //有疑问。。。 rear=s;&#125; void deQueue(LNode *&amp;rear,int &amp;x)&#123; LNode *s; if(rear-&gt;next==rear) return 0; else &#123; s=rear-&gt;next-&gt;next; //s指向开始结点 rear-&gt;next-&gt;next=s-&gt;next; //rear指向s指针指向的下一个结点 x=s-&gt;data; if(s==rear) rear=rear-&gt;next; free(s); return 1; &#125;&#125; 5.如果允许在循环队列的两端都可以进行插入和删除操作，要求：写出循环队列的类型定义，写出从队尾删除和从对头插入的算法。123456789101112131415161718192021222324252627282930typedef struct&#123; int data[maxsize]; int front,rear;&#125;cycqueue;int deQueue(cycqueue &amp;Q,int &amp;x) //从队尾删除&#123; if(Q.front==Q.rear) return 0; else &#123; x=Q.data[Q.rear]; Q.rear=(Q.rear-1+maxsize)%maxsize; //这里要注意一下 return 1; &#125;&#125;int enQueue(cycqueue &amp;Q,int &amp;x) //从队头插入&#123; if(Q.rear==(Q.front-1+maxsize)%maxsize) return 0; else &#123; Q.data[Q.front]=x; //约定front指针是指向队头元素的前一个位置 Q.front=(Q.front-1+maxsize)%maxsize; //所以这里是先赋值后移动front指针 return 1; &#125;&#125; 6.设计一个循环队列，用front和rear分别作为队头和队尾指针，用一个标志tag表示队列是否为空当tag为1时队不空，为0时表示为空。这样就可以用front==rear来作为队满的条件。要求设计出队列的结构和相关的基本运算（队列元素为int型）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455typedef struct&#123; int data[maxsize]; int front,rear; int tag;&#125;Queue;void initQueue(Queue &amp;qu) //初始化&#123; qu.front=qu.rear=0; qu.tag=0;&#125;int isQueueEmpty(Queue qu) //判空&#123; if(qu.front==qu.rear&amp;&amp;qu.tag==0) return 1; else return 0;&#125;int QueueFull(Queue qu) //判满&#123; if(qu.tag==1&amp;&amp;qu.front==qu.rear) return 1; else return 0;&#125;int enQueue(Queue &amp;qu,int x)&#123; if(QueueFull(qu)==1) return 0; else &#123; qu.rear=(qu.rear+1)%maxsize; qu.data[qu.rear]=x; qu.tag=1; return 1; &#125;&#125;int deQueue(Queue &amp;qu,int &amp;x)&#123; if(isQueueEmpty(qu)==1) return 0; else &#123; qu.front=(qu.front+1)%maxsize; x=qu.data[qu.front]; qu.tag=0; return 1; &#125;&#125; 7.编写一个算法，将一个非负的十进制整数N转换为一个二进制数。123456789101112131415161718int BaseTrans(int N)&#123; int i,result=0; int stack[maxsize],top=-1; while(N!=0) &#123; i=N%2; i=N/2; stack[++top]=i; &#125; while(top!=1) &#123; i=stack[top]; --top; result=result*10+i; &#125; return result;&#125; 8.试编写一个算法，检查一个程序中的花括号，方括号，小括号是否匹配，若全部匹配则返回1，否则就返回0.对于程序中出现的单引号和双引号不进行括号匹配。39为单引号的ASCII值，34为双引号ASCII值，单双引号出现必定成双出现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int pipeikuohao(char f[])&#123; stack S,char ch; char* p=f; while(p!='\\0') &#123; if(*p==39) &#123; ++p; //跳过第一个单引号 while(*p!=39) ++p; //跳过单引号中的元素 ++p; //跳过第二个单引号 &#125; else if (*p==34) &#123; ++p; //跳过第一个双引号 while(*p!=34) ++p; //跳过双引号中的元素 ++p; //跳过第二个双引号，这里要注意程序的执行流程。 &#125; else &#123; switch(*p) &#123; case '&#123;': case '[': case '(': push(S,*p); //如果是&#123;，[,(这些左括号，就入栈 break; case '&#125;': getTop(S,ch); //当遇到右括号了，读取此时的栈顶元素(getTop)， if(ch=='&#123;') //如果此时栈顶元素是相应的左括号， pop(S,ch); //就出栈 else return 0; break; case ']': getTop(S,ch); if(ch==']') pop(S.ch); else return 0; break; case ')': getTop(S,ch); if(ch==')') pop(S,ch); else return 0; &#125; ++p; &#125; &#125; if(isEmpty(S)) return 1; else return 0;&#125; var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', //改为你自己的，下同 client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/04/10/data-structure-3/"},{"title":"data structure——线性表","text":"顺序表定义： 123456#define maxsize 100typedef struct&#123; int data[maxsize]; int length;&#125;sqList; 或者可以这样：12int A[maxsize];int n; 单链表结点定义：12345typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode; 双链表结点定义： 123456typedef struct DLNode&#123; int data; struct DLNode *prior; struct DLNode *next; &#125;DLNode; 下面说几个例题，以说明顺序表的操作： 1.已知一个顺序表L其中元素为递增有序排列，先插入一个元素x使其仍为递增有序排列： 123456789101112131415161718192021222324252627#define maxsize 100int L[maxsize];int n;int findElem(sqList L,int x)&#123; int i; for (i=0;i&lt;L.length;++i) &#123; if(x&lt;L.data[i]) &#123; return i; &#125; &#125; return i;&#125;void insertElem(sqList &amp;L,int x)&#123; int p,i; p=findElem(L,x); for(i=L.length-1;i&gt;=p;--i) L.data[i+1]=L.data[i]; L.data[p]=x; ++(L.length);&#125; 其中findElem函数是返回这个递增顺序表中第一个比他大的元素的地址，最后一句return i是在顺序表所有的元素都比他小的情况下，此时for循环不满足条件退了出来，而此时对应的元素的地址刚好是最后一个元素的位置。insertElem函数是将找到的位置后面的元素，将元素往右移动，这里L因为本身是要改变，所以用了引用型。函数里面的for循环是从最右边往左一个一个的右移。 2.删除顺序表L中下标为p的元素，成功返回1，不成功返回0并将被删除元素的值赋给e 1234567891011int deleteElem(sqlist &amp;L,int p,int &amp;e)&#123; int i; if(p&lt;0||p&gt;L.length-1) return 0; e=L.data[p]; for (i=p;i&lt;L.length;++i) L.data[i]=L.data[i+1]; --(L.length); return 1; &#125; 这里是删除一个下标为p的元素，只要直接将p下标之后的元素，从左往右一个一个的覆盖即可。 实例1和实例2，主要就讲了顺序表中最基本的操作：查找，插入，删除。 还有初始化顺序表和求指定位置元素的算法： 1234void initList(sqList &amp;L)&#123; L.length=o;&#125; 1234567int getElem(sqlist L,int p,int &amp;e)&#123; if(p&lt;0||p&gt;L.length-1) return 0; e=L.data[p]; return 1;&#125; 下面通过一个实例来说明一下单链表的操作： 例：A和B是两个带头结点的单链表，其中元素递增有序，设计一个算法，将A和B归并成一个按元素值非递减有序的链表C。 12345678910111213141516171819202122232425262728void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *r; C=A; C-&gt;next=NULL; free(B); r=C; while (p!=NULL&amp;&amp;q!=NULL) &#123; if (p-&gt;data&lt;=q-&gt;data) &#123; r-&gt;next=p;p=p-&gt;next; r=r-&gt;next; &#125; else &#123; r-&gt;next=q;q=q-&gt;next; r=r-&gt;next; &#125; &#125; r-&gt;next=NULL; if(p!=NULL) r-&gt;next=p; if(q!=NULL) r-&gt;next=q;&#125; 这个实例的主要方法是，首先先创建一个新的单链表C，C的头结点使用A链表的头结点，再用新的指针C指向他。B链表的指针的头结点就没什么用了就free B，接着使用一个if判断，将A，B中的元素的大小进行比较，将小的那个插入到C链表中（A,B单链表是递增有序的）。最后再用一个if判断，将如果一方有剩余的元素的单链表全部插入到C链表中，注意，剩余的插入C链表中，只需要将前面的一个指针链接到C链表后面即可，因为剩余的那个链表后面已经链接好了，不需要再用for循环一个一个的将其断开再链接上去。 这个实例中用了尾插法创建了一个链表，下面对创建链表的方法做一个总结：尾插法：12345678910111213141516void createlistR(LNode *&amp;C,int a[],int n)&#123; LNode *s,*r; int i; C=(LNode *)malloc(sizeof(LNode)); C-&gt;next=NULL; r=C; for (i=0;i&lt;n;++i) &#123; s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=a[i]; r-next=s; r=r-&gt;next; &#125; r-&gt;next=NULL;&#125; 头插法：1234567891011121314void createlistF(LNode *&amp;C,int a[],int n)&#123; LNode *s; int i; C=(LNode*)malloc(sizeof(LNode)); c-&gt;next=NULL; for(i=0;i&lt;n;++i) &#123; s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=a[i]; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125;&#125; 如上面的实例中如果需要输出的是一个递减的链表C，那么我们就可以使用头插法来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p=A-&gt;next; LNode *q=B-&gt;next; LNode *s; C=A; C-&gt;next=NULL; free(B); while (p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;=q-&gt;data) &#123; s=p; p=p-next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; else &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; c-&gt;next=s; &#125; &#125; while(p!=NULL) &#123; s=p; p=p-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; while(q!=NULL) &#123; s=q; q=q-&gt;next; s-&gt;next=C-&gt;next; C-&gt;next=s; &#125; &#125; 头插法的原理图可见：图片来源：https://www.jianshu.com/p/8613ea20dd19 请再看一下个实例：查找链表C中是否存在一个值为x的结点，如果存在则删除该结点并返回1，否则返回0。 1234567891011121314151617181920212223void findAndDelete(LNode *C,int x)&#123; LNode *p ,*q; p=C; while(p-&gt;next!=NULL) &#123; if(p-&gt;next-&gt;data==x) break; p=p-&gt;next; &#125; while(p-&gt;next=NULL) &#123; return 0; &#125; else &#123; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); return 1; &#125;&#125; 注意，这里的p指针，我们是要他停在要删除结点的前驱结点处，而不是直接指向要删除的结点。 双链表：使用尾插法建立:1234567891011121314151617void createDlistR(DLNode *&amp;L,int a[], int n)&#123; DLNode *s,*r; int i; L=(DLNode *)malloc(sizeof(DLNode)); L-&gt;prior=NULL; L-&gt;next=NULL; r=L; for(i=0;i&lt;n;++i) &#123; s=(DLNode *)malloc(sizeof(DLNode)); s-&gt;data=a[i]; r-&gt;next=s; s-&gt;prior=r; r=s; &#125; r-&gt;next=NULL; 查找结点：查找值为x的结点，找到就返回结点指针，否则返回NULL。1234567891011DLNode* findNode(DLNode *C,int x)&#123; DLNode *p=C-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==x) break; p=p-&gt;next; &#125; return p;&#125; 插入一个结点的操作：1234s-&gt;next=p-&gt;next;s-&gt;prior=p;p-&gt;next-&gt;prior=s;p-&gt;next=s; 删除p结点的后继结点：1234q=p-&gt;next;p-&gt;next=q-&gt;next;q-&gt;next-&gt;prior=p;free(q); 下面是例题：1.设顺序表用数组A[]表示，表中元素存储在数组下标0~m+n-1的范围内，前m个元素递增有序，后n个元素也递增有序，设计一个算法，使得整个顺序表都递增有序。1234567891011121314void insertElem(int A[], int m, int n)&#123; int i,j; int temp; for(i=m;i&lt;m+n;++i) &#123; temp=A[i]; for(j=i-1;j&gt;=0&amp;&amp;temp&lt;A[j];--j) &#123; A[j+1]=A[j]; &#125; A[j+1]=temp; //因为for循环多移了一位，所以要j+1 &#125;&#125; 2.已知递增有序的单链表A,B（个数分别为m,n，且都有头结点）分别存储了一个集合，请设计一份个算法将两个集合的差集(即在A中出现而不在B中)保存在A中，并保持元素递增有序。12345678910111213141516171819202122232425262728void diffence(LNode *A LNode *B)&#123; LNode *p=A-&gt;next; LNode *pre=A; LNode *q=B-&gt;next; LNode *r; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data&lt;q-&gt;data) &#123; pre=p; p=p-&gt;next; &#125; else if(p-&gt;data&gt;q-&gt;data) &#123; q=q-&gt;next; &#125; else &#123; pre-&gt;enxt=p-&gt;next; r=p; p=p-&gt;next; free(r); &#125; &#125;&#125; 3.设计一个算法，将顺序表中的元素逆置 123456789101112viod reverse(sqlist &amp;L)&#123; int i; int j; int temp; for(i=0,j=L.length-1;i&lt;j;++i,j--) //i&lt;j,不能大于也不能等于 &#123; temp=L.data[i]; L.data[i]=L.data[j]; L.data[j]=temp; &#125;&#125; 4.从一个给定顺序表L中删除下标i~j的所有元素。（假定i和j都合法） 12345678910void delete(sqlist *L,int i,int j)&#123; int k,delta; delta=j-i+1; for(k=j+1;k&lt;L.length-1,++k) &#123; L.data[delta]=L.data[k]; &#125; L.length=L.length-delta; &#125; 此题主要是用第j+1即往后的元素覆盖到i~j之间的元素，这里，如果j+1往后的元素没有I~j之间的元素个数多也不要紧，不要认为就没有”删除”完i~j之间的元素，因为L.length=L.length-delta就已经限定了表长，后面就算有元素也不是表内元素了。 5.一个顺序表L，元素为整型，设计一个算法将比L的表头元素小的元素放在其左边，将比他大的元素放在右边。 12345678910111213141516171819202122232425262728void move(sqlist &amp;L)&#123; int temp; int i=0; int j=L.length-1; temp=L.data[i] while(i&lt;j) &#123; while(i&lt;j&amp;&amp;L.data[j]&gt;temp) --j; if(i&lt;j) &#123; L.data[i]=L.data[j]; ++i; &#125; while(i&lt;j&amp;&amp;L.data[i]&lt;temp) ++i; if(i&lt;j) &#123; L.data[j]=L.data[j]; --j; &#125; &#125; L.data[i]=temp;&#125; 此题需要好好的理解一下，主要是要知道，i和j是轮流移动的，不是同时移动的，这样就能够保证，在交换的时候不会造成元素丢失，因为他们是轮流着来移动，所以在交换元素之前，这个元素肯定已经存入到了其他的位置了。 6.将一个递增非空单链表中的相同值域的元素删除。 123456789101112131415161718192021222324252627void deletesil(LNode *L)&#123; LNode *p=L-&gt;next; LNode *q=L-&gt;next-&gt;next; *r; while(q!=NULL) &#123; while(q!=NULL&amp;&amp;q-&gt;data=p-&gt;data) &#123; q=q-&gt;next; &#125; if (q!=NULL) &#123; p=p-&gt;next; p-&gt;data=q-&gt;data; &#125; q=p-&gt;next; p-&gt;next=NULL; while(q!=NULL) //这里有点不理解。。。。 &#123; r=q; q=q-&gt;next; free(r); &#125; &#125;&#125; 7.删除一个单链表L中的最小值结点。1234567891011121314151617181920void deletesmall(LNode &amp;L)&#123; LNode *p=L-&gt;next; LNode *ppre=L; LNode *qpre=L; LNode *q=L-&gt;next; while(q!=NULL) &#123; if(q-&gt;data&lt;p-&gt;data) &#123; p=q; ppre=qpre; &#125; qpre=q; q=q-&gt;next; &#125; ppre-&gt;next=p-&gt;next; free(p);&#125; 此代码中，之所以要对p再使用一个前驱指针ppre，以及对q也使用了一个前驱指针qpre的原因是通过这前驱指针分别“记住”原来p和q指针的位置在哪。p指针用来指定最小值的位置，q指针则用来向前进，使元素一个一个的与目前p指针所指定的最小值作比较。 8.有一个线性表，采用带头结点的单链表L来存储。设计一个算法将其逆置。要求不能建立新结点，只能通过表中已有的结点的重新组合来完成。 12345678910111213void reversel(LNode *L)&#123; LNode *p=L-&gt;next; LNode *q; L-&gt;next=NULL; while(p!=NULL) &#123; q=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=q; &#125;&#125; 9.设计一个算法，将一个带头结点为A的单链表分解为两个单链表A和B，A链表中含有原来链表中data域中为奇数的结点，B链表中含有原来链表中data域中为偶数的结点。且保持相对位置不变。 12345678910111213141516171819202122void seletejiandou(LNode *A,LNode *&amp;B)&#123; LNode *p,*q,*r; B=(LNode*)malloc(sizeof(LNode)); B-&gt;next=NULL; r=B; p=A; while(p-&gt;next!=NULL) &#123; if(p-&gt;next-&gt;data%2==0) &#123; q=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=NULL; r-&gt;next=q; r=q; &#125; else p=p-&gt;next; &#125;&#125; 10.写出一个函数，逆序打印单链表中的数据，假设指针L指针指向了单链表的开始结点。12345678void reprint(LNode *L)&#123; if(L!=NULL) &#123; reprint(L-&gt;next); //递归逆序打印开始结点的后面的数据 cout&lt;&lt;L-&gt;data&lt;&lt;\" \"; &#125;&#125; 11.编写一个函数，以不多于3n/2的平均比较次数，找出在一个n个整数的顺序表A中的最大值和最小值。 123456789101112void searchmaxandmin(int A[], int n,int &amp;max,&amp;min)&#123; max=min=A[1]; for(int i=2,i&lt;=n,++i) &#123; if(A[i]&gt;max) max=A[i]; else if(A[i]&lt;min) min=A[i]; &#125;&#125; 12.假设一个链表只有一个头指针head，设计一个算法，查找链表中倒数第k个位置上的结点，查找成功就返回data值，且返回1，若不成功就返回0。 1234567891011121314151617181920int findElem(LNode *head,int k)&#123; p1=head-&gt;next; p=head; i=1; while (p1!=NULL) &#123; p1=p1-&gt;next; ++i; if(i&gt;k) p=p-&gt;next; &#125; if (p==head) return 0; else &#123; count&lt;&lt;p-&gt;data; return 1; &#125;&#125; 13.设将n个整数存放在一维数组R中，设计一个尽可能高效的算法将R中保存的序列循环左移P个位置。 1234567891011121314151617181920212223void reverse(int R[],int l,int r)&#123; int i,j; int temp; for (i=l,j=r,i&lt;j,++i,--j) &#123; temp=R[i]; R[i]=R[j]; R[j]=temp; &#125; &#125;void RCR(int R[],int n,int p)&#123; if(p&lt;0||p&gt;n) cout&lt;&lt;\"Error\"&lt;&lt;endl; else &#123; reverse(R,0,p-1); //先将前p个逆置 reverse(R,p,n-1); //接着将剩下的逆置 reverse(R,0,n-1); //最后将所有的一起再逆置一下 &#125;&#125; 14.已知一个整数序列A(a0,a1,a2,..ai..,an-1)其中0&lt;=ai&lt;n(0&lt;=i&lt;n).如果其中有超过一半的元素的值相同，那么这个相同的值就称之为”主元素”。假设A中的n个元素保存在一个一维数组中，设计一个算法，找出A中的主元素，如果有则输出他，如果没有就输出为-1。 123456789101112131415161718192021222324252627282930313233int majority(int A[],int n)&#123; int i ,c, count=1; c=A[0]; for (i=1,i&lt;n,i++) if(A[i]==c) count++; else &#123; if(count&gt;0) count--; else &#123; c=A[i]; count=1; &#125; &#125; if(count&gt;0) &#123; for(i=count=0,i&lt;n,i++) &#123; if(A[i]==c) count++; &#125; &#125; if(count&gt;n/2) return c; else return -1; &#125;","link":"/2018/04/06/data-structure-2/"},{"title":"data structure——数组、矩阵与广义表","text":"数组： 1.两种逻辑结构 一维数组dataType a[n]; 二维数组dataType a[m][n];元素为一维数组的数组 2.行优先和列优先储存这里要区分数组在定义的时候例如：int a[2][3]中2和3就是又两行，有三列的意思，而在说数组中的某一个元素是例如a[2][1]这里的2和1编号，是不一样的，因为编号是从0开始编号的。 矩阵: 1.概念矩阵可以理解为二维数组。 2.操作 矩阵转置 1234567void trsmat(int A[][maxsize],int B[][maxsize],int m, int n) /*这里二维数组声明时省略了行的个数， 但是列数是不可以省略的*/&#123; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) b[j][i]=A[i][j];&#125; 矩阵相加 123456void addmat(int A[][maxsize],int B[][maxsize],C[][maxsize],int m ,int n)&#123; for (int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) C[i][j]=A[i][j]+B[i][j];&#125; 矩阵相乘假设A[][]和B[][]分别为m*n，n*k。 12345678910void mutmat(int C[][maxsize],int B[][maxsize],int A[][maxsize],int m ,int n ,int k)&#123; for (int i=0;i&lt;m;++i) for(int j=0;j&lt;k;++j) &#123; C[0][0]=0; for(h=0;h&lt;n;++h) C[i][j]+=A[i][h]*B[h][j]; &#125;&#125; 特殊矩阵和稀疏矩阵： 1.特殊矩阵 对称矩阵 三角阵只需要将那些相同的元素的值加在一维数组的后面一位就可以了。 对角矩阵同上 2.稀疏矩阵 稀疏矩阵有两种表示方法： 三元组表示法12345typedef struct&#123; int val; //值 int i,j; //行标和下标&#125;Trimat; 定义一个含有maxterm个元素的稀疏矩阵：Trimat trimat[maxterm];所以可以理解为，三元组表示法，是将稀疏矩阵以每个元素有三个分量的线性表形式将其进行存储。 当然，也可以这样存储：int trimat[maxterms+1][3];此时：tirmat[k][0]表示原矩阵中的元素按行优先顺序的第k个元素的值trimat[k][1]，tirmat[k][2]表示第k值在矩阵中的位置。所以可以看出这是一个有maxterms行3列的数组，每行的第一列是值，第二列和第三列为这个元素的位置。还有，我们默认的将第一行：trimat[0][0]，trimat[0][1]，trimat[0][2]存储为非零元素的个数，矩阵行数，矩阵个数。 例题：给定一个稀疏矩阵A（float型），其尺寸为m*n，建立其对应的三元组存储，并通过三元组打印输出矩阵A 12345678910111213141516171819202122232425262728293031323334void createtrimat(float A[][maxsize],int m ,int n, float B[][3]) //建立三元组&#123; int k=1; for(int i=0;i&lt;m;++i) for(int j=0;j&lt;n;++j) if(A[i][j]!=0) &#123; B[k][0]=A[i][j]; B[k][1]=i; B[k][2]=j; ++k; &#125; B[0][0]=k-1; B[0][1]=i; B[0][2]=j;&#125;void print(float[][3]) //通过三元组打印矩阵A&#123; void k=1; for(int i=0;i&lt;B[0][1];++i) &#123; for(int j=0;j&lt;B[0][2];++j) &#123; if(i==(int)B[k][1]&amp;&amp;j==(int)B[k][2]) &#123; cout&lt;&lt;B[k][0]&lt;&lt;\" \"; ++k; &#125; else cout&lt;&lt;\"0 \"; &#125; cout&lt;&lt;endl; &#125;&#125; 伪地址表示法 1.邻接表表示法 2.十字链表表示法 两种结点的结构定义：12345678910111213typedef struct OLNode //普通结点定义&#123; int row,col; struct OLNode *right ,*down; float val;&#125;OLNode;typedef struct //头结点定义&#123; OLNode *rhead,*chead; int m,n,k; //矩阵的行数，列数，非零结点个数&#125;Crosslist; 例题：给定一个稀疏矩阵A，其尺寸是m*n。非零元素个数是k，建立其对应的十字链表存储结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int creatcrossListmat(float A[][maxsize],int m,int n,int k,Crosslist &amp;M)&#123; if(M.rhead) free(M.rhead); if(M.chead) free(M.chead); M.m=m; M.n=n; M.k=k; /*申请头结点数组空间*/ if(!(M.rhead=(OLNode*)malloc(sizeof(OLNode)*m))) return 0; if(!M.chead=(OLNode*)malloc(sizeof(OLNode)*n)) return 0; /*头结点数组right和down指针置空*/ fot(int i=0;i&lt;m;++i) &#123; M.rhead[i].right=NULL; M.rhead[i].down=NULL; &#125; for(j=0;j&lt;n;++j) &#123; M.chead[j].right=NULL; M.chead[j].down=NULL; &#125; OLNode *temp_r[maxsize]; //建立列链表的辅助指针数组 for(int j=0;j&lt;n;++j) temp_r[j]=&amp;(M.chead[j]); for(int i=0;i&lt;m;++i) &#123; OLNode *c=&amp;(M.rhead[i]); for (int j=0;j&lt;n;++j) &#123; if(A[i][j]!=0) &#123; OLNode *p=(OLNode*)malloc(sizeof(OLNode)); p-&gt;row=i; p-&gt;col=j; p-&gt;val=A[i][j]; p-&gt;down=NULL; p-&gt;right=NULL; c-&gt;right=p; c=p; temp_r[j]-&gt;down=p; temp_r[j]=p; &#125; &#125; &#125; return 1;&#125; 广义表： 广义表头尾链表存储结构A( )B(e)C(a,(b,c,d))D((),B,C)E(a,E)F(())其中有两种结点：原子结点，广义表结点。原子结点有两个域：标记域和数据域广义表结点有三个域：标记域，头指针和尾指针。当广义表非空时，第一个元素为广义表的表头，其余元素为广义表的表尾，这也是这个存储结构的名字的由来。 广义表的扩展线性表存储结构其中也有两种结点：原子结点，广义表结点。不同的是：原子结点有三个域：标记域，头指针和尾指针。广义表结点有三个域：标记域，头指针和尾指针。 特点广义表头尾链表存储结构类似于不带头结点的单链表存储结构，而广义表的扩展线性表存储结构类似于带头结点的单链表存储结构。 下面是例题：1.设数组A[0,...,n-1]的n个元素中有多个零元素，设计一个算法，将A数组中的所有非零元素依次移动到A数组的前端。1234567891011121314151617void movelement(int A[],int n) &#123; int i =-1,temp; //i用来指最远离A[j]的为零的元素 for(j=0,j&lt;n;++j) &#123; if(A[j]!=0) &#123; ++i; if(i!=j) &#123; temp=A[i]; //用当前不是0的A[j]通过temp， A[i]=A[j]; //与最远离他的0元素进行交换 A[j]=temp; &#125; &#125; &#125;&#125; 2.关于浮点型数组A[0,...,n-1]，试设计一个实现下列运算的算法。（1）求数组A中的最大值。（2）求数组中n个数之和。（3）求数组中n个数的平均值。123456789101112131415161718192021222324252627282930float findmax(float A[],int i ,int j) //求最大值，递归&#123; float max; if(i=j) return A[i]; else &#123; max=findmax(A[],i+1,j); if(A[i]=max) return A[i]; else return max； &#125;&#125;float arraysum(float A[],int i ,int j) //求和&#123; if(i=j) return A[i]; else return A[i]+arraysum(A[],i+1,j);&#125;float arrayavg(float A[],int i,int j) //求平均数&#123; if (i==j) return A[i]; else return(A[i]+(j-i)*arrayavg(A,i+1,j))/(j-i+1);&#125; 3.设计一个算法，将数组A[0,...,n-1]中所有奇数移到偶数之前。要求不增加存储空间，且时间复杂度为O(n)。1234567891011121314151617181920void divide(int A[],int n)&#123; int i=0,j=n-1,temp; while(i&lt;j) &#123; while(A[i]%2==1&amp;&amp;i&lt;j) //将i停在偶数上 ++i; while(A[i]%2==0&amp;&amp;i&lt;j) //将j停在奇数上 --j; if(i&lt;j) &#123; temp=A[i]; A[i]=A[j]; A[j]=temp; ++i; --j; &#125; &#125;&#125; 4.设有一元素为整数的线性表L，存放在一维数组A[0,...,n-1]中，设计一个算法，以A[n-1]为参考量，将该数组分为左右两个部分，其中左半部分的元素均小于等于A[n-1]，右半部分的元素值均大于A[n-1]，A[n-1]则位于这两个部分之间。要求结果仍存放在数组A中。12345678910111213141516171819202122232425262728void divide(int A[],int n)&#123; int temp; int i=0; int j=n-1; temp=A[i]; A[i]=A[j]; A[j]=temp; temp=A[i]; while(i!=j) &#123; while (j&gt;i&amp;&amp;A[j]&gt;temp) --j; //找到右边第一个小于temp的数 if(i&lt;j) &#123; A[i]=A[j]; ++i; &#125; while(i&lt;j&amp;&amp;A[i]&lt;temp) ++i; //找到左边第一个大于temp的数 if(i&lt;j) &#123; A[j]=A[i]; --j; &#125; A[i]=temp； &#125;&#125; 5.设计一个算法，对给定的一个整形m*n矩阵A,统计这个矩阵中具有下列特特征的元素并输出他们的坐标及数值：他们既是所在行中的最小值，又是所在列中的最小值：或者他们既是所在行中的最大值，又是所在列中的最大值。假设矩阵中元素各不相同，要求结果在处理过程中用输出语句输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void printmin(int A[][maxsize],int m,int n) //求最小，m是行号，n是列号&#123; int i,j,k,min,minj; //minj是记录第i行上最小值的列号 int flag; for(i=0;i&lt;m;++i) &#123; min=A[i][0]; minj=0; for(j=1;j&lt;n;++j) if (A[i][j]&lt;min) //找出第i行上的最小值，列号为minj &#123; min=A[i][j]; minj=j; &#125; flag=1; for(k=0;k&lt;m;++k) &#123; if(min&gt;A[k][minj]) &#123; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;min&lt;&lt;\",[\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;j&lt;&lt;\",]\"&lt;&lt;\" \"; &#125; cou &lt;&lt;endl;&#125;void printmax(int A[][maxsize],int m,int n) //最大&#123; int i,j,k,max,maxj; int flag=0; for(i=0;i&lt;m;++i) &#123; max=A[i][0]; maxj=0; for(j=1;j&lt;n;++j) &#123; if(A[i][j]&gt;max) &#123; max=A[i][j]; maxj=j; &#125; flag=1; for(k=0;k&lt;m;++k) &#123; if(max&lt;A[i][maxj]) &#123; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;max&lt;&lt;\",[\"&lt;&lt;i&lt;&lt;\",\"&lt;&lt;maxj&lt;&lt;\",]\"&lt;&lt;\" \"; &#125; &#125; cout&lt;&lt;endl;&#125; 此题是一行一行的循环，首先是由第5行的循环，然后再通过第10行的循环，找出这一行中的最小值，然后，再在第16行的循环比较，这一行的这个最小值是不是又是他所在列的最小值，如果不是就将flag值为0，并退出，如果是，就以min,[i,minj]的格式将其输出。求最大的值的思路一样。 6.给定稀疏矩阵A（int型），创建其三元组存储结构B;查找给定元素x是否在矩阵中。1234567891011121314151617181920212223242526272829void create(int A[][maxsize],int m,int n,int B[][3])&#123; int i,j,k=1; for(i=0;i&lt;m;++i) for(j=0;j&lt;n;++i) if(A[i][j]!=0) &#123; B[k][0]=A[i][j]; B[k][1]=i; B[k][2]=j; ++k; &#125; B[0][0]=k-1; B[0][1]=m; B[0][2]=n;&#125;int search(int B[][3],int x) //查找元素&#123; int i,t; t=B[0][0]; i=1; while(i&lt;=t&amp;&amp;B[i][0]!=x) i++; if(i&lt;=t) //这里有疑问 return 1; else return 0;&#125; 7.假设稀疏矩阵A采用三元组表示，编写一个函数，计算其转置矩阵B,要求B也采用三元组表示。1234567891011121314151617181920void transpose(int A[][3],int B[][3])&#123; int p,q,col; B[0][0]=A[0][0]; B[0][1]=A[0][2]; B[0][2]=A[0][1]; if(B[0][0]&gt;0) &#123; q=1; for(col=0;col&lt;B[0][1];++col) for(p=1;p&lt;=B[0][0];++p) if(A[p][2]==col) &#123; B[q][0]=A[p][0]; B[q][1]=A[p][2]; B[q][2]=A[p][1]; ++q; &#125; &#125;&#125; 8.假设稀疏矩阵A和B（两矩阵行列数对应相等）都采用三元组表示，编写一个函数，计算C=A+B，要求C也采用三元组表示，所有矩阵均为int型。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void add(int A[][3],int B[][3],int C[][3]) &#123; int i=1,j=1,k=1,m; while(i&lt;=A[0][0]&amp;&amp;j&lt;=B[0][0]) if(A[i][1]==B[i][1]) //如果a中的元素的行号等于b的元素的行号，说明，这两个元素在原来的稀疏矩阵中的同一行， &#123; if (A[i][2]&lt;B[i][2]) /*接着再比较这个元素的列号，若果a的列号小于b,那么就说明， a这个非零元素在稀疏矩阵中的位置， 对应于b的这个相同行号的元素在其稀疏矩阵中的位置的那个元素是0*/ &#123; C[k][0]=A[i][0]; /*所以，a的元素加上0，就相当于将a当前的元素直接赋值给三元组c，下面的思路是一个意思*/ C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; else if (A[i][2]&gt;B[1][2]) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++j; &#125; else (A[i][2]==B[j][2]) &#123; m=A[i][0]+B[j][0]; if(m!=0) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; &#125; ++j; ++i; &#125; &#125; else if(A[i][1]&lt;B[j][1]) //如果a三元组的这个元素的行号小于b三元组的行号时 &#123; C[k][0]=A[i][0]; C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; else(A[i][1]&gt;B[j][1]) &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++i; &#125; while(i&lt;=A[0][0]) //如果a三元组中有多余的元素，将多余的元素直接赋值给c &#123; C[k][0]=A[i][0]; C[k][1]=A[i][1]; C[k][2]=A[i][2]; ++k; ++i; &#125; while (i&lt;B[0][0]) //如果b三元组有多余 &#123; C[k][0]=B[j][0]; C[k][1]=B[j][1]; C[k][2]=B[j][2]; ++k; ++j; &#125; C[0][0]=k-1; C[0][1]=A[0][1]; C[0][2]=A[0][2]; &#125; 由稀疏矩阵而来的三元组中，其实已经存储的是稀疏矩阵中非零的元素了，切记。 9.假设稀疏矩阵A,B（分别为m*n,n*k矩阵）采用三元组表示，编写一个函数计算C=A*B，要求C也是采用三元组表示的稀疏矩阵。12345678910111213141516171819202122232425262728293031int getvalue(int D[][maxsize],int i,int j) //返回三元组中的元素对应于他在稀疏矩阵中的值&#123; int k=1; while(k&lt;=D[0][0] &amp;&amp; (D[k][1]!=i||D[k][2]!=j)) //不相同的是0元素 k++; //所以就跳过 if (k&lt;=D[0][0]) return D[k][0]; else return 0;&#125;void mul(int A[][3],int B[][3],int C[][3],int m,int n,int k)&#123; int i,j,l,p=1,s; for(i=0;i&lt;m;++i) for(j=0;j&lt;n;++j) &#123; s=0; for(l=0;l&lt;n;++l) //主要是这个l要注意一下 s+=getvalue(A,i,l)*getvalue(B,l,j); if(s!=0) &#123; C[p][1]=i; C[p][2]=j; C[p][0]=s; ++p; &#125; &#125; C[0][1]=m; C[0][2]=n; C[0][0]=p-1;&#125; -..—.–..-.-./-.–..-..-.-..-/-.-.–.—…../-..—…—.-./–…-….-…-/-…-.——.-../-..—.-….–./-..—………/-.-..—–..-.-/-..-.-.-…–..-/-…-.—-.—.-/——–….–../-…-.—.-.-..-/-..—-.–…../–..—….-..-/—….-.—..-/-.—……—-/-..—…..–.-/-..–.-.–.–…/-.-…-.—.-../-..—.-….–./——–….–../-…——.–…/-..—………/-..—…-.-.-./-.-..-.-.–..-./—.–.-….-../-..—…..–.-/—.-…….–./–…-….-…-/——–….–../-….–..—–.-/—…-..–.–./–…-….-…-/—.——..-.-/-..-…..-.-..–/-.-..—–.-.-./–..–…-.—-/-..—-.–…../-.-.-..-…–../–…-….-…-/—.-.-…—–/—.–.-….-../-.—……—-/-..—…..–.-/-.—–……../-.——-….–/——–….–../-.-..—–.—-/–..–…-.—-/–..-.—–.–./-..-.-.—–.-../-..—………/-..-.-.-.——-/–…-….-…-/-…——.–…/–..–…-.—-/–..—….-..-/-..—………/—….-.—..-/-.—……—-/-.–..-..–…-/-….-….—-.-/-.-.-…–…-./–……….-./—..—.–…./-.-.—..-.-…/-..—-.–…../-.-.—..-.-…/-.-.–.——-./-..—..–..–./-..–..–….–./-..-…—..–../——–….–../-.-.—..-.-…/–…-….-…-/—.–.-….-../-.–.——-..-/-..-.—.–…-./—.—.–….-/—.—.-……/-..—.-….–./——–….–../–…-….-…-/–…-..-.-..–/-.—–……../-..-.——-..–/-..—..-.-…./——–….–../-.-..—-..-…/——.–.–..-/–…-….-…-/–…—.-.-…/-..-………..-/-..—.-….–./-..—………/-..—…-.-.-./-..—………/-..–..–..-.–./-.-..–.–….-/-.-…–..—../——–….–../-.——.-.—./-..–…–..—./-…—-.—-.–/–…-.–….-./—.—.-……/-..—-.–…../——–….–../–…-….-…-/—.—….-.–/—.—.-……/-..—-.–…../——–….–../-….–..—–.-/—…-..–.–./–.–..-.-….-/–..—….-..-/-.–..-..-.-.-./-..-.–…–..–/——–….–../-.-..–.—.-../-…——.–…/–..–…-.—-/-…-..—..-..-/—.–.-….-../-.-.-..-…–../-..—-.–…../-.-.—..-.-…/-..—………/-…–.-.—.—/—.—…—–/-.–..-.—–.-/–……….-.","link":"/2018/04/14/data-structure-5/"},{"title":"data structure——图","text":"图的存储结构： 图的顺序存储结构：邻接矩阵的结构型有两个数组：一个一维数组存储图中的顶点信息；一个二维数组存储图中的边或弧的信息。缺点：如果边数相对于顶点数较少，那么边数组的存储空间是一个很大的浪费。123456789101112typedef struct&#123; int no; //顶点编号 char info; //顶点的其他信息，视情况而定写不写&#125;VertexType;typedef struct //图的定义&#123; int edges[maxSize][maxSize]; //邻接矩阵定义，可看做边表 int n,e; //顶点数和边数 VertexType vex[maxSize]; //顶点表，存放结点信息&#125;MGraph; //图的邻接矩阵类型 邻接矩阵事例： 图的链式存储结构：邻接表数组与链表相结合；图中顶点用一维数组来存储（也可用单链表）；图中的每个顶点的邻接点用单链表来存储。 12345678910111213141516171819typedef struct ArcNode //边表&#123; int adjvex; //该边所指向的结点的位置，就是顶点标号 struct ArcNode *nextarc; //指向这个顶点结点的另一条边的指针 int info; //该边的相关信息&#125;ArcNode;typedef struct //顶点表&#123; char data; //顶点信息 ArcNode *firstarc; //指向第一条边的指针&#125;VNode;typedef struct &#123; VNode adjlist[maxSize]; //邻接表 int n,e; //顶点数和边数&#125;AGraph; //图的邻接表类型 邻接表事例：ArcNode是“边”（边结点）的结构体，是用点与点之间的关系来表示边的。其中的adjvex（Adjacent vertices邻接顶点的缩写）这条边所指的顶点，是顶点在数组中的下标，*next是指向下一个边结点的指针。VNode是“顶点”的结构体，AGraph是“图”的结构体，其中定义了一个VNode型的数组来储存顶点，n,e是结点数和边数。邻接表中，如果是有向图的话，邻接表是存储的是这个结点引出的边，也即“出度”，而如果存储的是指向这个结点的边，也即“入度”的话，这个存储结构就是“逆邻接表”。 有向图的十字链表存储结构 如果我们想即存储出度又存储入度呢？我们可以这样：其中的firstIn是指向入边链表中第一个结点的指针，firstOut指向第一个出边链表的指针。start是指当前边起点的数据域，end是当前边终点的数据域，nextIn指向这个顶点的下一个入边，nextOut指向这个结点的下一个出边。 这就是有向图的十字链表存储结构。 无向图的邻接多重表 我们在看到用邻接表存储无向图的时候，会出现重复存储的情况，那么我可以这样：左上方是顶点的结构体设计，右上方是边结点的结构体设计。其中的Vi是边的起点，Vj是边的终点。ViNext是表示与Vi相关的下一个边结点，VjNext是表示与Vj相关的下一个边结点。 遍历这里dfs和bfs的代码所对应的都是图的邻接表的存储方式的遍历。 深度优先遍历（DFS） 很类似于树的先序遍历算法，这里用了一个visit[]数组，设置为一个标记，如果这个结点已经访问过了就设置为1，如果没有访问过默认为0。注意：Visit函数和visit[]数组不是同一个东西，第10句中的下一个结点指的是在邻接表中当前结点的下一个结点。123456789101112void DFS(int c,AGraph *G)&#123; visit[v]=1; Visit(v); //Visit函数代表了对顶点v的访问 ArcNode* q=G-&gt;adjList[v].first; //这里是p指向顶点的第一条边 while(q!=NULL) &#123; if(visit[q-&gt;adjV]==0) //如果这个顶点没有被访问过，那么就访问他 DFS(q-&gt;adjV,G); //递归处理 q=q-&gt;next; //指向当前顶点的下一个结点 &#125;&#125; 广度优先遍历（BFS）类似于树的层次遍历，遍历过程会用到一个列表。主要过程是：取一个顶点进行访问，入队，并将这个点标记为已访问；接着，访问这个结点的下一个结点，没有访问过就访问，标记为1，入队，如此循环将邻接点都入队，p为空时就出队，然后循环对这个出队顶点的所有没有被访问过的邻接顶点进行访问，标记，入队，依次循环最后，直至出队使得队列为空，结束循环。 123456789101112131415161718192021222324252627void BFS(AGraph *G,int v,int visit[maxsize])&#123; ArcNode *p; int que[maxSize],front=0,rear=0; //创建一个队列que int j; Visit(v); //访问任意一个v结点 visit[v]=1; //标记为已访问 rear=(rear+1)%maxSize; //当前结点入队 que[rear]=v; //入队，（是将数组下标写进队列中） while(front!=rear) //如果队列不为空，就循环 &#123; front=(front+1)%maxSize; //出队 j=que[front]; p=G-&gt;adjlist[j].first; //p指向这个出队顶点j的第一条边 while(p!=NULL) //当p不空的时候, &#123; if(visit[p-&gt;adjV]==0) //如果p的邻接点没有被访问过， &#123; Visit(p-&gt;adjV); //就访问他, visit[p-&gt;adjV]=1; //接着标记为已访问， rear=(rear+1)%maxSize; //该顶点也入队 que[rear]=p-&gt;adjV; //入队 &#125; p=p-&gt;next; //访问下一条边 &#125; &#125;&#125; 最小生成树 由一个图按照某种规则导出的一个树，叫生成树。最小生成树：构成这个生成树的所有分支的权值和最小。 prime算法求最小生成树的代码：1234567891011121314151617181920212223242526272829void Prim(int n ,float MGraph[][n],int v0,float &amp;sum)//顶点个数，带权图，构造生成树的起始顶点，&#123; //存储最小权值和（代价） int lowCost[n],vSet[n]; int v,k,min; for(int i=0;i&lt;n;++i) &#123; lowCost[i]=MGraph[v0][i]; //lowCost[]指向vo初始点的同一行的不同列的顶点 vSet[i]=0; &#125; v=v0; //v指向第一个结点， vSet[v]=1; //已经并入，所以标记设置为1 sum=0; //初始化 for(int i=0;i&lt;n-1;++i) &#123; min=INF; //min初始化为无穷大 for(int j=0;j&lt;n,++j) if(vSet[j]==0&amp;&amp;lowCost[j]&lt;min) &#123; min=lowCost[j]; k=j; &#125; vSet[k]=1; v=k; //v指向如今刚进入的结点 sum+=min; //min的值累加到sum for(int j=0;j&lt;n;++j) //更新lowCost数组 if(vSet[j]==0&amp;&amp;MGraph[v][j]&lt;lowCost[j]) lowCost[j]=MGraph[v][j]; &#125;&#125; lowCost[]数组是用来存储当前生成树到图中其余顶点的边的最小权值。vSet[i]为1时就说明已经被并入生成树中，为0就没有并入。v指向刚并入的顶点。 v0是最小生成树的初始结点，所以v=v0 kruskal算法 把当前未被并入的，且并入后不会产生环的最小边进行并入。如何检测并入后到底会不会产生环呢？就用到了“并查集”。所谓的并查集，就是通过这些图中的点构造出来的树，每一个结点在相连的时候，要一直查到到根结点，如果根结点不相同，说明图中选取边之后不会产生环，所以可以选择这个这个结点的边。 相关的存储结构：","link":"/2018/04/30/data-structure-7/"},{"title":"data structure——树与二叉树","text":"看一下知识点： 树的存储结构 二叉树的存储结构 二叉树的性质 树与二叉树的转换 森林与二叉树的转换 二叉树的遍历算法 非递归的二叉树的遍历算法 树的遍历算法 森林的遍历算法 线索二叉树，结构，遍历算法 赫夫曼树和编码 二叉树的确定 二叉树的估计 二叉树表达式 树的存储结构 顺序存储结构即定义一个数组来存储，如：int tree[maxsize];。用数组下标来表示树中的结点，数组元素中的内容表示该结点的双亲结点。所以又称为双亲存储结构。 链式存储结构主要有孩子存储结构和孩子兄弟存储结构两种。 二叉树的定义满足条件：1，每个结点最多只有两棵子树2,子树有左右顺序之分。 二叉树的存储结构 顺序存储结构（适用于完全二叉树）图中右边的规则只是适合完全二叉树，（如果用来储存一般的二叉树会浪费大量的存储空间）且是从0开始编号的。 链式存储结构（又名二叉链表存储结构）123456typedef struct BTNode&#123; char data; struct BTNode *lchild; struct BTNode *rchild;&#125;BTNode; 如下图： 树的孩子兄弟存储结构可以用于树等结构，可以将树变为二叉树，然后再用链式存储，其实也是链式存储，和上面那个是一样的意思。 满二叉树在一棵二叉树中，所有所有的分支结点都有左右孩子，并且所有的叶子结点都集中在二叉树的最后一层。 完全二叉树求完全二叉树的高度(h)（完全二叉树与结点个数有关系）看规律：高为1 共有 2^1-1 个结点高为2 共有 2^2-1 个结点高为3 共有 2^3-1 个结点… … 高为h 共有 2^h-1 个结点 所以也可以知道高度为h的完全二叉树的结点的个数n在这个范围内2^(h-1)-1&lt; n &lt;=2^h-12^(h-1)&lt;= n &lt;2^h 处理方法2：2^(h-1)+1&lt;= n+1 &lt;2^h+1h-1&lt;=log2n &lt;h (比h-1只大了一个不大于1的小数，所以可以取整)h-1=下取整log2n &lt;h所以h=下取整log2n+1 如果使用处理方法2：那么，可以接着化简：h-1 &lt; log2(n+1) &lt;= h (比h小了一个不大于1的小数)上取整：h=上取整log2(n+1) 二叉树的性质1，总分支数=总结点数-1（所有树结构都满足这个性质） 1 2，叶子结点数n0,单分支结点数n1，双分支结点数n2。则总结点数=n0+n1+n2 2总分支数=n1+2n2 （因为叶子结点无分支，单分支结点1个分支，双分支结点2个分支） 3 3，由1和2和3联立方程组，解得：n0=n2+1即得：叶子节点数=双分支结点数+1。 4，空分支数=总结点数+1 树与二叉树的相互转化把每一个结点的兄弟结点相互连接起来，然后删除父结点与孩子结点的连线，只保留一条，默认的是保留最左边（视觉上的最左的那个）的一个连线。二叉树转换为树的话，过程相反即可。 森林与二叉树的相互转换 首先按照将树转换成二叉树的方法，将森林中的每棵树转换为二叉树，然后，将每一个二叉树的根结点的右边的分支连接起来即可。 二叉树的遍历算法二叉树的深度优先遍历的算法用到递归这个概念，所以先看一下递归函数，递归有直接递归和间接递归，这里只讲直接递归1234void r()&#123; r();&#125; 简单一点讲，递归就是这个函数自己调用自己。在自己中调用自己的时候系统会做一个保护现场的操作，在调用玩自己后，系统又会做一个恢复现场的操作，这样就可以实现原路返回了，且，第一个调用自己的时候，在返回时是最后一个恢复现场的，这里明显有一个先进后出的感觉，这就是使用了“系统栈”，非递归就是使用自己定义的一个栈来进行遍历。 1.深度优先遍历 先序遍历 123456789void preorder(BTNode *p)&#123; if(p!=NULL) &#123; Visit(p); preorder(p-&gt;lchild); preorder(p-&gt;rchild); &#125;&#125; 中序遍历 123456789void inorder(BTNode *p)&#123; if(p!=NULL) &#123; inorder(p-&gt;lchid); Visit(p); inorder(p-&gt;rchild); &#125;&#125; 后序遍历 123456789void postorder(BTNode *p)&#123; if(!p=NULL) &#123; postorder(p-&gt;lchid); postorder(p-&gt;rchild); Visit(p); &#125;&#125; 例题：写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。123456789101112int getDepth(BTNode *p)&#123; int LD,RD; if(p=NULL) return 0; else &#123; LD=getDepth(p-&gt;lchid); RD=getDepth(p-&gt;rchild); return (LD&gt;RD?LD:RD)+1; &#125;&#125; 采用后序遍历方式，先算出左子树的深度LD再算出右子树的深度RD,最后max{LD,RD}+1，加一是因为还有一个根节点。其中LD&gt;RD?LD:RD是一个三目运算符，LD如果大于RD就返回LD,如果不大于就返回RD。 例题：在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点是否存在（找到任何一个满足要求的结点即可），如果存在，则将q指向该结点，否则q赋值为NULL，假设data为int型。12345678910111213int search(BTNode *p,BTNode *&amp;q,int key)&#123; if(p!=NULL) &#123; if(p-&gt;data==key) q=p; else &#123; search(p-&gt;lchild,q,key); search(p-&gt;rchild,q,key); &#125; &#125;&#125; 此算法可以进行修改，因为只需要找到一个满足条件的结点就好，所以当在左子树中找到这个结点了之后就可以直接退出了，如果没有找到，才需要再在右子树中去寻找，这就是所谓的“剪枝操作”，所以代码修改如下：123456789101112131415int search(BTNode *p,BTNode *&amp;q,int key)&#123; if(p!=NULL) &#123; if(p-&gt;data==key) q=p; else &#123; search(p-&gt;lchild,q,key); if(q==NULL) search(p-&gt;rchild,q,key); &#125; &#125;&#125; 例题：假设二叉树采用二叉链表存储结构存储，编写一个程序，输出先序遍历序列中第k个结点的值，假设k不大于总的结点数（结点data域类型为char型）。1234567891011121314151617int n=0;void trave(BTNode *p,int k)&#123; if(p!=NULL) &#123; ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; trave(p-&gt;lchild,k); trave(p-&gt;rchild,k); &#125;&#125; 若是中序或者后序遍历的话，代码如下：123456789101112131415161718192021222324252627282930void(BTNode *p,int k) //中序&#123; if(p!=NULL) &#123; trave(p-&gt;lchild,k); ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; trave(p-&gt;rchild,k); &#125;&#125;void trave(BTNode *p,int k) //后序&#123; if(p!=NULL) &#123; trave(p-&gt;lchild,k); trave(p-&gt;rchild,k); ++n; if(k==n) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return; &#125; &#125;&#125; 2.广度优先遍历 层次遍历层次遍历的主要过程是：从根节点开始，根结点先入队，然后根结点出队，访问他，看他是否存在左右孩子，如果存在就入队，先入左孩子，再入右孩子。然后就是重复以上过程：出队结点，访问，看是否存在左右孩子，存在就入队，直到队空为止。 1234567891011121314151617181920212223242526272829void level(BTNode *p)&#123; int front,rear; BTNode *que[maxsize]； //定义一个循环列表，来记录要访问的一个层次上的结点 front=rear=0; BTNode *q; //遍历指针 if(p!=NULL) &#123; rear=(rear+1)%maxsize； //入队 que[rear]=p; //根节点入队 while(front!=rear) //队列不空的时候循环 &#123; front=(front+1)%maxsize; //出队 q=que[front]; //队头结点出队 Visit(q); //访问队头结点 if(q-&gt;lchild!=NULL) //如果左子树不空, &#123; rear=(rear+1)%maxsize; que[rear]=q-&gt;lchild; //则左子树的根结点就入队 &#125; if(q-&gt;rchild!=NULL) //右子树如果不空， &#123; rear=(rear+1)%maxsize; que[rear]=q-&gt;rchild; //则右子树的根结点就入队 &#125; &#125; &#125;&#125; 例题：假设二叉树采用二叉链表储存结构储存，设计一个算法，求出该二叉树的宽度（具有结点数最多的那一层上的结点个数）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef struct&#123; BTNode *p; //结点指针 int lno; //结点的层次号&#125;St;int maxNode(BTNode *b)&#123; St que[maxsize]; int front,rear; int Lno,i,j,n,max; front=rear=0; BTNode *q; if(b!=NULL) &#123; ++rear; que[rear].p=b; que[rear].lno=1; while(front!=rear) &#123; ++front; q=que[front].p; Lno=que[front].lno; if(q-&gt;lchild!=NULL) &#123; que[rear].p=q-&gt;lchild; que[rear].lno=Lno+1; &#125; if(q-&gt;rchild!=NULL) &#123; ++rear; que[rear].p=q-&gt;rchild; que[rear].lno=Lno+1; &#125; &#125; max=0; //循环比较Lno，找出最大值，即为最大层数 for(i=1;i&lt;=Lno;++i) &#123; n=0; for(j=1;j&lt;=rear;++j) if(que[j].lno==i) ++n; if(max&lt;n) max=n; &#125; return max; &#125; else return 0;&#125; 树的遍历算法：树只有先序遍历和后序遍历算法，没有中序遍历算法。如果将一棵树转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对树进行先序遍历；对这个二叉树树进行中序遍历就相当于对这个树进行后序遍历。 树的先序遍历 1234567891011121314void preOrder(TNode* p,TNode tree[])&#123; if(p!=NULL) &#123; visit(p); Branch* q; q=p-&gt;first; while(q!=NULL) &#123; preOrder(&amp;tree[q-&gt;cIdx],tree); q=q-&gt;next; &#125; &#125;&#125; 树的后序遍历 123456789101112131415void preOrder(TNode* p,TNode tree[])&#123; if(p!=NULL) &#123; Branch* q; q=p-&gt;first; while(q!=NULL) &#123; preOrder(&amp;tree[q-&gt;cIdx],tree); q=q-&gt;next; &#125; visit(p); &#125;&#125; 树的层次遍历 12345678910111213141516171819202122232425void level(TNode *tn,TNode tree[])&#123; int front,rear; TNode *que[maxSize]; front=rear=0; TNode *p; if(tn!=NULL) &#123; rear=(rear+1)%maxSize; que[rear]=tn; while(front!=rear) &#123; front=(front+1)%maxSize; p=que[front]; visit(p); Branch* q=p-&gt;first; while(q!=NULL) &#123; rear=(rear+1)%maxSize; que[rear]=&amp;tree[q-&gt;cIdx]; q=q-&gt;next; &#125; &#125; &#125;&#125; 森林的遍历算法：森林也只有先序遍历和后序遍历。如果将一森林转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对森林进行先序遍历；对这个二叉树进行中序遍历就相当于对这个森林进行后序遍历。 二叉树的遍历算法的改进： 先序遍历的非递归算法 12345678910111213141516171819void preorderNonrecursion(BTNode *bt) //传入一个二叉树结点类型的指针&#123; if(bt!=NULL) &#123; BTNode *Stack[maxsize]; //建立了一个辅助栈 int top=-1; BTNode *p; //遍历指针 Stack[++top]=bt; while(top!=-1) &#123; p=Stack[top--]; //先出栈 Visit(p); if(p-&gt;rchild!=NULL) //如果右孩子存在就入栈 Stack[++p]=p-&gt;rchild; if(p-&gt;lchild!=NULL) //如果左孩子存在就入栈 Stack[++top]=p-&gt;lchild; &#125; &#125;&#125; 中序遍历的非递归算法 中序遍历的规则是：根结点入栈，栈顶结点的左孩子存在就入栈， 一直向左走，一直走到不能向左走了，即栈顶结点的左孩子不存在，则出栈并输出栈顶结点。然后向右走一步，如果栈顶结点的右孩子存在就入栈，再从这个右孩子向左一直走，走到不能向左走为止。不能走了就出栈，看其右孩子是否有，有的话就向右走一步，。。。就这样一直重复。123456789101112131415161718192021222324void inorderNoncursion(BTNode *bt)&#123; if(bt!=NULL) &#123; BTNode *Stack[maxsize]; int top=-1; BTNode *p=NULL; p=bt; //p指向根结点 while(top!=-1||p!=NULL) &#123; while(p!=NULL) &#123; Stack[++top]=p; p=p-&gt;lchild; &#125; if(top!=-1) &#123; p=Stack[top--]; Visit(p); p=p-&gt;rchild; &#125; &#125; &#125;&#125; 后序遍历的非递归算法后序遍历可以使用先序遍历得到：先对先序遍历序列进行左右子树的遍历顺序交换，得到逆后序遍历序列；再使用一个栈，将逆后序遍历序列的顺序逆过来输出得到后序遍历序列。1234567891011121314151617181920212223242526void postorderNoncursion(BTNode *bt) &#123; if(bt!=NULL) &#123; BTNode *Stack1[maxsize]; //定义一个辅助遍历的栈 int top1=-1; BTNode *Stack2[maxsize]; //定义一个用来逆序的栈 int top2=-1; BTNode *p=NULL; //遍历指针 Stack1[++top1]=bt; //根结点入栈Stack1 while(top1!=-1) &#123; p=Stack1[top1--]; //出栈S1 Stack2[++top2]=p; //上一步出栈出来的元素入栈到S2 if(p-&gt;lchild!=NULL) Stack1[++top1]=p-&gt;lchild; //左孩子先入栈 if(p-&gt;rchild!=NULL) Stack1[++top1]=p-&gt;rchild; //右孩子入栈 &#125; while(top2!=-1) &#123; p=Stack2[top2--]; //出栈, Visit(p); //后打印 &#125; &#125; &#125; 二叉树的估计 二叉树的表达式 本文章主要整理于《数据结构高分笔记》和《率辉数据结构辅导专栏》微信号:辉解读。","link":"/2018/10/14/data-structure-6/"},{"title":"搜索算法--DFS+BFS","text":"虽然DFS和BDFS都是搜索方法，但是在不同的问题中两者的效率还是会有差别的。dfs实现的方式是递归或者非递归，但是其本质还是栈。bfs的本质则是队列。本质不同，他们的搜索方式必然是不同的，dfs是在其中可选项中选择一个，然后再以其再递归如果不满足了就回溯。而bfs就不同，bfs是选择一个元素，其元素的周围的可选项全部入队，然后出队首元素，出对的元素的周围可选项再全部入队，如此。DFS类比于撞南墙（递归），撞到头不好走了就返回（回溯）；BFS就相当于水面上的涟漪，一圈一圈的扩散。具体概念上的异同点可以查阅资料，下面举例几道题感受一下： 首先看一道经典例题：八皇后问题。题目链接对于要求一个棋子，其对应的所在行，所在列，所在两个对角线都不能有其他的棋子存在。 那么b[j]==0即为搜在列没有棋子。c[i+j]==0代表其左下到右上的斜对角线上没有棋子，因为你会发现，i+j相同，即代表行+列的和相同，满足这样的情况，就是同一对角线上的棋子，且是左下到右上的斜对角线。d[i-j+n]==0代表的是左上到右下的斜对角线的棋子们。i-j相同，即行-列的差相同，就是同一从左上到右下的斜对角线。因为i-j会有小于0的情况，所以，要+n。 程序的思想是：从第一行开始，对每一行的每一个列递归查找。如果满足条件就标记此处，在此下棋。如果下的棋子的个数达到n，就按条件输出，如果没有达到，就递归搜索下一行。如果这一行的所有列都搜索过了，且没有满足条件的地方，那么就出递归，消除上一行中下棋的地方，重新再这一行中的下面没有寻找的列中找到满足下棋的地方，如果找到就向下递归，如果这行也没有找到，就回溯到上一行，取消掉这一行中所下的棋子。如此过程即可。这是一个典型的深度优先遍历的思想。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;int a[1000],b[1000],c[1000],d[1000];//a数组存行，b存列，c存左下到右上的对角线，d存右下到左上的对角线int n,s;void shuchu()&#123; int i; s++; if(s&lt;=3)&#123; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;\" \";//按要求将行输出 &#125; cout&lt;&lt;endl; &#125;&#125;int search(int i)&#123;//i 行 int j;//j 列 for(j=1;j&lt;=n;j++)&#123; if(b[j]==0&amp;&amp;c[i+j]==0&amp;&amp;d[i-j+n]==0)&#123;//如果这个行的j列，两个写对角线都没有棋子 a[i]=j;//那么就将这个棋子下到这，按题目要求，将j列写进去这个数组中 b[j]=1;//此行标记为已经下了棋子了 c[i+j]=1;//同上，只是是对角线 d[i-j+n]=1;//同上 if(i==n) shuchu();//满足条件输出 else search(i+1);//递归 b[j]=0;//递归口出来，要消除他们的标记，回溯 c[i+j]=0; d[i-j+n]=0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; search(1); cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 接着看一道题：单词方阵题目链接 解题思路：首先先要找到一个字符串是’y’，然后以这个字符为循环起点，分别对这个点的八个不同的方向去循环。选择一个方向，循环这个方向上的所有字符串，如果所有的字符串都和所求字符串相同，就将这个方向保存在ans数组种，如果字符串有一个不同或者越界，就至标记flag=0,跳出字符串的循环，开始下一个方向的循环。 其实这题不太算严谨的DFS，只能叫循环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxn=110;const int dx[]=&#123;1,1,1,0,0,-1,-1,-1&#125;;//方向数组const int dy[]=&#123;1,0,-1,1,-1,0,1,-1&#125;;const string cmp=\"yizhong\";char a[maxn][maxn],ans[maxn][maxn];int n;void dfs(int x,int y)&#123;//从这个点的不同的方向遍历 for(int i=0;i&lt;8;i++)&#123;//这里循环是，八个方向的循环 int flag=1; for(int j=1;j&lt;=6;j++)&#123;//这里循环，是字符串的循环，因为先找到了字符串的开头， //所以循环次数要字符串长度-1 int xx=x+j*dx[i];//新的方向 int yy=y+j*dy[i]; if(xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n)&#123;//越界 flag=0; break; &#125; if(cmp[j]!=a[xx][yy])&#123;//有一个字符不相同，就break flag=0; break; &#125; &#125; if(flag==0) continue;//如果flag==0，就继续循环下一个方向 for(int j=0;j&lt;=6;j++)&#123;//将满足条件的路径用ans数组保存下来 int xx=x+j*dx[i]; int yy=y+j*dy[i]; ans[xx][yy]=a[xx][yy]; &#125; &#125; return;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;a[i][j];//输入模块 &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(a[i][j]=='y') dfs(i,j);//如果找到了开头的字母y， //那么就从此位置开始深度遍历 &#125; &#125; for(int i=1;i&lt;=n;i++)&#123;//输出 for(int j=1;j&lt;=n;j++)&#123; if(ans[i][j]==0) ans[i][j]='*'; cout&lt;&lt;ans[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 再看一个题：迷宫题目链接 这题的思路无独有偶，可以用深度搜索遍历。只是其中的tt数组有两个功能，一个是表示是否这个为陷阱，还有一个功能是要他来表示边界，因为tt数组定义在栈中，即为全局变量，所以默认都是0，所以又要表示出边界，只能初始化为1。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;-1,1,0,0&#125;;int tt[6][6];//这是存储地图中障碍点的信息bool temp[6][6];//temp是标记此点是否走过int n,m,t;int total;int tx,ty;int sx,sy,fx,fy;void dfs(int x,int y)&#123; if(x==fx&amp;&amp;y==fy)&#123;//如果能达到终点 total++;//总数加1 return; &#125; else&#123; for(int i=0;i&lt;=3;i++)&#123; if(temp[x+dx[i]][y+dy[i]]==0&amp;&amp;tt[x+dx[i]][y+dy[i]]==1)&#123; //如果没有走过这个点，且他不是障碍点的话， temp[x][y]=1;//就选择走这个点，即先将这个点标记为走过 dfs(x+dx[i],y+dy[i]);//然后递归 temp[x][y]=0;//递归出口，要将这个点的标记复原 &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;//输入长度宽度，障碍个数 cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;//输入起始地点和结束地点 for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; tt[i][j]=1;//先默认标记地图中的点为1 &#125; &#125; for(int k=1;k&lt;=t;k++)&#123; cin&gt;&gt;tx&gt;&gt;ty; tt[tx][ty]=0;//输入障碍点,如果是障碍点就将此处的标记设为0 &#125; dfs(sx,sy); cout&lt;&lt;total&lt;&lt;endl; return 0;&#125; 填涂颜色题目链接DFS题解如下：注意下题再输入的时候是从i=1，j=1处输入的，但是数组的行，列都是从0，0开始的，所以，我们输入的数组，没有贴着数组输入，输入的数字是被外面一圈0包围着的。这样，就不会如果输入的数据一开始就是包围圈，递归就停止递归了。就不会出现上述这种情况。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int a[32][32],b[32][32];int dx[5]=&#123;0,-1,1,0,0&#125;;int dy[5]=&#123;0,0,0,-1,1&#125;;int n,j,i;void dfs(int x,int y)&#123; int i; if(x&lt;0||x&gt;n+1||y&lt;0||y&gt;n+1||a[x][y]!=0) return;//如果越界或者碰到闭合圈，退出 a[x][y]=1;//染色 for(i=1;i&lt;=4;i++)&#123; dfs(x+dx[i],y+dy[i]);//对当前位置的上下左右四个方位递归 &#125;&#125;int main()&#123; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)&#123;//注意是从1开始输入 for(j=1;j&lt;=n;j++)&#123; cin&gt;&gt;b[i][j]; if(b[i][j]==0) a[i][j]=0; else a[i][j]=2; &#125; &#125; dfs(0,0); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(a[i][j]==0) cout&lt;&lt;2&lt;&lt;' ';//如果此时还是0，说明这些0是闭合圈里的 else cout&lt;&lt;b[i][j]&lt;&lt;' ';//输出闭合圈 &#125; cout&lt;&lt;'\\n'; &#125; return 0;&#125; 字串变化题目链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;const int maxn=15;string aa;//string b;int n,ans;struct node&#123; string a; int step;&#125;;string shi[maxn];string zhong[maxn];map&lt;string,int&gt; ma;//建立string型与int型的映射,用来判重string pin(const string &amp;a,int i,int j)&#123;//拼接函数 //对于要拼接的串a，我们试图在他的第i个位置用第j种手段去改变 //然后去判断此改变是否合法，如果合法就压入队列，再次搜索 string ans=\"\"; if(i+shi[j].length()&gt;a.length())&#123; return ans; &#125; for(int k=0;k&lt;shi[j].length();k++)&#123; if(a[i+k]!=shi[j][k]) return ans; &#125; ans=a.substr(0,i); ans+=zhong[j]; ans+=a.substr(i+shi[j].length()); return ans;&#125;void bfs()&#123; queue&lt;node&gt; q; node s; s.a=aa;//先将输入的字符串， s.step=0; q.push(s);//入队 while(!q.empty())&#123; node u=q.front();//将队首结点赋给u q.pop();//出队 string temp; if(ma.count(u.a)==1)&#123;//count函数是map中判断关键字是否出现 //优化一下，如果重复的路径就continue continue; &#125; if(u.a==b)&#123;//如果等于最后需要的字符串 ans=u.step; break; &#125; ma[u.a]=1;//标记为1 //下面的双重for循环的含义是： //枚举当前队列中队头那个串的每一个字符，且对每一个字符 //枚举所有的可能转换的情况，然后去尝试拼接 for(int i=0;i&lt;u.a.length();i++)&#123; for(int j=0;j&lt;n;j++)&#123; temp=pin(u.a,i,j); if(temp!=\"\")&#123; node v; v.a=temp; v.step=u.step+1; q.push(v); &#125; &#125; &#125; &#125; if(ans&gt;10||ans==0)&#123; cout&lt;&lt;\"NO ANSWER!\"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;int main()&#123; cin&gt;&gt;aa&gt;&gt;b;//输入两个字符串 while(cin&gt;&gt;shi[n]&gt;&gt;zhong[n]) n++;//因为不知道输入多少个转换条件，所以就用while判定 bfs();//调用bfs return 0; &#125;","link":"/2019/07/01/ruogu-dfs-bfs/"},{"title":"计划表","text":"2018年硕士研究生入学考试专业基础课程考试大纲及题型分布 题型分布 一、选择题：（40道题，每题2分，共80分） 操作系统：16道题数据结构：12道题组成原理：12道题 二、综合问答题：（7道题，平均10分，共70分）操作系统：3道题（共28分）数据结构：2道题（共21分）组成原理：2道题（共21分） 考试大纲 操作系统【考查目标】 掌握操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行。 掌握操作系统进程、内存、文件和I/O管理的策略、算法、机制以及互相关系。 能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C或C++等高级语言描述相关算法。 一、操作系统概述（一）操作系统的概念、特征、功能和提供的服务（二）操作系统的发展与分类（三）操作系统的运行环境 内核态与用户态 中断、异常 系统调用（四）操作系统的结构 二、进程管理（一）进程与线程 进程概念 进程的状态与转换 进程控制和组织进程控制块；调度队列和调度器；进程的创建和终止。4.线程概念与多线程模型（二）CPU调度 调度的基本概念 调度时机、切换与过程 调度的基本准则 调度方式 典型调度算法先来先服务调度算法；短作业（短进程、短线程）优先调度算法；时间片轮转调度算法；优先级调度算法；多级反馈队列调度算法。（三）同步与互斥 进程同步和临界区的基本概念 信号量 使用信号量描述和解决经典同步问题 （四）死锁 死锁的概念 死锁处理策略 死锁预防 死锁避免系统安全状态；银行家算法。 死锁检测和解除 三、内存管理（一）内存管理基础 内存管理概念程序装入与链接；逻辑地址与物理地址空间；内存保护。 连续分配管理方式 非连续分配管理方式分页管理方式；分段管理方式；段页式管理方式。（二）虚拟内存管理 虚拟内存基本概念 请求分页管理方式 页面置换算法最佳置换算法（OPT）；先进先出置换算法（FIFO）；最近最少使用置换算法（LRU）。 页面分配策略 工作集 抖动 四、文件管理（一）文件系统基础 文件概念 文件的逻辑结构顺序文件；索引文件；索引顺序文件。 目录结构文件控制块和索引节点；单级目录结构和两级目录结构；树形目录结构；图形目录结构。 文件共享 文件保护访问类型；访问控制。（二）文件系统实现 文件系统层次结构 目录实现 文件实现（三）磁盘组织与管理 磁盘的结构 磁盘调度算法 磁盘的管理 五、输入输出（I/O）管理（一）I/O管理概述 I/O控制方式 I/O软件层次结构（二）I/O核心子系统 I/O调度概念 高速缓存与缓冲区 数据结构【考查目标】 1. 理解数据结构的基本概念；掌握数据的逻辑结构、存储结构及其差异以及各种基本操作的实现。 2. 掌握基本的数据处理原理和方法的基础上，能够对算法进行设计与分析。 3. 能够选择合适的数据结构和方法进行问题求解；具备采用c或c++语言设计与实现算法的能力。【考查范围】 一、线性表 (一) 线性表的定义和基本操作 (二) 线性表的实现 1. 顺序存储结构 2. 链式存储结构 3. 线性表的应用 二、栈、队列和数组 (一) 栈和队列的基本概念 (二) 栈和队列的顺序存储结构 (三) 栈和队列的链式存储结构 (四) 栈和队列的应用 (五) 特殊矩阵的压缩存储 三、树与二叉树 (一) 树的基本概念 (二) 二叉树 1. 二叉树的定义及其主要特征 2. 二叉树的顺序存储结构和链式存储结构 3. 二叉树的遍历 4. 线索二叉树的基本概念和构造 (三) 树、森林 1. 树的存储结构 2. 森林与二叉树的转换 3. 树和森林的遍历(四) 树和二叉树的应用 二叉排序树 2. 平衡二叉树 3. 哈夫曼(Huffman)树和哈夫曼编码 三、图 (一) 图的概念 (二) 图的存储及基本操作 1. 邻接矩阵法 2. 邻接表法 (三) 图的遍历 1. 深度优先搜索 2. 广度优先搜索(四) 图的基本应用 1. 最小(代价)生成树 2. 最短路径 3. 拓扑排序 4. 关键路径 四、查找 (一) 查找的基本概念 (二) 顺序查找法 (三) 折半查找法 (四) B-树及其基本操作、B+树的基本概念(五) 散列(Hash)表 (六) 查找算法的分析及应用 五、内部排序 (一) 排序的基本概念 (二) 插入排序 1. 直接插入排序 2. 折半插入排序 (三) 冒泡排序(bubble sort) (四) 简单选择排序 (五) 希尔排序(shell sort) (六) 快速排序 (七) 堆排序 (八) 二路归并排序(merge sort) (九) 基数排序 (十) 各种内部排序算法的比较 (十一) 内部排序算法的应用 计算机组成原理 【考查目标】 1. 理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念。 2. 理解计算机系统层次化结构的概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。 能够运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，并能对一些基本部件进行简单设计。 一、计算机系统概述 (一)计算机发展历程 (二)计算机系统层次结构 1.计算机硬件的基本组成 2.计算机软件的分类 3.计算机的工作过程 (三)计算机性能指标 响应时间、吞吐率，CPU时钟周期、主频、CPI、CPU执行时间，MIPS、MFLOPS 二、数据的表示和运算 (一)数制与编码 1.进位计数制及其相互转换 2.数据编码：机器数及其编码，BCD码，字符编码 3.校验码(二)数据的表示 数值数据的定点表示：无符号数的表示，有符号数的表示 数值数据的浮点表示：浮点表示方法，IEEE754标准 非数值数据的表示：字符与字符串的表示，逻辑数的表示(三) 定点数的运算 位移运算，位扩展运算，原码加/减运算，补码加/减运算，原码一位乘法运算，补码一位乘法运算，溢出概念和判别方法 (四)浮点数的运算 加/减运算 (五)算术逻辑单元ALU 1.串行进位加法器和并行进位加法器 2.算术逻辑单元ALU的功能和结构 三、存储器层次结构 (一)存储器的分类 (二)存储器的层次化结构 (三)半导体随机存取存储器 1. SRAM存储器的工作原理 2. DRAM存储器的工作原理 3.只读存储器(四)主存储器主存的逻辑设计，主存与CPU的连接，提高访存速度的措施 (五)高速缓冲存储器(Cache) 1.Cache的基本工作原理 2.Cache和主存之间的映射方式 3. Cache中主存块的替换算法 4. Cache写策略 (六)虚拟存储器 1.虚拟存储器的基本概念 2.虚拟存储器的实现 页式虚拟存储器，段式虚拟存储器，段页式虚拟存储器，TLB(快表) 四、指令系统 (一)指令格式指令的功能，指令的基本格式，操作码字段的功能及表示，地址码字段的功能及表示，指令字的相关概念 (二)指令的寻址方式 1.有效地址的概念 2.数据寻址和指令寻址 3.常见寻址方式 (三) CISC和RISC的基本概念 五、中央处理器(CPU) (一) CPU的功能和基本结构(二) 指令执行过程 CPU的工作流程，指令的执行过程，CPU基本操作与微操作的关系，指令执行过程的微操作序列(三)数据通路的功能和基本结构数据通路的类型，单总线数据通路的基本结构，微操作与微操作命令的关系，指令执行过程的微操作命令序列 (四)控制器的功能和工作原理 1.硬布线控制器基本结构，时序系统组成，信号时序控制方式，微操作控制信号形成 2.微程序控制器 微程序相关概念，微指令的编码方式，微地址的形成方式 (五)指令流水线 1.指令流水线的基本概念 2.指令流水线的基本实现 3.超标量和动态流水线的基本概念 (六)多核处理器的基本概念 六、总线 (一)总线概述 1.总线的基本概念 2.总线的分类 3.总线的组成及性能指标 总线的操作过程 (二)总线仲裁 1.集中仲裁方式：链式查询，计数器定时查询，独立请求 2.分布仲裁方式的基本概念 (三)总线操作定时 同步定时方式，异步定时方式，半同步定时方式 (四)总线标准 七、输入输出(I/O)系统 (一)I/O系统基本概念 (二)外部设备 输入设备，输出设备，外存储器 (三) I/O接口(I/O控制器) 1.I/O接口的功能和基本结构 2.I/O端口及其编址 3.I/O地址空间及其编码 (四)I/O方式 1.程序查询方式 2.程序中断方式 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念 3.DMA方式 DMA控制器的组成，DMA传送过程4.通道方式","link":"/2018/04/13/plan/"},{"title":"贴一个用python实现了一个解析pcap文件的小工具","text":"作为学习了一段时间的py和复习了一段网络有关的知识，就实现了如下的一个小工具，输入时pcap格式的文件，后序的话在实现用哈希来更好的存储吧。。嗯。。写的有点乱。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211import structimport os#x=os.system('cls')def clear():os.system('cls')#def clear(): # os.system('clear')#huanyingdef welcome(): print('\\t******************************\\n') print ('\\t* *\\n') print ('\\t* oneturle sniffer *\\n') print ('\\t* *\\n') print('\\n\\t******************************\\n') print('你想要了解什么呢?\\n') print('1.报文总数统计\\n') print('2.平均每秒字节数和每秒报文数的统计\\n') print('3.各种协议的每秒报文数统计和每秒字节数统计\\n') print('4.各种协议数据在流量中所占的比例\\n') print('5.退出\\n')#初始化参数input_file=input('请输入文件名：\\n')output_file=input('请输出文件名：\\n')print(\"\\n\"*15)m=0n=0tcp_n=0udp_n=0tcp_n=0udp_n=0egp_n=0igp_n=0ipv6_n=0ospf_n=0icmp_n=0igmp_n=0tcp_l=0udp_l=0tcp_l=0udp_l=0egp_l=0igp_l=0ipv6_l=0ospf_l=0icmp_l=0igmp_l=0ftime=0ltime=0ip_tlen=0with open(output_file,'w') as g: with open(input_file,'rb') as f: total=f.read(24) total=struct.unpack('LHHLLLL',total)#BHL while True: b=f.read(16) if b==b'': break #for i in range(18): #b=f.read(16) #shujutou b=struct.unpack('4i',b) if m==0: ftime=b[0] #shujudaodashijian else: ltime=b[0] #n=n+b[3] #jisuanshujuchangdu #g.write('%d '%b[1]) #print('%d'%b[3]) f.read(12) #mac frametype=f.read(2) #panbianip leixing if frametype!=b'\\x08\\x00': f.read(b[2]-14) #if frametype!=b'\\x08\\x00': #f.read(b[2]-14) else: g.write('%6d '%b[1]) n=n+b[2] version=f.read(1) #ipv4 or ipv6 g.write('IPV'+str(int(struct.unpack('B',version)[0]/16))+' ') TOS=f.read(1) #fuwu lei xing total_length=f.read(2) # chang du ip_tlen=ip_tlen+total_length[1] #jisuan changdu ID=f.read(2) Flag_segment=f.read(2) life=f.read(1) xieyi=f.read(1) #print(xieyi) check=f.read(2) #xieyi=struct.unpack('B',xieyi) #print('%d'%xieyi) ip_from=f.read(4) #ip address ip_from=struct.unpack('4B',ip_from) ip_to=f.read(4) ip_to=struct.unpack('4B',ip_to) port_from=f.read(2) #duan kou port_to=f.read(2) port_from=port_from[0]*256+port_from[1] port_to=port_to[0]*256+port_to[1] #port_from=struct.unpack('H',port_from) #port_to=struct.unpack('H',port_to) seq=f.read(4) #xu lie hao ac=f.read(4) #ack renzheng g.write('.'.join(['%3d'%i for i in ip_from])+':%d'%port_from) g.write('==&gt;') g.write('.'.join(['%3d'%i for i in ip_to])+':%d '%port_to) f.read(b[3]-34-12)#shuju chang du -shuju tou -shuju neirong #if frametype==b'\\x08\\x00': m=m+1 #ip bao geshu if xieyi==b'\\x06': g.write('TCP') tcp_n=tcp_n+1 tcp_l=tcp_l+b[2] elif xieyi==b'\\x11': g.write('UDP') udp_n=udp_n+1 udp_l=udp_l+b[2] elif xieyi==b'\\x01': g.write('ICMP') icmp_n=icmp_n+1 icmp_l=icmp_l+b[2] elif xieyi==b'\\x02': g.write('IGMP') igmp_n=igmp_n+1 igmp_l=igmp_l+b[2] elif xieyi==b'\\x08': g.write('EGP') egp_n=egp_n+1 egp_l=egp_l+b[2] elif xieyi==b'\\x09': g.write('IGP') igp_n=igp_n+1 igp_l=igp_l+b[2] elif xieyi==b'\\x29': g.write('IPV6') ipv6_n=ipv6_n+1 ipv6_l=ipv6_l+b[2] elif xieyi==b'\\x4f': g.write('OSPF') ospf_n=ospf_n+1 ospf_l=ospf_l+b[2]#3 g.write(' ') g.write('%dbyte'%b[2]) #dan ge baowen changdu g.write('\\n') #print('%d'%f.tell())welcome()k=mwhile True: f=input('请输入：\\n') f=int(f) if f==1: print('\\n\\n\\n报文大小为: %ld byte\\n'%n) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==2: print(\"\\n\\n\\n平均每秒字节数为:%4.2f b/s\\n\"%(n/(ltime-ftime))) print(\"平均每秒报文数为:%8.6f m/s\\n\"%(k/(ltime-ftime))) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==3: print(\"\\n\"*5) print('\\n\\n\\nICM2P:协议的每秒报文数统计:%4.2f b/s\\n'%(icmp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(icmp_n/(ltime-ftime))) print(\"IGMP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(igmp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(igmp_n/(ltime-ftime))) print('TCP:协议的每秒报文数统计:%4.2f b/s\\n'%(tcp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(tcp_n/(ltime-ftime))) print(\"EGP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(egp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(egp_n/(ltime-ftime))) print('IGP:协议的每秒报文数统计:%4.2f b/s\\n'%(igp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(igp_n/(ltime-ftime))) print(\"UDP:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(udp_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(udp_n/(ltime-ftime))) print('IPV6:协议的每秒报文数统计:%4.2f b/s\\n'%(ipv6_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(ipv6_n/(ltime-ftime))) print(\"OSPF:\\t协议的每秒报文数统计:%4.2f b/s\\n\"%(ospf_l/(ltime-ftime))) print(\"每秒字节数统计:%4.2f m/s\\n\"%(ospf_n/(ltime-ftime))) flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==4: print(\"\\n\"*18) print('\\n\\n\\nICMP :%4.2f'%(icmp_n/k*100)+'%\\n') print('IGMP :%4.2f'%(igmp_n/k*100)+'%\\n') print('TCP :%4.2f'%(tcp_n/k*100)+'%\\n') print('EGP :%4.2f'%(egp_n/k*100)+'%\\n') print('IGP :%4.2f'%(igp_n/k*100)+'%\\n') print('UDP :%4.2f'%(udp_n/k*100)+'%\\n') print('IPV6 :%4.2f'%(ipv6_n/k*100)+'%\\n') print('OSPF :%4.2f'%(ospf_n/k*100)+'%\\n') flag=input('是否继续,y or n?\\n') if flag=='y': print(\"\\n\"*15) welcome() elif flag=='n': exit(0) if f==5: print('\\n\\n再见~\\n\\n') exit(0)","link":"/2018/07/18/shujubaojiexi-py/"},{"title":"urllib库详解","text":"&nbsp;&nbsp;非常明显，技术已经超越我们的人性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——阿尔伯特·爱因斯坦（Albert Einstein） python爬虫之旅之第一站~~ 首先讲一下urllib库，他是python内置的一个http请求库，他有以下主要的四个模块： urllib.request 请求模块，我们通过他来模拟发送一个请求 urllib.error 异常处理模块 urllib.parse url解析模块，可以对url进行拆分，合并等操作 urllib.robotparser robots.txt解析模块，主要是对网站的robots.txt文件进行解析 下面我们就来讲解一下urllib库中的各种使用情况： urlopen函数：urllib.request.urlopen(url,data=None,[timeout])urlopen函数中的常见的参数有url,data和timeout，url参数是传入网站的url，data参数主要是用来传入一些其他的数据，timeout是用于超时的数据。 下面看代码：123import urllib.requestresponse=urllib.request.urlopen(\"http://aisleep.xyz\")print(response.read().decode('utf-8')) 其中.read()是获取response的内容，因为一开始是bytes数据，所以才要再用.decode(&#39;utf-8&#39;)将其转为字符串。这个是request的一个get的请求。 接着看：123456import urllib.parseimport urllib.requestdata=bytes(urllib.parse.urlencode(&#123;'word': 'hello'&#125;),encoding='utf8')response=urllib.request.urlopen('http://httpbin.org',data=data)print(response.read()) 这里传入了个data，且必须是bytes类型。其中调用urlencode方法传入所需要的字典，后又定义了一个编码方式。这就是post请求。 下面再看一下使用timeout参数的代码：12345678910import urllib.requestimport socketimport urllib.errortry: response=urllib.request.urlopen('http://httpbin.org/get',timeout=1) print(response.read())except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(\"time out\") 这里是使用了一个try-except处理异常，还设置了一个timeout参数，还有涉及到了一些error等，这个后面会有讲解。 下面我们再来看看，urlopen的响应类型（一般常用的有：状态码，响应头，响应体）：代码一：123import urllib.requestresponse=urllib.request.urlopen('http://baidu.com')print(type(response)) 代码二：123456import urllib.requestresponse=urllib.request.urlopen('https://baidu.com')print(response.status)print(response.getheaders()）print(response.getheader('Server'))print(response.read().decode('utf-8')) 代码一中是返回了response的类型是什么，代码二中第3行是返回的状态码，一般请求成功状态码就是200第4行是返回的响应头的全部信息，第5行则是返回的是响应头中的Server参数的信息，第6行则是使用了常用的read方法，来获取响应体的内容。 Request对象 代码一： 1234import urllib.requestrequest=urllib.request.Request('http://aisleep.xyz')response=urllib.request.urlopen(request)print(response.read().decode('utf-8')) 代码二：12345678910from urllib import request,parseurl=\"http://httpbin.org/post\"dict=&#123; 'name':'lifan'&#125;data=bytes(parse.urlencode(dict),encoding='utf8')req=request.Request(url=url,data=data,method='POST')req.add_header('User-Agent','Mozilia/4.0(compatible;MSIE 5.5;Windows NT)')response=request.urlopen(req)print(response.read().decode('utf-8')) 这里代码二是将url,data,header一起传给Request对象，然后再使用urlopen函数。第8行是传入了一个header,可以用特殊的add_header函数，也可以将其构造一个和这里的dict一样的字典传给Request。通过Request对象可以将我们需要传入的请求方式，请求头，请求体等参数构造成一各整体，传给Request对象，发送给服务器。这里使用Request对象，再调用urlopen函数的方法相比于直接使用urlopen函数的好处就是可以传入更多类型的参数。不单单只是url,timeout,data等了。 代理（handler） 12345678import urllib.requestproxy_handler=urllib.request.ProxyHandler(&#123; 'https': 'https://127.0.0.1:9743', 'http': 'http://127.0.0.1:9743' &#125;)opener=urllib.request.build_opener(proxy_handler)response=opener.open('http://www.google.com')print(response.read()) 这里稍后再细讲 cookie 获取cookie 1234567import urllib.request,http.cookiejarcookie=http.cookiejar.CookieJar()hander=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(hander)response=opener.open('http://www.baidu.com')for item in cookie: print(item.name+\"=\"+item.value) cookie保存： 12345678#cookie保存方式1import http.cookiejar,urllib.requestfilename=\"cookie.txt\"cookie=http.cookiejar.MozillaCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(\"http://www.baidu.com\")cookie.save(ignore_discard=True,ignore_expires=True) 12345678#cookie保存方式2import http.cookie,urllib.requestfilename ='cookie.txt'cookie=http.cookiejar.LWPCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open('http://www.baidu.com')cookie.save(ignore_discard=True,ignore_expires=True) 1234567#读取cookie文件import http.cookiejar,urllib.requestcookie=http.cookiejar.LWPCookiejar()cookie.load('cookie.txt',ignore_discard=True,ignore_expires=True)handler=urllib.request.build_opener(handler)response=opener.open('http://www.baidu.com')print(response.read().decode('utf-8')) cookie这里的使用，后面再细讲。 error模块，异常处理 123456789from urllib import request,errortry: response=request.urlopen('http://www.baidu.com')except error.HTTPError as e: print(e.reason,e.code,e.headers,sep='\\n')except error.URLError as e: print(e.reason)else： print（'Request.Successfully'） urlparse模块，url解析 123from urlib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment')print(result) urlparse模块主要是对url进行解析，这个代码的输出信息是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id5&#39;,fragment=&#39;comment&#39;) 再看： 123from urlib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment',scheme='https')print(result) 这个代码的输出信息则是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id5&#39;,fragment=&#39;comment&#39;)可以看到，我们指定的协议类型，如果默认协议存在则不会被我们指定的协议所改变。 再看： 12from urllib.parse import urlparseresult=urlparse('http://www.baidu.com/index.html;user?id=5#comment',allow_fragments=False) 这个代码的输出信息则是：ParseResult(scheme=&#39;http&#39;,netloc=&#39;www.baidu.com&#39;,path=&#39;/index.html&#39;,params=&#39;user&#39;,query=&#39;id=5#comment&#39;,fragment=&#39;&#39;)可见，当我们指定allow_fragment=False的时候，fragment的内容就会被拼接到前面的query 里面去。如果连前面的query也没有呢？fragment里面的内容会继续拼接到前面的地方。 unurlparse函数，组成url 123from urllib.parse import urlunparsedata=['http','www.baidu.com','index.html','user','a=6','comment']print(urlunparse(data)) 这个代码的输出信息则是：http://www.baidu.com/index.html;user?a=6#comment urljoin函数，拼接url 12345from urllib.parse import urljoinprint(urljoin('http://www.baidu.com','https://www.google.com/faq.html'))print（urljoin('http://www.baidu.com','https://www.baidu.com')）print(urljoin('http://www.baidu.com','http://www.baidu.com/FAQ.html?question=2'))print(urljoin('http://www.baidu.com','?category=1')) 这个代码的运行结果是：1234https://www.google.com/faq.htmlhttps://www.baidu.comhttp://www.baidu.com/FAQ.html?question=2http://www.baidu.com?category=1 我们从中可以知道，urljoin函数，泛泛的理解就是：在前者后者都有的情况下，后者的内容会覆盖前者，前者没有后者有的时候，也是为后者的内容，如果前者有，后者内容没有就以前者为准。 urlencode函数，将字典对象转换成get请求参数 12345678from urllib.parse import urlencodeparams=&#123; 'name':'lifan', 'age':23&#125;base_url='http://www.baidu.com'url=base_url+urlencode(params)print(url) 运行结果是：http://www.baidu.comname=lifan&amp;age=23 var gitment = new Gitment({ owner: 'fanandli', //改你自己的名字 repo: 'Comments', //专门储存评论一个GitHub仓库 oauth: { client_id: '07907d02b088f1358f34', //改为你自己的，下同 client_secret: 'd9f8fe0bb6f746db6e0d7b9478e7c907871c790d', }, }) gitment.render('container')","link":"/2018/04/01/web-scraping-1/"},{"title":"有关栈的问题","text":"1、利用栈将中缀表达式求值：计算规则：设两个栈，s1用来存储操作数，s2用来存储运算符。从左往右扫描表达式，遇到操作数就将入栈s1,遇到运算符就入栈s2。当前扫描到的运算符优先级大于栈顶的运算符的优先级，则入栈，否则，就出栈s1中的两个操作数，进行计算，将计算结果入栈s1。且栈顶的操作数先出栈，放在运算符的右边，栈顶下面的一个操作数后出栈，放在运算符的左边。如果遇到左括号就直接入栈s2，直到遇到右括号，此时，从栈顶到左括号的运算符都出栈进行计算。出栈的运算符都不再入栈。如果表达式全部扫描完毕，s2栈中还有运算符的话就挨个出栈进行计算，计算结果依次放入s1栈中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int getpriority(char op) //判断运算符的优先级&#123; if(op=='+'||op == '-') // 规定只有+,-,*,/这四个运算 return 0; //若是+，-，则返回0 else return 1; //若是*，/，则返回1&#125;int calSub(float opandl,char,op,float opand2,float &amp;result) //出栈两个操作数和一个运算符进行运算&#123; if(op=='+') result = opandl+opand2; if(op=='-') result = opandl-opand2; if(op=='*') result = opandl*opand2; if(op=='/') &#123; if(fabs(opand2)&lt;MIN) //判断float型为0的标准语句 &#123; return 0; //除数为0的情况返回0，意为运算失败 &#125; else &#123; result = opandl / opand2; // 如果除数不是0的话就相除 &#125; &#125; return 1; //成功运算返回1，且结果保存在result中。&#125;float calInfix(char exp[]) //计算中缀表达式&#123; float s1[maxSize];int top1=-1; //顺序栈，来存操作数 char s2[maxSize];int top2=-1; //存运算符 int i=0; while(exp[i]!='\\0') //串尾为\\0 &#123; if('0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') //这里的0，9都是字符，不是数字，且假设输入都是一位数字 &#123; //所以字符的大小比较，是比较这个字符对应ascll码值 s1[++top1]=exp[i] -'0'; //exp[i]-'0'就将字符转为这个字符对应的数值，入栈 ++i; &#125; else if (exp[i]=='(') //如果扫描到了（,则直接入运算符栈 &#123; s2=[++top2]='('; ++i; &#125; else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') //如果扫描到了运算符 &#123; //一般有两种情况，一是直接入栈，二是弹出操作数进行运算后再入栈 if(top2==-1||s2[top2]=='(' || getpriority(exp[i])&gt;getpriority(s2[top2])) //如果栈空， //如果为（， &#123; //如果当前扫描到的运算符的优先级大于栈顶的运算符的优先级 s2[++top2]=exp[i]; //就入栈 ++i; &#125; else //如果不满足，就弹出运算符，和一些运算符进行运算 &#123; float opnd1,opnd2,result; //出栈的两个操作数，和结果 char op; //要进行运算的运算符 int flag; //接受calSub返回的标记 opnd2=s1[top--]; //先出栈的为第二个操作数 opnd1=s1[top--]; //后出栈的为第一个操作数，顺序不能弄反了 op=s2[top2--]; //弹出一个运算符 flag=calSub(opnd1,op,opnd2,result); //调用calSub函数，函数返回的是0,1，代表成不成功，结果是存在result中的 if(flag==0) //0代表计算不成功 &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; //求值成功了就将结果压栈 &#125; &#125; else if (exp[i]==')') //扫描遇到')'时， &#123; while(s2[top2] !='(') //就不停的出栈，直到遇到'(', &#123; float opnd1,opnd2,result; //且对每一个出栈的运算符进行一次运算 char op; int flag; opnd2=s1[top--]; opnd1=s1[top--]; op=s2[top2--]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; &#125; --top2; //此时指向'(',出栈，去掉他 ++i; //指向下一个字符 &#125; &#125; while(top2!=-1) //当表达式全部扫描之后，如果栈中还有运算符剩余，就全部出栈，且取两个操作数进行计算 &#123; float opnd1,opnd2,result; char op; int flag; opnd2=s1[top--]; opnd1=s1[top--]; op=s2[top2--]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s1[++top1]=result; &#125; retunr s1[top1]; //操作数的结果在栈顶，返回即可&#125; 2、用栈求后缀表达式值：从左往右扫描这个表达式串，当遇到操作数的时候就入栈，当遇到运算符就出栈两个操作数，进行运算，先出栈的操作数放在运算符的左边，后出战的操作数放在运算符的右边。计算出结果，然后将这个结果入栈。一直将运算符全部运算完，最后一个计算结果即所求的值。1234567891011121314151617181920212223242526float calPostFix(char exp[])&#123; float s[maxsize];int top=-1; for(int i=0;exp[i]!='\\0';++i) &#123; if('\\0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') s[++top]=exp[i]-'0'; else //else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') &#123; float opnd1,opnd2,result; char op; int flag; opnd2=s[top--]; opnd1=s[top--]; op=exp[i]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; break; &#125; s[++top]=result; &#125; &#125; return s[top];&#125; 3、用栈求前缀表达式：从右往左扫描这个表达式。当遇到操作数的时候就入栈，当遇到运算符就出栈两个操作数，进行运算，先出栈的数放在运算符的右边，后出栈的放在运算符的左边。其他操作和后缀表达式计算方式一样。1234567891011121314151617181920212223242526float calPreFix(char exp[],int len)&#123; float s[maxsize];int top=-1; for(int i=len-1;i&gt;=0;--i) //从右往左 &#123; if('\\0'&lt;=exp[i] &amp;&amp; exp[i]&lt;='9') s[++top]=exp[i]-'0'; else //else if (exp[i]=='+'||exp[i]=='-'||exp[i]=='*'||exp[i]=='/') &#123; float opnd1,opnd2,result; char op; int flag; opnd1=s[top--]; //这里的出栈操作数的顺序也不一样 opnd2=s[top--]; op=exp[i]; flag=calSub(opnd1,op,opnd2,result); if(flag==0) &#123; std::cout&lt;&lt;\"error\"&lt;&lt;std::endl; return 0; &#125; s[++top]=result; &#125; &#125; return s[top];&#125; 这里就可以看出，中缀形式求值明显比用后缀或者前缀来的复杂，所以，这就是为什么计算机中会出现在生活中不会使用到的后缀和前缀形式。就像十进制一样，为人们所习惯，而计算机中普遍使用的是二进制。所以我们也必须为计算机的发展创造出能被计算机所方便使用和接受的规则。 4、中缀转后缀：转化规则：从左到右扫描中缀表达式，如果遇到操作数就直接将其写入结果表达式，（这个结果表达式的书写顺序是从左往右书写）如果遇到运算符就将其入栈。且如果这个即将入栈的运算符小于等于当前栈顶的运算符，则将当前栈顶的运算符出栈，写入当前得到的结果表达式中，这样一直比较下去，直到即将入栈的运算符的优先级大于当前栈顶的运算符，此时再将这个即将入栈的运算符入栈。如果栈空，就直接入栈，不需要上述的比较。如果遇到左括号，就直接入栈，当栈顶元素是左括号的时候，所有扫描到的运算符都入栈。当扫描到右括号的时候，执行一系列的出栈操作。将当前栈顶到左括号的运算符全部出栈，并将其写入结果表达式中，其中出栈的括号直接扔掉，左右括号都不写入结果表达式。一个左括号配一个右括号。此时如果全部扫描完表达式，栈中还有运算符，则将其全部出栈，写入结果表达式中即可。 12345678910111213141516171819202122232425262728293031323334353637void infixToPostFix(char infix[],char s2[],int &amp;top2)//infix为中缀表达式，s2这个栈用来存储转换后的后缀，top2作为栈顶&#123; char s1[maxSize];int top1=-1;//再定义一个辅助栈 int i=0; while(infix[i]!='\\0') &#123; if('0'&lt;=infix[i] &amp;&amp; infix[i]&lt;='9') &#123; s2[++top2]=infix[i]; ++i; &#125; else if(infix[i]='(') &#123; s1[++top]='('; ++i; &#125; else if(infix[i]=='+'||infix[i]=='-'||infix[i]='*'||infix[i]='/') &#123; if(top1==-1||s1[top1]=='(' || getpriority(exp[i])&gt;getpriority(s1[top1])) &#123; s1[++top1]=infix[i]; ++i; &#125; else s2[++top2]=s1[top1--]; //否则就从s1中出栈一个运算符入s2栈 &#125; else if(infix[i]==')') &#123; while (s1[top1]!='(') s2[++top2]=s1[top--]; --top1; //(出栈 ++i; &#125; &#125; while(top1!=1) s2[++top2]=s1[top1--];&#125; 5、中缀转前缀：转化规则：从右往左扫描，书写结果表达式的方向是从右往左写。遇到右括号直接入栈，遇到左括号就将当前栈顶到右括号的运算符出栈。当前运算符如果小于栈顶的运算符时，则当前栈顶的运算符出栈。其他的操作和中缀转后缀式一样的。12345678910111213141516171819202122232425262728293031323334353637void infixToPreFix(char infix[],char s2[],int &amp;top2,int len)//infix为中缀表达式，s2这个栈用来存储转换后的后缀，top2作为栈顶&#123; char s1[maxSize];int top1=-1;//再定义一个辅助栈 int i=len-1; while(i&gt;=0) &#123; if('0'&lt;=infix[i] &amp;&amp; infix[i]&lt;='9') &#123; s2[++top2]=infix[i]; --i; //注意 &#125; else if(infix[i]=')') //注意 &#123; s1[++top]=')'; --i; //注意 &#125; else if(infix[i]=='+'||infix[i]=='-'||infix[i]='*'||infix[i]='/') &#123; if(top1==-1||s1[top1]=='）' || getpriority(exp[i])&gt;=getpriority(s1[top1])) //注意，为&gt;=，不是&gt; &#123; s1[++top1]=infix[i]; --i; //注意 &#125; else s2[++top2]=s1[top1--]; //否则就从s1中出栈一个运算符入s2栈 &#125; else if(infix[i]=='(') //注意 &#123; while (s1[top1]!=')') //注意 s2[++top2]=s1[top--]; --top1; //(出栈 --i; //注意 &#125; &#125; while(top1!=1) s2[++top2]=s1[top1--];&#125; 6、括号匹配问题：12345678910111213141516171819202122232425262728293031323334int isMatched(char left,char right)&#123; if(left=='(' &amp;&amp; right==')') return 1; if(left=='[' &amp;&amp; right==']') return 1; if(left=='&#123;' &amp;&amp; right=='&#125;') return 1; else return 0;&#125;int isParenthesesBalanced(char exp[])&#123; char s[maxSize];int top=-1; for(int i=0;exp[i]!='\\0';++i) &#123; if(exp[i]=='('||exp[i]=='['||exp[i]=='&#123;') s[++top]=exp[i]; if(exp[i]==')'||exp[i]==']'||exp[i]=='&#125;') &#123; if(top==-1) return 0; //如果栈空就不匹配，返回0 char left =s[top--]; if(isMatched(left,exp[i])==0) return 0; &#125; &#125; if(top&gt;-1) return 0; // 栈不空，则不匹配 return 1; //栈为空，则匹配。返回1&#125; 7、计算问题：类似于这类问题，可以用递归去处理，不过递归的实质也是用栈，只是这个栈是系统分配的栈，我们这里是自己定义了一个栈。 1234567891011121314int calF(int m)&#123; int cum=1; int s[maxSize],top=-1; while(m!=0) &#123; s[++top]=m; m /= 3; //m=m/3 &#125; while(top!=-1) cum *=s[top--]; return cum;&#125; 8、共享栈：这样来定义共享栈：(假设共享栈由s1和s2两个栈共享)12int satck[maxsize];int top1=-1,top2=maxsize; 可以看到，无非就是在栈尾后面一个位置定义一个top2去指向他，在栈首的前一个位置定义一个top1去指向他。一般的，为了更好的同一形式，不用定义两个新的量去指向这些位置，而是定义一个数组，数组中有两个值，分别指向这两个位置。即：top[2]={-1,maxsize};就可以了。分别用top[0],top[1]去使用它们。 s1栈为空：top[0]==-1;s2栈为空：top[1]==maxsize;s1入栈：stack[++top[0]] = x;s2入栈：stack[–top[1]] = x;栈满判断：top[0]+1==top[1]; 9、用栈来模拟队列：用两个栈来实现，即要将栈的“先进后出”变为队列的“先进先出”。","link":"/2018/08/19/zhan-prc/"},{"title":"PAT_A分类题解","text":"list: vector的使用1039 Course List for Student (25 分)1047 Student List for Course (25 分) set的使用1063 Set Similarity (25 分) string的使用1060 Are They Equal (25 分) map的使用1100 Mars Numbers (20 分)1054 The Dominant Color (20 分)1071 Speech Patterns (25 分) 栈1051 Pop Sequence (25 分) 队列1056 Mice and Rice (25 分) 链表1052 Linked List Sorting (25 分)1074 Reversing Linked List (25 分) 简单模拟：1042 Shuffling Machine (20 分)1046 Shortest Distance (20 common.points)1065 A+B and C (64bit) (20 分)1002 A+B for Polynomials (25 分) ========================================================== 1039 Course List for Student (25 分)题目链接思路：注意vector selectCourse[M]和vector selectCourse是不一样的东西。前者相当于是二维数组，后者相当于一维数组。将学生姓名通过getid函数使每一个姓名都与一个数字相关联（类似hash表的思想）以此数字作为selectCourse的下标，用数组selectCourse[i]去存储对应学生所选课程的编号。注意vector的使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N=40010;const int M=26*26*26*10+1;vector&lt;int&gt; selectCourse[M];//用来存储这个学生所选择的课程编号int getid(char name[])&#123;//将name转换为数字 int id=0; for(int i=0;i&lt;3;i++)&#123; id=id*26+(name[i]-'A'); &#125; id=id*10+(name[3]-'0'); return id;&#125;int main()&#123; char name[5]; int n,k;//人数和课程数 scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0;i&lt;k;i++)&#123; int course,x;//课程编号，以及选了这门课的人数 scanf(\"%d%d\",&amp;course,&amp;x); for(int j=0;j&lt;x;j++)&#123; scanf(\"%s\",name); int id=getid(name);//将学生名变为id selectCourse[id].push_back(course);//将课程编号加入这个学生数组中 &#125; &#125; for(int i=0;i&lt;n;i++)&#123; scanf(\"%s\",name); int id=getid(name); sort(selectCourse[id].begin(),selectCourse[id].end()); printf(\"%s %d\",name,selectCourse[id].size()); for(int j=0;j&lt;selectCourse[id].size();j++)&#123; printf(\" %d\",selectCourse[id][j]);//这里注意 &#125; printf(\"\\n\"); &#125; return 0;&#125; 1047 Student List for Course (25 分)题目链接思路：此题的思想与上一题差不多，不过定义的name数组是二维数组，输出name字符串的方法要注意一下，要能透彻的理解vector类似是一个可变长的数组。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=40010;const int maxc=2510;vector&lt;int&gt; course[maxc];//存储选定某门课的学生的编号char name[maxn][5];int n;//选特定课的人数bool cmp(int a,int b)&#123; return strcmp(name[a],name[b])&lt;0;&#125;int main()&#123; int renshu,kechengshu,kebianhao; scanf(\"%d%d\",&amp;renshu,&amp;kechengshu);//输入总人数和总课程个数 for(int i=0;i&lt;renshu;i++)&#123; scanf(\"%s %d\",name[i],&amp;n);//输入姓名，和总选课程数 for(int j=0;j&lt;n;j++)&#123; scanf(\"%d\",&amp;kebianhao);//输入每一个选择的课程编号 course[kebianhao].push_back(i); //以课程编号作为此数组的下标，里面存的是对应的name数组的下标 &#125; &#125; //下面开始输出 for(int i=1;i&lt;=kechengshu;i++)&#123; printf(\"%d %d\\n\",i,course[i].size()); sort(course[i].begin(),course[i].end(),cmp); for(int j=0;j&lt;course[i].size();j++)&#123; printf(\"%s\\n\",name[course[i][j]]); //课程编号为i的course中，以j循环输出选了这门课的学生的名字， //course[i][j]是上文中push_back的i，即为name[i]中的i //每个i对应了一个输入的name字符串 &#125; &#125; return 0;&#125; 1063 Set Similarity (25 分)题目链接思路：用set存储输入的数字，可以去重，然后用compare函数去对比两个不同的集合中的数字是否相同，如果相同，就使samen++,如果不同，就说明使一个新的元素，所以就让totaln++1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;set&gt;using namespace std;const int n=55;set&lt;int&gt; st[n];void compare(int x,int y)&#123; int totaln=st[y].size(),samen=0; for(set&lt;int&gt;::iterator it =st[x].begin();it!=st[x].end();it++)&#123; if(st[y].find(*it)!=st[y].end()) samen++; else totaln++; &#125; printf(\"%.1f%\\n\",samen*100.0/totaln);&#125;int main()&#123; int setn,setinn;//集合个数，集合中元素的个数 int setshu;//集合中的数 scanf(\"%d\",&amp;setn); for(int i=1;i&lt;=setn;i++)&#123; scanf(\"%d\",&amp;setinn); for(int j=0;j&lt;setinn;j++)&#123; scanf(\"%d\",&amp;setshu); st[i].insert(setshu); &#125; &#125; int duibishu,set1,set2; scanf(\"%d\",&amp;duibishu); for(int i=0;i&lt;duibishu;i++)&#123; scanf(\"%d%d\",&amp;set1,&amp;set2); compare(set1,set2); &#125;&#125; 1060 Are They Equal (25 分)题目链接思路： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int n;string deal(string s,int &amp;e)&#123; int k=0;//s的下标 while(s.length()&gt;0&amp;&amp;s[0]=='0')&#123; s.erase(s.begin()); &#125; if(s[0]=='.')&#123; s.erase(s.begin()); while(s.length()&gt;0&amp;&amp;s[0]=='0')&#123; s.erase(s.begin()); e--; &#125; &#125;else&#123; while(k&lt;s.length()&amp;&amp;s[k]!='.')&#123; k++; e++; &#125; if(k&lt;s.length())&#123; s.erase(s.begin()+k); &#125; &#125; if(s.length()==0)&#123; e=0; &#125; int num=0; k=0; string res; while(num&lt;n)&#123; if(k&lt;s.length()) res+=s[k++]; else res+='0'; num++; &#125; return res;&#125;int main()&#123; string s1,s2,s3,s4; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; int e1=0,e2=0; s3=deal(s1,e1); s4=deal(s2,e2); if(s3==s4&amp;&amp;e1==e2)&#123; cout&lt;&lt;\"YES 0.\"&lt;&lt;s3&lt;&lt;\"*10^\"&lt;&lt;e1&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"NO 0.\"&lt;&lt;s3&lt;&lt;\"*10^\"&lt;&lt;e1&lt;&lt;\" 0.\"&lt;&lt;s4&lt;&lt;\"*10^\"&lt;&lt;e2&lt;&lt;endl; &#125; return 0;&#125; 1100 Mars Numbers (20 分)题目链接思路：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;string shuzi[13]=&#123;\"tret\",\"jan\",\"feb\",\"mar\",\"apr\",\"may\",\"jun\", \"jly\",\"aug\",\"sep\",\"oct\",\"nov\",\"dec\"&#125;;string beishuzi[13]=&#123;\"tret\",\"tam\",\"hel\",\"maa\",\"huh\",\"tou\", \"kes\",\"hei\",\"elo\",\"syy\",\"lok\",\"mer\",\"jou\"&#125;;string numtostr[170];//数字与火星文的映射map&lt;string,int&gt; strtonum;//火星文与数字的映射void init()&#123; for(int i=0;i&lt;13;i++)&#123; numtostr[i]=shuzi[i];//只有个位时，数-&gt;火星文 strtonum[shuzi[i]]=i;//个位时，火星文-&gt;数 numtostr[i*13]=beishuzi[i];//有十位时且个位为0时，数-&gt;火星文 strtonum[beishuzi[i]]=i*13;//有十位时且个位为0时，火星文-&gt;数 &#125; //都不为0时 for(int i=1;i&lt;13;i++)&#123;//十位 for(int j=1;j&lt;13;j++)&#123;//个位 string str=beishuzi[i]+\" \"+shuzi[j]; numtostr[i*13+j]=str;//十位和个位都不为0的情况，数字-&gt;火星文 strtonum[str]=i*13+j;//十位和个位都不为0的情况，火星文-&gt;数字 &#125; &#125;&#125;int main()&#123; init(); int geshu; scanf(\"%d%*c\",&amp;geshu); while(geshu--)&#123; string str; getline(cin,str);// if(str[0]&gt;='0'&amp;&amp;str[0]&lt;='9')&#123;//如果是数字（这里的数字形式是字符串形式） int num=0; for(int i=0;i&lt;str.length();i++)&#123; num=num*10+(str[i]-'0');//就先算出这个字符串代表的数字的值是多少 &#125; cout&lt;&lt;numtostr[num]&lt;&lt;endl;//输出这个数字值对应的火星文 &#125;else&#123; cout&lt;&lt;strtonum[str]&lt;&lt;endl;//如果是火星文，直接查表输出对应的数字值， &#125; &#125; return 0;&#125; 1054 The Dominant Color (20 分)题目链接思路:用map比较方便，map是这个数字值与这个数字出现的次数的映射。注意it迭代器，it-&gt;first是数字，it-&gt;second是次数。123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;map&gt;using namespace std;int main()&#123; int hang,lie,col; scanf(\"%d%d\",&amp;hang,&amp;lie); map&lt;int,int&gt;count; for(int i=0;i&lt;hang;i++)&#123; for(int j=0;j&lt;lie;j++)&#123; scanf(\"%d\",&amp;col); if(count.find(col)!=count.end()) count[col]++;//若已存在此数，个数就加一 else count[col]=1;//若不存在，就置为1 &#125; &#125; int k=0,max=0;//最大数字值，该数字值出现的次数 for(map&lt;int,int&gt;::iterator it=count.begin();it!=count.end();it++)&#123; if(it-&gt;second &gt; max)&#123; k=it-&gt;first;//获取第一个关键字，即数字 max=it-&gt;second;//获取第二关键字，即这个数字出现的次数 &#125; &#125; printf(\"%d\\n\",k); return 0;&#125; 1071 Speech Patterns (25 分)题目链接思路：与上一题的思路一致。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;bool check(char c)&#123; if(c&gt;='0'&amp;&amp;c&lt;='9') return true; if(c&gt;='A'&amp;&amp;c&lt;='Z') return true; if(c&gt;='a'&amp;&amp;c&lt;='z') return true; return false;&#125;int main()&#123; map&lt;string,int&gt; count; string str; getline(cin,str); int i=0; while(i&lt;str.length())&#123;// string word; while(i&lt;str.length()&amp;&amp;check(str[i])==true)&#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')&#123; str[i]+=32;//大写字母转为小写字母 &#125; word+=str[i];//将这个字符加入到这个单词中 i++;//小标后移一位 &#125; if(word!=\"\")&#123;//单词非空的前提下，计算个数 if(count.find(word)==count.end()) count[word]=1;//如果此单词不存在，就让个数为1 else count[word]++;//如果此单词存在，就将个数加一 &#125; while(i&lt;str.length()&amp;&amp;check(str[i]==false))&#123; i++;//跳过非单词字符 &#125; &#125; //输出最多次数的单词，以及此单词的个数 string ans; int max=0; for(map&lt;string,int&gt;::iterator it=count.begin();it!=count.end();it++)&#123; if(it-&gt;second&gt;max)&#123; max=it-&gt;second; ans=it-&gt;first; &#125; &#125; cout&lt;&lt;ans&lt;&lt;\" \"&lt;&lt;max&lt;&lt;endl; return 0;&#125; 1051 Pop Sequence (25 分)题目链接思路：用数组存储输入的数字，用current去指向每一个待出栈元素最里面一层的while语句是核心判定方法，while循环会一直判定栈顶元素是不是与出栈序列中的current指向的元素相同。如果相同就出栈，如果不同了才会去执行外层的for循环，如果此时for循环成立，则才会再执行st.push(i)语句,即入栈。这里不要理解错误。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stack&gt;using namespace std;const int maxn=1010;int arr[maxn];stack&lt;int&gt; st;int main()&#123; int m,n,t; scanf(\"%d%d%d\",&amp;m,&amp;n,&amp;t); while(t--)&#123; while(!st.empty())&#123; st.pop();//清空栈 &#125; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;arr[i]);//读入数据 &#125; int current=1;//指向出栈序列中的待出栈元素 bool flag=true; for(int i=1;i&lt;=n;i++)&#123; st.push(i);//入栈 if(st.size()&gt;m)&#123;//栈中元素个数超过上限 flag=false; break; &#125; while (!st.empty()&amp;&amp;st.top()==arr[current])&#123;//核心判断 st.pop();//出栈 current++; &#125; &#125; if(st.empty()==true&amp;&amp;flag==true)&#123; printf(\"YES\\n\"); &#125;else&#123; printf(\"NO\\n\"); &#125; &#125; return 0;&#125; 1056 Mice and Rice (25 分)题目链接123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;queue&gt;using namespace std;const int maxn=1010;struct mouse&#123; int weight; int r;&#125;mouse[maxn];int main()&#123; int np,ng,order; scanf(\"%d%d\",&amp;np,&amp;ng); for(int i=0;i&lt;np;i++)&#123; scanf(\"%d\",&amp;mouse[i].weight); &#125; queue&lt;int&gt; q; for(int i=0;i&lt;np;i++)&#123; scanf(\"%d\",&amp;order); q.push(order); &#125; int temp=np,group;//temp是当前轮的参赛老鼠数，group是当前轮的组数 while(q.size()!=1)&#123; if(temp%ng==0) group=temp/ng;//计算出组数 else group=temp/ng+1;//计算出组数，如不能整除，就加一组 for(int i=0;i&lt;group;i++)&#123; int k=q.front();//k存放最大质量的老鼠的编号 for(int j=0;j&lt;ng;j++)&#123;//组内找出最大质量 if(i*ng+j&gt;=temp) break;//此为最后一组时的情况 int front=q.front();//队首老鼠的编号 if(mouse[front].weight&gt;mouse[k].weight)&#123; k=front;//找出这组中最大质量的老鼠 &#125; mouse[front].r=group+1; q.pop();// &#125; q.push(k); &#125; temp=group;//下一轮老鼠的总数为group &#125; mouse[q.front()].r=1; for(int i=0;i&lt;np;i++)&#123; printf(\"%d\",mouse[i].r); if(i&lt;np-1) printf(\" \"); &#125; return 0;&#125; 1052 Linked List Sorting (25 分)题目链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;struct Node&#123; int address,data,next;//地址，数据，下一个地址 bool flag;&#125;node[maxn];//无效结点指的是那些不在链表上的结点bool cmp(Node a,Node b)&#123; if(a.flag==false||b.flag==false)&#123; return a.flag&gt;b.flag;//有无效结点，且把无效结点放在后面 //无效结点的flag=0,有效结点的flag为1，所以能实现把无效结点放在后面 &#125;else&#123; return a.data&lt;b.data;//都是有效结点，则按要求排序,即按数据从小到大的排序 &#125;&#125;int main()&#123; for(int i=0;i&lt;maxn;i++)&#123; node[i].flag=false;//初始化 &#125; int n,begin,address; scanf(\"%d%d\",&amp;n,&amp;begin);//输入个数和开始结点 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;address);//输入地址 scanf(\"%d%d\",&amp;node[address].data,&amp;node[address].next); node[address].address=address; &#125; int count=0,p=begin; while(p!=-1)&#123; node[p].flag=true; count++; p=node[p].next; &#125; if(count==0)&#123; printf(\"0 -1\");//均为无效结点的情况 &#125;else&#123; sort(node,node+maxn,cmp); printf(\"%d %05d\\n\",count,node[0].address); for(int i=0;i&lt;count;i++)&#123; if(i!=count-1)&#123;// %05d不能正确的输出-1 printf(\"%05d %d %05d\\n\",node[i].address,node[i].data,node[i+1].address); &#125;else&#123; printf(\"%05d %d -1\\n\",node[i].address,node[i].data); &#125; &#125; &#125; return 0;&#125; 1074 Reversing Linked List (25 分)题目链接思路：将有效结点按照order从0开始排列，无效结点的order都是maxn，再通过sort排序，就可以将有效结点和无效结点排分开来。（要考虑到有无效结点的存在） 因为题目需要每k个结点就要反转一次，所以，我们可以将每k个结点看为一组，我们可以对每一组从后往前的输出结点，但是，关键是每一组的最后一个结点的next的处理：如果i号结点（假设i号结点是一组中的最后一个结点）不在最后一个完整组中，那么i号结点的next就是（i+2）k-1,即i+1组的最后一个结点。如果i号结点是在最后一个完整组中，且其后没有不完整组了，则i的next为-1，如果i号结点在最后一个不完整组中，且其后还有一组不完整组，则i的next为（i+1)k，即为不完整组中的第一个结点。此题输出的格式处理较麻烦。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100010;struct Node&#123; int address,data,next; int order;//此为链表上的序号，无效结点的序号规定为maxn&#125;node[maxn];bool cmp(Node a,Node b)&#123; return a.order&lt;b.order;&#125;int main()&#123; for(int i=0;i&lt;maxn;i++)&#123; node[i].order=maxn;//全部先初始化为无效结点 &#125; int begin,n,k,address; scanf(\"%d%d%d\",&amp;begin,&amp;n,&amp;k);//起始地址，结点个数，步长 for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;address); scanf(\"%d%d\",&amp;node[address].data,&amp;node[address].next); node[address].address=address; &#125; int p=begin,count=0; while(p!=-1)&#123;//对链表上的结点进行编号 node[p].order=count++; p=node[p].next; &#125; sort(node,node+maxn,cmp); n=count; for(int i=0;i&lt;n/k;i++)&#123;//遍历n/k组 for(int j=(i+1)*k-1;j&gt;i*k;j--)&#123;//倒着输出 printf(\"%05d %d %05d\\n\",node[j].address,node[j].data,node[j-1].address); &#125; printf(\"%05d %d\",node[i*k].address,node[i*k].data); if(i&lt;n/k-1)&#123; printf(\"%05d\\n\",node[(i+2)*k-1].address); &#125;else&#123; if(n%k==0)&#123; printf(\"-1\\n\"); &#125;else&#123; printf(\"%05d\\n\",node[(i+1)*k].address); for(int i=n/k*k;i&lt;n;i++)&#123; printf(\"%05d %d \",node[i].address,node[i].data); if(i&lt;n-1)&#123;//这里的if-else是为了区分输出最后一个结点的address //因为最后一个结点的address为-1，%05d不能正确输出-1 printf(\"%05d\\n\",node[i+1].address); &#125;else&#123; printf(\"-1\\n\"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1042 Shuffling Machine (20 分) 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;const int N=54; int originaln[N+1];//存放原始序列int nextn[N+1]; //int finallyn[N+1];//存放改变后的序列char huase[5]=&#123;'S','H','C','D','J'&#125;;int main()&#123; //花色与牌号的关系是： //当牌号为x时：huase[(x-1)/13]为牌号对应的花色 //（x-1）%13+1即为它在所属花色下的编号 int k; scanf(\"%d\",&amp;k); for(int i=1;i&lt;=N;i++)&#123; originaln[i]=i;//初始化牌的编号 &#125; for(int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;nextn[i]); &#125; for(int step=0;step&lt;k;step++)&#123;//执行k次 for(int i=1;i&lt;=N;i++)&#123; finallyn[nextn[i]]=originaln[i];//位置为j的牌号为originaln[j]， //要放在位置为nextn[j]上 &#125; for(int i=1;i&lt;=N;i++)&#123; originaln[i]=finallyn[i]; &#125; &#125; for(int i=1;i&lt;=N;i++)&#123; if(i!=1) printf(\" \"); //originaln[i]--; printf(\"%c%d\",huase[(originaln[i]-1)/13],(finallyn[i]-1)%13+1);//这里要注意 &#125; return 0;&#125; 1046 Shortest Distance (20 common.points) 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int pointers;int chaxun;int main()&#123; int pointerzu[maxn]; int shi=0,zhong=0,zongchang=0; int changbu=0; scanf(\"%d\",&amp;pointers); for(int i=0;i&lt;pointers;i++)&#123; scanf(\"%d\",&amp;pointerzu[i]); zongchang+=pointerzu[i]; &#125; scanf(\"%d\",&amp;chaxun); for(int i=0;i&lt;chaxun;i++)&#123; scanf(\"%d%d\",&amp;shi,&amp;zhong); int chang=0; if(shi&gt;zhong)&#123; // int temp=shi; // shi=zhong; // zhong=temp; swap(shi,zhong); &#125; for(int j=shi-1;j&lt;zhong-1;j++)&#123; chang+=pointerzu[j]; &#125; changbu=zongchang-chang; if(changbu&lt;chang)&#123; chang=changbu; &#125; printf(\"%d\\n\",chang); &#125; return 0;&#125; 上面的方法里面有for循环的嵌套，在运行的时候可能会运行超时，所以可以优化一下： 1065 A+B and C (64bit) (20 分)注意：这题要注意溢出的判断，如果两个正数之和为负数，就为正溢出，如果两个负数相加为正数，就为负溢出12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; long long a,b,c; int n; int tcase=1; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;c); long long res=a+b; bool flag; if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;res&lt;0) flag=true;//正溢出， else if(a&lt;0&amp;&amp;b&lt;0&amp;&amp;res&gt;=0) flag=false;//负溢出 else if(res&gt;c) flag=true; else flag=false; if(flag==true) printf(\"Case #%d: true\\n\",tcase++); else printf(\"Case #%d: false\\n\",tcase++); &#125; return 0;&#125; 1002 A+B for Polynomials (25 分)思路：用数组下标作为次项，对应的数组中存放的是对应此项的系数。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;const int maxn=1111;double p[maxn]=&#123;&#125;;int main()&#123; int count=0;//个数 int cixiang=0;//次项 double a; scanf(\"%d\",&amp;count); for(int i=0;i&lt;count;i++)&#123; scanf(\"%d %lf\",&amp;cixiang,&amp;a); // scanf(\"%lf\",&amp;p[cixiang]);//该次项对应的系数 p[cixiang]+=a;//注意这样写，直接输入系数，像上面那样是错的，因为遇到相同的次数的话，会覆盖掉之前存的系数 &#125; scanf(\"%d\",&amp;count); // double xishu; for(int i=0;i&lt;count;i++)&#123; scanf(\"%d %lf\",&amp;cixiang,&amp;a); p[cixiang]+=a; //下面为另一种实线思路：功能同p[cixiang]+=a,但是不简洁 // if(!p[cixiang]==0)&#123; // scanf(\"%lf\",&amp;xishu); // p[cixiang]+=xishu; // &#125;else&#123; // scanf(\"%lf\",&amp;p[cixiang]); // &#125; &#125; int shu=0; for(int i=0;i&lt;maxn;i++)&#123; if(p[i]!=0) shu++;//统计有多少非零项 &#125; printf(\"%d\",shu); for(int i=maxn-1;i&gt;=0;i--)&#123; if(p[i]!=0)&#123; printf(\" %d %.1f\",i,p[i]); &#125; &#125; return 0;&#125;","link":"/2019/05/07/pat-a-solution/"},{"title":"windump使用注意事项","text":"之前在准备的时候需要用到windump这个软件，这里就主要记录一下使用过程中遇到的坑吧。。 首先使用windump是需要安装winpcap的，安装就好，然后在命令行下直接使用windump。（要先打开到windump所处的位置）接着windump是直接监听网卡，所以你要选择你监听的网卡，这里也需要注意，你无线上网或者有线上网是不一样的，不然是捕获不到包的。有代理服务器的话也会多出来另外一个选择，所以最好要先运行windump -D先把网卡列表显示出来。（这里切记是大写的D,坑~）之后你再选择了哪一个网卡之后在进行针对性操作。例如，你可以键入： windump -i 2 -q -w C:\\perflogs\\filename\\ -n -C 30 -W 10 -U -s 0 其中， -i是选择你需要监听的网卡号，这里选择的是2号。 -q是指在安静（quiet）模式下。 -w是要创建的文件的前缀。 -n是指不会解析主机名称，以ip地址存储。 -C是此文件大小为百万字节，多了就转移到下一个文件。 -W是指将抓取的包存在一个位于perflogs处的文件中，文件名可以自己起。 -U是指随着每个数据包的保存，它将被写入输出文件。 -s减少了数据包缓冲量，将其设置为零。 （注意:一定要区分大小写，空格.） 抓包成功后，我们可以使用wireshark去分析，wireshark的安装等就不说了，这里主要介绍一下，在你选定一条数据包的时候，双击去查看他的详细信息。 (图片来源网络) 这里有： 帧：这里告诉用户帧号，与数据包有关的时间相关信息，帧长度，帧内的协议以及着色规则。 以太网II：指示数据包的来源和目的地。 Internet协议：包含了源和目标信息以及版本，标题详细信息和生命周期。可以看到源ip地址和目的ip地址。 TCP（transmission control protocol）:这里捕获有关通信中涉及的源端口和目标端口的信息，下一个要查找的序列号以及不同的标记。 HTTP(Hypertext Transfer Protocol):包含http的版本，服务器信息，超时值，连接状态，内容类型和字符集的信息。 基于行的文本数据：这包含了HTML的源代码。 还有一些根据你具体不同的协议有所不同。 windump的使用信息在百度搜索都很有限，感觉少数人是总结的，大部分都是复制黏贴，嗯。。。 为了能够让更多的人快速，更好的上手windump,本文会持续更新。 2018.5.12更新一、关键字表达式是一个正则表达式，Windump利用它作为过滤报文的条件，如果一个报文满足表达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会被截获。在表达式中一般如下几种类型的关键字。 1、第一种是关于类型的关键字，主要包括host，net，port, 例如 host 192.168.0.111，指明 192.168.0.111是一台主机，net 192.168.0.0 指明 192.168.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host. 2、第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,这些关键字指明了传输的方向。举例说明，src192.168.0.94 ,指明ip包中源地址是192.168.0.94 , dst net 192.168.0.0 指明目的网络地址是192.168.0.0。如果没有指明方向关键字，则缺省是src or dst关键字。 3、第三种是协议的关键字，主要包括fddi,ip,arp,rarp,tcp,udp等类型。Fddi指明是在FDDI(分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则Windump将会监听所有协议的信息包。 4、除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是’and’,’&amp;&amp;’;或运算 是’or’ ,’││’；这些关键字可以组合起来构成强大的组合条件来满足人们的需要，下面举几个例子来说明。A想要截获所有192.168.0.94 的主机收到的和发出的所有的数据包： #Windump host 192.168.0.94B想要截获主机192.168.0.94 和主机192.168.0.168 或192.168.0.111的通信，使用命令：（在命令行中适用括号时，一定要 #Windump host 192.168.0.94 and (192.168.0.168 or 192.168.0.111)C如果想要获取主机192.168.0.94除了和主机192.168.0.111之外所有主机通信的ip包，使用命令： #Windump ip host 192.168.0.94 and ! 192.168.0.111D如果想要获取主机192.168.0.94接收或发出的telnet包，使用如下命令： #Windump tcp port 23 host 192.168.0.94 二、Windump的输出结果介绍1、数据链路层头信息 使用命令 #Windump –e host test100 16:20:51.602645 arp who-has TEST100 tell wh16:20:51.602931 arp reply TEST100 is-at 0:1:2:9a:d:2416:20:51.602979 wh.137 &gt; TEST100.137:16:29:26.397806 TEST100.139 &gt; wh.1226: . 4218060367:4218060368(1) ack 4122708076 win 17223分析：16:20:51是显示的时间， 602645是ID号，首先主机wh发出arp请求test100的MAC地址,接着test100返回了它的MAC地址,wh的137与test100 的137端口发送.test100的139端口向wh的1226端口发送数据, ack 4122708076 表明对序列号是4122708076的包进行响应. win 17223表明发送窗口的大小是17223 2、ARP包的WINDUMP输出信息 使用命令 #Windump arp得到的输出结果是：22:32:42.802509 arp who-has 192.168.0.168 tell 192.168.0.9422:32:42.802902 arp reply 192.168.0.168 is-at 0:1:2:9a:d:24分析: 22:32:42是时间戳, 802509是ID号, arp表明是ARP请求包, who-has 192.168.0.168 tell 192.168.0.94 表示主机192.168.0.94请求主机192.168.0.168的MAC地址.接着arp reply 192.168.0.168 is-at 0:1:2:9a:d:24表示主机192.168.0.168收到请求并返回自己的MAC地址. 3、TCP包的输出信息 用WINDUMP捕获的TCP包的一般输出信息是：时间戳&amp;ID号 src.port1&gt;dst.port2 : flags data-seqno ack window urgent options02:53:03是时间戳, 541838是ID号,src &gt; dst:表明从源地址到目的地址, port1,port2代表端口号,flags是TCP包中的标志信息,S 是SYN标志, F (FIN), P (PUSH) , R (RST) “.” (没有标记); data-seqno是数据包中的数据的顺序号, ack是下次期望的顺序号, window是接收缓存的窗口大小, urgent表明数据包中是否有紧急指针. Options是选项. 4、UDP包的输出信息 用WINDUMP捕获的UDP包的一般输出信息是：时间戳&amp;ID号 src.port1&gt;dst.port2: udp lengthUDP十分简单，上面的输出行表明从主机src的port1端口发出的一个UDP数据包到主机dst的port2端口，类型是UDP， 包的长度是length 三、Windump网络数据的过滤不带任何参数的Windump将搜索系统中所有的网络接口，并显示它截获的所有数据，这些数据对我们不一定全都需要，而且数据太多不利于分析。所以，我们应当先想好需要哪些数据，Windump提供以下参数供我们选择数据： 1、Windump后直接跟 数据-链路层上选择协议 包括ip、arp、rarp、ipx都是这一层的。例如：D:>Windump arp //将只显示网络中的arp即地址转换协议信息。 2、-i选择过滤的网络接口 如果是作为路由器至少有两个网络接口，通过这个选项，就可以只过滤指定的接口上通过的数据。例如：src、dst、port、host、net、ether、gateway这几个选项又分别包含src、dst、port、host、net、ehost 等附加选项。他们用来分辨数据包的来源和去向，src host 192.168.0.1指定源主机IP地址是192.168.0.1，dst net 192.168.0.0/24指定目标是网络192.168.0.0。以此类推，host是与其指定主机相关无论它是源还是目的，net是与其指定网络相关的，ether后面跟的不是IP地址而是物理地址，而gateway则用于网关主机。可能有点复杂，看下面例子就知道了：D:>Windump src host 192.168.0.1 and dst net 192.168.0.0/24过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头。D:>Windump ether src 00:50:04:BA:9B and dst……过滤源主机物理地址为XXX的报头(为什么ether src后面没有host或者net？物理地址当然不可能有网络喽)。D:>Windump src host 192.168.0.1 and dst port not telnet过滤源主机192.168.0.1和目的端口不是telnet的报头。 3、ip icmp arp rarp和tcp、udp、icmp这些选项等都要放到第一个参数的位置 用来过滤数据报的类型。例如：D:>Windump ip src……只过滤数据-链路层上的IP报头。D:>Windump udp and src host 192.168.0.1只过滤源主机192.168.0.1的所有udp报头 4、-n不进行IP地址到主机名的转换 四、Windump实战解析 我经常用的命令是windump –n –S,或者windump –n –S –v 或者windump –n-S-vv.-n表示源地址和目的地址不采用主机名的形式显示而采用IP地址的形式;-S是显示TCP/IP的实际进程数,如果不选择这个选项,可能出现的就是近似值,比如:如果现在的进程数是87334271,下一秒变成了多了一个,就会显示出来是87334272.-v和-vv是让机器显示更加全面的信息,显示诸如存活时间/IP的ID等信息.,上一节1.2.2中已经对各参数的详细功能做了介绍.接着我们对TCP握手过程进行嗅探分析,在windows命令行界面下,运行windump,如下:D:>windump –nwindump: listening on\\Device\\Packet_{9D9A4413-7F41-463A-BA3C-B17145F4A626}02:53:03.541838 192.168.0.194.4423 &gt; 192.168.0.168.80: S 4057648491:4057648491(0) win 16384 (DF) 02:53:03.542005 192.168.0.168.1234 &gt; 192.168.0.194.4423: S 1391008532:1391008532(0) ack 4057648492 win 17520 (DF) 02:53:03.542167 192.168.0.194.4423 &gt; 192.168.0.168.1234: . ack 1 win 17520 (DF) 当TCP三次握手不成功又是怎么样的呢?接着telnet到一台没有开telnet服务的计算机上面,插看windump抓获的数据包C:\\Documents and Settings\\wh&gt;telnet 192.168.0.194Connecting To 192.168.0.194…Could not open a connection to host on port 23 : Connect failed D:>windump –nwindump: listening on\\Device\\Packet_{9D9A4413-7F41-463A-BA3C-B17145F4A626}18:19:45.278916 arp who-has 192.168.0.194 tell 192.168.0.168 18:19:45.279090 arp reply 192.168.0.194 is-at 0:d0:f8:38:de:ab 18:19:45.279108 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF) 18:19:45.279269 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 2869223553 win 0 18:19:45.769542 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF)18:19:45.769757 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 1 win 018:19:46.316397 192.168.0.168.1148 &gt; 192.168.0.194.23: S 2869223552:2869223552(0) win 16384 (DF)18:19:46.316636 192.168.0.194.23 &gt; 192.168.0.168.1148: R 0:0(0) ack 1 win 0以上是利用Windump对TCP的三次握手过程进行分析,Windump的参数很多，功能也非常强大,实际运用中根据实际的需求,来设置参数,获得你所需要的信息.相信每次使用都会有不同的收获． 五、命令参数-a将网络和广播地址转化为名称-c接收指定数据包后退出-d接收人可读的包匹配编译代码到标准输出，然后停止-dd以C程序分段方式捕获包匹配代码-ddd以十进制数据形式捕获包匹配代码-e在每个捕获行打印链路层头标-Ealgo:secret为解密IPSE ESP包使用算法。算法可以是des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或none。默认值是desc-cbc。只有当TCPDUMP编译时使用激活加密选项时，才可以解密数据包。Secret是ESP密匙是ASCII码。当前还不能认为一定是二进制值。该选项是以RFC2406ESP为假设，而不是RFC1827 ESP。只用于调试，不鼓励用真正的密码作为选项。当你在PS或其他场合，把IPSEC密码写在命令行上时，会被他人看到。-f不用符号而用数字方式输出外部英特网地址-F使用文件作为过滤表达式的输入。命令行的其他部分会被忽略。-i在接口上监听。如果没有指定，TCPDUMP将搜索系统接口列表中最小，被配置激活的接口（LOOPBACK接口除外）。可用最先匹配替换这种关系。在WINDOWS中接口可以是网卡的名称，或是网卡的号码（-D参数可显示该号码）。 内核为2。2或其后的LINUX系统，参数“ANY”可以获取所有接口的数据。应注意的是在混乱模式下不能使用“ANY”参数。-l标准输出行缓存。如果你想在捕获数据时查看的话，这个参数很有用。例如：“tcpdump -l │ tee dat or tcpdump -l &gt; dat &amp; tail -f dat.” n 不要将地址（如主机地址，端口号）转换为名称 -N 不要打印主机名称的域名限定。如：如果你使用该参数，TCPDUMP会输出“NIC”而不是“NIC。DDN。MIL”。 -m 从文件模块中载入SMI MIB 模块定义。这个选项可以为TCPDUMP载入多个MIB模块 -O 不要运行包匹配代码优化器。只有在你怀疑优化器有问题时可以使用这个参数。 -p 不要让接口处于“混乱”模式。注意接口可能由于其他原因处于“混乱”模式；因此“-p”不能用作以太网络主机或广播的缩写。 -q 快速（安静？）输出。打印较少的协议信息，因此输出行更短。 -r 从文件中读取包（与参数据-W一起使用）。如果文件是“-”就使用标准输入。 -s 不使用默认的68个字节，更改从每个包中获取数据的字节数量（ SunOS系统实际最小为96）。对于IP，ICMP，TCP和UDP包68个字节已足够，但是对命名服务和NFS包，他们的协议会被截断（见下面）。包被截断是因为在使用参数[│proto]输出时指定受限制的快照，proto是被截断协议层的名称。注意如果使用大的快照会增加处理包的时间，并且明显地减少包的缓存数量。也许会导致包的丢失。你应该将snaplen 设置成你感兴趣协议的最小数。当snaplen 为0时接收整个包。-T根据表达式将选中的数据包表达成指定的类型。当前已有的类型有CNFP（Cisco的网络流量协议），rpc（远端程序调用），rtp（实时程序协议），rtcp（实时程序控制协议），snmp（简单网络管理协议），vat（可视单频工具），和wb（分布式白板）。-R假设ESP/AH包遵守旧的说明（RFC1825到RFC1829）。如果该参数被指定，TCPDUMP不打输出域。因为在ESP/AH说明中没有协议版本，TCPDUMP就无法推断出其版本号。-S输出绝对TCP序列号，而不是相对号。-t每个捕获行不要显示时间戳。-tt每个捕获行显示非格式化的时间时间戳。-v详细输出。例如，显示生存时间TTL，标识符，总长度和IP数据包的选项。也进行额外的包完整性较验，如验证IP和ICMP的头标较验值。-vv更为详细的输出。例如，显示NFS中继包中的其他域。-vvv很详细的输出。如，完全输出TELNET SB… SE选项。带-X参数的TELNET，打印并以十六进制输出。-w不对原始数据包解析打印而是转到文件中去。以后可用-r选项打印。当文件名为“-”表示标准输出。-x以十六进制（去除链路层头标）输出每个数据包。输出整个包的小部分或snaplen 个字节。-X输出十六进制同时，输出ASCII码。如果-x也被设置，数据包会以十六制/ASCII码显示。这对于分析新协议非常方便。如果-x也没有设置，一些数据包的部分会以十六制/ASCII码显示。Win32特殊扩展-B以千字节为单位设置驱动缓存。默认缓存为1M（即1000）。如果在获取数据包时有数据丢失，建议使用该参数增大核心缓存大小，因为驱动缓存大小对数据捕获性能有很大影响。-D显示系统上可用的网卡列表。该参数将返回每块网卡的号码，名称和描述。用户可以输入“WinDump –i 网卡名称”或“WinDump –i 网卡号码”。如果机器有多块网卡，不带参数的WINDUMP命令会从系统的第一块可用网卡开始。","link":"/2018/03/09/windump-use/"},{"title":"PAT_B 分类题解","text":"list: 简单模拟1:1001 害死人不偿命的(3n+1)猜想 （15 分)2:1008 数组元素循环右移问题 （20 分)3:1011 A+B 和 C （15 分)4:1016 部分A+B （15 分)5:1026 程序运行时间 （15 分)6:1046 划拳 （15 分)7:1012 数字分类 （20 分)8:1018 锤子剪刀布 （20 分)9:1010 一元多项式求导 （25 分) 查找元素1:1041 考试座位号 （15 分)2:1004 成绩排名 （20 分)3:1028 人口普查 （20 分)4:1032 挖掘机技术哪家强 （20 分) 图形输出1:1036 跟奥巴马一起编程 （15 分)2:1027 打印沙漏 （20 分) 进制转换1:1022 D进制的A+B （20 分)2:1037 在霍格沃茨找零钱 （20 分) 字符串处理1:1006 换个格式输出整数 （15 分)2:10211021 个位数统计 （15 分)3:1031 查验身份证 （15 分)4:1002 写出这个数 (20 分)5:1009 说反话 (20 分)6:1014 福尔摩斯的约会 (20 分) 排序1:1015 德才论 (25 分) 散列1:1029 旧键盘 (20 分)2:1033 旧键盘打字 (20 分)3:1038 统计同成绩学生 (20 分)4:1039 到底买不买 (20 分)5:1042 字符统计 (20 分) 贪心1:1020 月饼 (25 分)2:1023 组个最小数 (20 分) 二分1:1030 完美数列 (25 分) two pointers1:1035 插入与归并 (25 分) 递推1:1040 有几个PAT (25 分) 快排1:1045 快速排序 (25 分) =================================================================简单模拟1001 害死人不偿命的(3n+1)猜想 （15 分)题目链接思路：基本语句的使用，判断奇偶数的方法。（简单题）12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int a; int cishu = 0; scanf(\"%d\", &amp;a); while (a != 1)&#123; if (a % 2 == 0)&#123; a /= 2; cishu++; &#125; else if (a % 2 == 1)&#123; a = 3 * a + 1; a /= 2; cishu++; &#125; &#125; printf(\"%d\", cishu); return 0;&#125; 1008 数组元素循环右移问题 （20 分)题目链接思路：要保证输入的m&lt;n，不然不符合题意，令m=m%n即实现这个功能。设置一个count变量可以实现输出或者不输出之类的不同输出形式的要求。 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int a[110],n,m; scanf(\"%d%d\",&amp;n,&amp;m); m=m%n;//notice int count=n;//控制是否在数字后面打印空格 for(int i=0;i&lt;n;i++)&#123;//首先先把数字给输入进去 scanf(\"%d\",&amp;a[i]); &#125; for(int i=n-m;i&lt;n;i++)&#123;//输出n-m到n-1 printf(\"%d\",a[i]);//只要打印出来就行，而不需要存入数组中 count--; if(count!=0) printf(\" \"); &#125; for(int i=0;i&lt;n-m;i++)&#123;//输出0到n-m-1 printf(\"%d\",a[i]); count--; if(count!=0) printf(\" \"); &#125; return 0;&#125; 1011 A+B 和 C （15 分)题目链接思路：数字的表示范围明显超出了int型表示的范围，所以可以用long long类型。使用一个变量去输出case #1。1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; int t; scanf(\"%d\",&amp;t); long long a,b,c; int cases=0; for(int i=0;i&lt;t;i++)&#123; cases++; scanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;c); if(a+b&gt;c)&#123; printf(\"Case #%d: true\\n\",cases); &#125;else&#123; printf(\"Case #%d: false\\n\",cases); &#125; &#125; return 0;&#125; 1016 部分A+B （15 分)题目链接思路：学会使用适当的除操作，取余操作去实现取出整数中的每一位。1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; long long a,b; long long da,db; long long pa=0,pb=0; scanf(\"%lld%lld%lld%lld\",&amp;a,&amp;da,&amp;b,&amp;db); while(a!=0)&#123; if(a%10==da) pa=pa*10+da;//important a=a/10; &#125; while(b!=0)&#123; if(b%10==db) pb=pb*10+db;//important b=b/10; &#125; printf(\"%lld\\n\",pa+pb); return 0;&#125; 1026 程序运行时间 （15 分)题目链接思路：1：ans/100是因为要换算为s（秒）单位。2：题目要求四舍五入，因此需要对c2-c1的末两位来判断四舍还是五入，当后两位不小于50时，则要进位。如何看c2-c1的末两位？取余100。3：类似的操作还有:看一个整数的个位:取余10（a%10）；看一个两位整数的十位，除10（a/10）；看一个三位整数的十位，先除10再取余10（a/10%10）；看一个三位整数的百位，除100（a/100）;看一个四位整数的百位，先除100，再取余10（a/100%10）…4：ans/3600就是小时数，ans%3600就是去除小时数后剩余的部分，这个部分再除以60就是分钟数，取余就是秒数。12345678910111213#include&lt;stdio.h&gt;int main()&#123; int c1,c2; scanf(\"%d%d\",&amp;c1,&amp;c2); int ans=c2-c1; if(ans%100&gt;=50)&#123;//要进位 ans=ans/100+1; &#125;else&#123;//不需要进位 ans=ans/100; &#125; printf(\"%02d:%02d:%02d\\n\",ans/3600,ans%3600/60,ans%60); return 0;&#125; 1046 划拳 （15 分)题目链接123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int cishu; scanf(\"%d\",&amp;cishu); int jhan,jhua,yhan,yhua; int jhe=0,yhe=0; for(int i=0;i&lt;cishu;i++)&#123; scanf(\"%d%d%d%d\",&amp;jhan,&amp;jhua,&amp;yhan,&amp;yhua); if(jhua==jhan+yhan&amp;&amp;yhua!=jhan+yhan)&#123; yhe++; &#125; if(yhua==jhan+yhan&amp;&amp;jhua!=jhan+yhan)&#123; jhe++; &#125; &#125; printf(\"%d %d\\n\",jhe,yhe); return 0;&#125; 1012 数字分类 （20 分)题目链接思路：想到用数组去处理。最后一个输出后面不能有空格，不然会有格式错误。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;int main()&#123; int count[5]=&#123;0&#125;;//存放五类数字的个数 int ans[5]=&#123;0&#125;;//五类数字的输出结果 int n,temp; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;temp); if(temp%5==0)&#123; if(temp%2==0)&#123; ans[0]+=temp; count[0]++; &#125; &#125;else if(temp%5==1)&#123; if(count[1]%2==0)&#123; ans[1]+=temp; &#125;else&#123; ans[1]-=temp; &#125; count[1]++; &#125;else if(temp%5==2)&#123; count[2]++; //printf(\"count[2]\"); &#125;else if(temp%5==3)&#123; ans[3]+=temp; count[3]++; //ans[3]=ans[3]/count[3]; //printf(\"%.1\\n\",ans[3]); &#125;else&#123; if(ans[4]&lt;temp)&#123; ans[4]=temp; &#125; count[4]++; &#125; &#125; if(count[0]==0) printf(\"N \"); else printf(\"%d \",ans[0]); if(count[1]==0) printf(\"N \"); else printf(\"%d \",ans[1]); if(count[2]==0) printf(\"N \"); else printf(\"%d \",count[2]); if(count[3]==0) printf(\"N \"); else printf(\"%.1f \",(double)ans[3]/count[3]); if(count[4]==0) printf(\"N\");//这里的N后面没有空格 else printf(\"%d\",ans[4]);//这里是\"%d\",不是\"%d \" return 0;&#125; 1018 锤子剪刀布 （20 分)notice题目链接思路：用changes函数，将字符与数字对应，这样可以更方便的实现石头剪刀布的游戏规则。scanf(“%c”)会将你输入的\\n等都输出到屏幕上，我们要避免这种情况，就需要用getchar()去吸取掉。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;int changes(char a)&#123; if(a=='B') return 0; if(a=='C') return 1; if(a=='J') return 2;&#125;int main()&#123; int frequency; scanf(\"%d\",&amp;frequency); char jia,yi; char mp[3]=&#123;'B','C','J'&#125;; int time_A[3]=&#123;0&#125;; int time_B[3]=&#123;0&#125;; int hand_A[3]=&#123;0&#125;,hand_B[3]=&#123;0&#125;; for(int i=0;i&lt;frequency;i++)&#123; getchar();// scanf(\"%c %c\",&amp;jia,&amp;yi); int k1=changes(jia); int k2=changes(yi); if((k1+1)%3==k2)&#123;//好好理解一下 time_A[0]++; time_B[2]++; hand_A[k1]++; &#125;else if(k1==k2)&#123; time_A[1]++; time_B[1]++; &#125;else&#123; time_A[2]++; time_B[0]++; hand_B[k2]++; &#125; &#125; printf(\"%d %d %d\\n\",time_A[0],time_A[1],time_A[2]); printf(\"%d %d %d\\n\",time_B[0],time_B[1],time_B[2]); int id1=0,id2=0; for(int i=0;i&lt;3;i++)&#123; if(hand_A[i]&gt;hand_A[id1]) id1=i; if(hand_B[i]&gt;hand_B[id2]) id2=i; &#125; printf(\"%c %c\\n\",mp[id1],mp[id2]); return 0;&#125; 1010 一元多项式求导 （25 分) 题目链接思路：使用数组a,将多项式的系数和次数的对应关系联系起来，即“a[多项式的指数]=对应多项式的系数”。变量count是统计非零项的个数的。注意输出的格式。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int coefficient; int index; int count=0; int a[1010]=&#123;0&#125;; while(scanf(\"%d %d\",&amp;coefficient,&amp;index)!=EOF)&#123; a[index]=coefficient;//important &#125; a[0]=0;//常数项求导为0 for(int i=1;i&lt;=1000;i++)&#123; a[i-1]=i*a[i];//求导公式 a[i]=0;// if(a[i-1]!=0)//如果是非零项，个数就加一 count++; &#125; if(count==0) printf(\"0 0\");//指数和系数都是0的情况 else&#123; for(int i=1000;i&gt;=0;i--)&#123; if(a[i]!=0)&#123; printf(\"%d %d\",a[i],i); count--; if(count!=0)//如果还有未输出的非零项，那么紧接着要输出空格 printf(\" \"); &#125; &#125; &#125; return 0;&#125; 查找元素1041 考试座位号 （15 分)题目链接思路：处理不同类型的数据，可以使用结构体，且将试机座位号作为数组下标更好。准考证是14位数字，所以可以用long long型来存储他。12345678910111213141516171819202122232425#include&lt;stdio.h&gt;const int maxn=1010;struct Student&#123; long long id; int zuohao;&#125;testseat[maxn];int main()&#123; int n; int chaxun; scanf(\"%d\",&amp;n); long long id; int jihao,zuohao; for(int i=0;i&lt;n;i++)&#123; scanf(\"%lld%d%d\",&amp;id,&amp;jihao,&amp;zuohao); testseat[jihao].id=id; testseat[jihao].zuohao=zuohao; &#125; scanf(\"%d\",&amp;chaxun); for(int i=0;i&lt;chaxun;i++)&#123; scanf(\"%d\",&amp;jihao); printf(\"%lld %d\\n\",testseat[jihao].id,testseat[jihao].zuohao); &#125; return 0;&#125; 1004 成绩排名 （20 分)题目链接思路：使用结构体，因为是只需要输出得分最值，所以没有必要对输入的所有学生信息都存储下来，只需要在for循环的时候再用if语句判断一下。结构体里的数组类型，在输入的时候，前面不需要加取地址符（&amp;）。name[]数组最少要有十一个空间，因为字符数组最后要多存储\\n作为结尾标记，题目说明name和id是字符长度不超过10,所以至少要超过11位。注意输出格式。1234567891011121314151617181920212223#include&lt;stdio.h&gt;struct Student&#123; char name[15]; char id[15]; int score;&#125;temp,maxn,minn;int main()&#123; int n; maxn.score=-1; minn.score=101; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%s%s%d\",temp.name,temp.id,&amp;temp.score);//notice if(temp.score&gt;maxn.score) maxn=temp; if(temp.score&lt;minn.score) minn=temp; &#125; printf(\"%s %s\\n\",maxn.name,maxn.id); printf(\"%s %s\\n\",minn.name,minn.id); return 0;&#125; 1028 人口普查 （20 分)题目链接思路：使用结构体，最好使用单独的函数来判断年轻和年长。注意输入和输出的格式，这里年长的日期在数值上看是最小的，年轻的日期在数值上看是最大的，这个要转过弯来。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;struct Person&#123; char name[10]; int year,month,day;&#125;old,young,temp,left,right;bool lessEqu(Person a,Person b)&#123; if(a.year!=b.year) return a.year&lt;=b.year; else if(a.month!=b.month) return a.month&lt;=b.month; else return a.day&lt;=b.day;&#125;bool moreEqu(Person a,Person b)&#123; if(a.year!=b.year) return a.year&gt;=b.year; else if(a.month!=b.month) return a.month&gt;=b.month; else return a.day&gt;=b.day;&#125;void init()&#123; young.year=left.year=1814; old.year=right.year=2014; young.month=old.month=left.month=right.month=9; young.day=old.day=left.day=right.day=6;&#125;int main()&#123; init(); int n,hefarenshu=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%s %d/%d/%d\",temp.name,&amp;temp.year,&amp;temp.month,&amp;temp.day);//notice if(moreEqu(temp,left)&amp;&amp;lessEqu(temp,right))&#123; hefarenshu++; if(lessEqu(temp,old)) old=temp; if(moreEqu(temp,young)) young=temp; &#125; &#125; if(hefarenshu==0) printf(\"0\\n\");//notice else printf(\"%d %s %s\\n\",hefarenshu,old.name,young.name);//notice return 0;&#125; 1032 挖掘机技术哪家强 （20 分)题目链接12345678910111213141516171819202122232425#include&lt;stdio.h&gt;const int maxn=100010;int school[maxn]=&#123;0&#125;;int main()&#123; int num; int id; int score=0; scanf(\"%d\",&amp;num); for(int i=0;i&lt;num;i++)&#123; scanf(\"%d%d\",&amp;id,&amp;score); school[id]+=score; &#125; int maxscore=-1,maxid=1; for(int i=1;i&lt;=num;i++)&#123; if(school[i]&gt;maxscore)&#123; maxscore=school[i]; maxid=i; &#125; &#125; printf(\"%d %d\",maxid,maxscore); return 0; &#125; 图形输出1036 跟奥巴马一起编程 （15 分)思路：题目要求高是宽的一半，且满足四舍五入，所以要判断奇偶。注意输出格式。123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int n; char zifu; int high; scanf(\"%d %c\",&amp;n,&amp;zifu); if(n%2==0) high=n/2; else high=n/2+1; for(int i=0;i&lt;n;i++)&#123; printf(\"%c\",zifu); &#125; printf(\"\\n\"); for(int i=0;i&lt;high;i++)&#123; printf(\"%c\",zifu); for(int j=0;j&lt;n-2;j++)&#123; printf(\" \"); &#125; printf(\"%c\\n\",zifu); &#125; for(int i=0;i&lt;n;i++)&#123; printf(\"%c\",zifu); &#125; return 0;&#125; 1027 打印沙漏 （20 分)思路：这里要先能够算出这个类似两个三角形的底边长，然后要找要输出的字符和空格之间的关系。 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int n; char zifu; scanf(\"%d %c\",&amp;n,&amp;zifu); int bottom=(int)sqrt(2.0*(n+1))-1; if(bottom%2==0) bottom--; int used=(bottom+1)*(bottom+1)/2-1; for(int i=bottom;i&gt;=1;i-=2)&#123; for(int j=0;j&lt;(bottom-i)/2;j++)&#123; printf(\" \"); &#125; for(int j=0;j&lt;i;j++)&#123; printf(\"%c\",zifu); &#125; printf(\"\\n\"); &#125; for(int i=3;i&lt;=bottom;i+=2)&#123; for(int j=0;j&lt;(bottom-i)/2;j++)&#123; printf(\" \"); &#125; for(int j=0;j&lt;i;j++)&#123; printf(\"%c\",zifu); &#125; printf(\"\\n\"); &#125; printf(\"%d\\n\",n-used); return 0;&#125; 进制转换1022 D进制的A+B （20 分)题目链接思路：这里就只考了除基取余法，直接用这个思路就行。注意ans数组要倒着输出。123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a,b,d; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;d); int sum=a+b; int ans[31],num=0; do&#123;//除基取余法 ans[num++]=sum%d; sum/=d; &#125;while(sum!=0); for(int i=num-1;i&gt;=0;i--)&#123;//倒着输出 printf(\"%d\",ans[i]); &#125; return 0;&#125; 1037 在霍格沃茨找零钱 （20 分)题目链接思路：将Galleon和Sickle都转化为Knut，然后再进行做差，就知道要找多少零钱了，在输出的时候再转化为各自的单位就行。当实付的钱小于价格的时候，就要输出负值，如代码中的if语句。12345678910111213141516#include&lt;stdio.h&gt;const int Galleon=29*17;const int Sickle=29;int main()&#123; int Galleona,Sicklea,Knuta,Galleonb,Sickleb,Knutb; scanf(\"%d.%d.%d %d.%d.%d\",&amp;Galleona,&amp;Sicklea,&amp;Knuta,&amp;Galleonb,&amp;Sickleb,&amp;Knutb);//注意格式 int price=Galleona*Galleon+Sicklea*Sickle+Knuta; int realp=Galleonb*Galleon+Sickleb*Sickle+Knutb; int chap=realp-price; if(chap&lt;0)&#123; printf(\"-\");//先输出负号 chap=-chap;//再输出这个差价的绝对值 &#125; printf(\"%d.%d.%d\\n\",chap/Galleon,chap%Galleon/Sickle,chap%Sickle);//注意输出格式 return 0;&#125; 1006 换个格式输出整数 （15 分)题目链接123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int num; scanf(\"%d\",&amp;num); if(num/100!=0)&#123; int bai=num/100; for(int i=0;i&lt;bai;i++)&#123; printf(\"B\"); &#125; &#125; if(num%100/10!=0)&#123; int shi=num%100/10; for(int i=0;i&lt;shi;i++)&#123; printf(\"S\"); &#125; &#125; if(num%10!=0)&#123; int ge=num%10; for(int i=1;i&lt;=ge;i++)&#123; printf(\"%d\",i); &#125; &#125; return 0;&#125; 1021 个位数统计 （15 分)题目链接思路：用字符数组的形式输入题目中的正整数N，然后可以通过strlen获得N的长度。其中str[i]-‘0’是将字符型数字转为整数型数字。1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str[1000]; gets(str); int len=strlen(str); int count[10]=&#123;0&#125;; for(int i=0;i&lt;len;i++)&#123; count[str[i]-'0']++; &#125; for(int i=0;i&lt;10;i++)&#123; if(count[i]!=0) printf(\"%d:%d\\n\",i,count[i]); &#125; return 0;&#125; 1031 查验身份证 （15 分)题目链接123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;int quanzhong[]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;char M[]=&#123;'1','0','X','9','8','7','6','5','4','3','2'&#125;;int main()&#123; int num; scanf(\"%d\",&amp;num); bool flag=true; char str[20]; int last=0; int j; for(int i=0;i&lt;num;i++)&#123; scanf(\"%s\",str);//存储输入的身份证 for(j=0;j&lt;17;j++)&#123; if(!(str[i]&gt;='0'&amp;&amp;str[j]&lt;='9')) break;//非数字的话直接break last+=(str[j]-'0')*quanzhong[j];//记录了前17个数的加权和 &#125; &#125; if(j&lt;17)&#123;//这个if是在break跳出后会判定的地方， flag=false;//也即是有非数字存在后才会跳到这里 printf(\"%s\\n\",str);//所以就是flag为false,打印身份证号码 &#125;else&#123; if(M[last%11]!=str[17])&#123; flag=false; printf(\"%s\\n\",str);//校验码不等于身份证最后一位的情况下 &#125; &#125; if(flag==true)&#123; printf(\"All passed\\n\"); &#125; return 0;&#125; 1002 写出这个数 (20 分)题目链接思路：用字符数组去存储输入的数，然后用for循环算出sum，接着使用while循环将sum中的每一个数字取出来放在ans数组中，最后以ans[i]作为shuzi[]数组的下标。1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;char shuzi[10][5]=&#123;\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"&#125;;int main()&#123; char str[110]; gets(str);//用字符数组来存储 int len=strlen(str); int sum; for(int i=0;i&lt;len;i++)&#123; sum+=(str[i]-'0');//得到输入的数字的各位数的和 &#125; int num=0,ans[10]; while(sum!=0)&#123;//将sum的每一位数字存在ans数组中 ans[num]=sum%10; num++; sum/=10; &#125; for(int i=num-1;i&gt;=0;i--)&#123; printf(\"%s\",shuzi[ans[i]]); if(i!=0) printf(\" \"); else printf(\"\\n\"); return 0; &#125; 1009 说反话 (20 分)题目链接思路：用二维数组去存储，要熟悉二维数组的操作，注意对是否输出空格的判断。123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str[90]; gets(str); char ans[90][90]; int len=strlen(str); int r,h=0; for(int i=0;i&lt;len;i++)&#123; if(str[i]!=' ')&#123; ans[r][h++]=str[i]; &#125;else&#123; ans[r][h]='\\0'; r++; h=0; &#125; &#125; for(int i=r;i&gt;=0;i--)&#123; printf(\"%s\",ans[i]); if(i&gt;0) printf(\" \"); &#125; return 0;&#125; 1014 福尔摩斯的约会 (20 分)题目链接思路：注意理解清题意，然后使用二维数组去存储。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char riqi[7][5]=&#123;\"MON\",\"TUE\",\"WED\",\"THU\",\"FRI\",\"SAT\",\"SUM\"&#125;;//记得加分号 char str1[70],str2[70],str3[70],str4[70]; fgets(str1); fgets(str2); fgets(str3); fgets(str4); int len1=strlen(str1); int len2=strlen(str2); int len3=strlen(str3); int len4=strlen(str4); int i; for(i=0;i&lt;len1&amp;&amp;i&lt;len2;i++)&#123; if(str1[i]==str2[i]&amp;&amp;str1[i]&gt;'A'&amp;&amp;str1[i]&lt;'G')&#123; printf(\"%s \",riqi[str1[i]-'A']); break; &#125; &#125; for(i++;i&lt;len1&amp;&amp;i&lt;len2;i++)&#123; if(str1[i]==str2[i])&#123; if(str1[i]&gt;='0'&amp;&amp;str1[i]&lt;='9')&#123; printf(\"%2d:\",str1[i]-'0'); break; &#125;else if(str1[i]&gt;='A'&amp;&amp;str1[i]&lt;='G')&#123; printf(\"%2d:\",str1[i]-'A'+10); break; &#125; &#125; &#125; for(int i=0;i&lt;len3&amp;&amp;i&lt;len4;i++)&#123; if(str3[i]==str4[i])&#123; if(str3[i]&gt;'A'&amp;&amp;str3[i]&lt;'Z'||str3[i]&gt;'a'&amp;&amp;str3[i]&lt;'z')&#123; printf(\"%02d\",i); break; &#125; &#125; &#125; return 0;&#125; 排序1015 德才论 (25 分)题目链接思路：要能够想到定义一个学生的类型此题主要考察了sort函数的使用，需要同学们对stl有一个比较熟悉的理解，还有就是考察了for循环语句的考察，尤其考察了if-else if语句的考察还有就是结构体的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct Student&#123; char id[10]; int de,cai,sum; int flag;//考生类别&#125;stu[100010];bool cmp(Student a,Student b)&#123; if(a.flag!=b.flag) return a.flag&lt;b.flag; else if(a.sum!=b.sum) return a.sum&gt;b.sum; else if(a.de!=b.de) return a.de&gt;b.de; else return strcmp(a.id,b.id)&lt;0;&#125;int main()&#123; int n,l,h,num=0; scanf(\"%d%d%d\",&amp;n,&amp;l,&amp;h); for(int i=0;i&lt;n;i++)&#123; scanf(\"%s%d%d\",stu[i].id,&amp;stu[i].de,&amp;stu[i].cai); stu[i].sum=stu[i].de+stu[i].cai; if(stu[i].de&lt;l||stu[i].cai&lt;l)&#123; stu[i].flag=5; &#125;else if(stu[i].de&gt;=h&amp;&amp;stu[i].cai&gt;=h)&#123; stu[i].flag=1; num++; &#125;else if(stu[i].de&gt;=h&amp;&amp;stu[i].cai&lt;=h)&#123; stu[i].flag=2; num++; &#125;else if(stu[i].de&lt;=h&amp;&amp;stu[i].de&gt;=stu[i].cai)&#123; stu[i].flag=3; num++; &#125;else&#123; stu[i].flag=4; num++; &#125; &#125; sort(stu,stu+n,cmp); printf(\"%d\\n\",num); for(int i=0;i&lt;num;i++)&#123; printf(\"%s %d %d\\n\",stu[i].id,stu[i].de,stu[i].cai); &#125; return 0;&#125; 散列1029 旧键盘 (20 分)题目链接思路：两层for循环，用一个bool型数组hashtable来指明字符是否已经输出。123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; bool hashtable[128]=&#123;false&#125;; char yinggai[100]; char shiji[100]; gets(yinggai); gets(shiji); int len1=strlen(yinggai); int len2=strlen(shiji); for(int i=0;i&lt;len1;i++)&#123; int j; char c1,c2; for(j=0;j&lt;len2;j++)&#123; c1=yinggai[i]; c2=shiji[j]; if(c1&gt;='a'&amp;&amp;c1&lt;='z') c1-=32; if(c2&gt;='a'&amp;&amp;c2&lt;='z') c2-=32; if(c1==c2) break; &#125; if(j==len2&amp;&amp;hashtable[c1]==false)&#123; printf(\"%c\",c1); hashtable[c1]=true; &#125; &#125; return 0;&#125; 1033 旧键盘打字 (20 分)题目链接12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn=100010;bool hashtable[256];char str[maxn];int main()&#123; memset(hashtable,true,sizeof(hashtable)); gets(str);//读入失效的键位 int len=strlen(str); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')&#123; str[i]=str[i]-'A'+'a';//转为小写字母 &#125; hashtable[str[i]]=false; &#125; gets(str);//读入要输入的字符串 len=strlen(str); for(int i=0;i&lt;len;i++)&#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')&#123; int low=str[i]-'A'+'a';//转为小写字母 &#125; if(hashtable[low]==true&amp;&amp;hashtable['+']=true)&#123; printf(\"%c\",str[i]); &#125; &#125; printf(\"\\n\"); return 0;&#125; 1038 统计同成绩学生 (20 分)题目链接12345678910111213141516171819#include&lt;stdio.h&gt;int hashtable[110]=&#123;0&#125;;int main()&#123; int n,score,k; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;score); hashtable[score]++; &#125; scanf(\"%d\",&amp;k); for(int i=0;i&lt;k;i++)&#123; scanf(\"%d\",&amp;score); printf(\"%d\",hashtable[score]); if(i&lt;k-1)&#123; printf(\" \"); &#125; &#125; return 0;&#125; 1039 到底买不买 (20 分)题目链接思路：因为颜色总共只有62种可能，26*2个大小字母+10个数字。所以我们完全可以开一个hashtable函数记录每一种颜色的珠子个数，这种想法是最基本的散列思想。12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn=1010;int change(char c)&#123;//将数字和字母转为hashtable的下标 if(c&gt;='0'&amp;&amp;c&lt;='9') return c-'0'; if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'+10; if(c&gt;='A'&amp;&amp;c&lt;='Z') return c-'A'+36;&#125;int main()&#123; int hashtable[80]=&#123;0&#125;; char xianyou[maxn],xuyao[maxn]; int miss=0; gets(xianyou); gets(xuyao); int len1=strlen(xianyou); int len2=strlen(xuyao); for(int i=0;i&lt;len1;i++)&#123; int id=change(xianyou[i]); hashtable[id]++; &#125; for(int i=0;i&lt;len2;i++)&#123; int id=change(xuyao[i]); hashtable[id]--; if(hashtable[id]&lt;0)&#123; miss++;//miss是用来统计缺的珠子的个数 &#125; &#125; if(miss&gt;0) printf(\"No %d\\n\",miss); else&#123; printf(\"Yes %d\\n\",len1-len2);//如果珠子多，只需相减就可以输出多的珠子的个数 &#125; return 0;&#125; 1042 字符统计 (20 分)题目链接思路：基本题型。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn=1010;int main()&#123; int hashtable[30]=&#123;0&#125;; char shuru[maxn]; gets(shuru); int len=strlen(shuru); for(int i=0;i&lt;len;i++)&#123; if(shuru[i]&gt;='a'&amp;&amp;shuru[i]&lt;='z')&#123; hashtable[shuru[i]-'a']++; &#125;else if(shuru[i]&gt;='A'&amp;&amp;shuru[i]&lt;='Z')&#123; hashtable[shuru[i]-'A']++; &#125; &#125; int k=0; for(int i=0;i&lt;26;i++)&#123; if(hashtable[i]&gt;hashtable[k])&#123; k=i; &#125; &#125; printf(\"%c %d\\n\",'a'+k,hashtable[k]); return 0;&#125; 1020 月饼 (25 分)题目链接思路：用结构体。注意使用double型去定义库存，总售价，单价。用sort排序，这样下面就可以使用for循环更方便的遍历处理。根据这个月饼的库存和总需求之间的大小关系，用if-else去更新total_demand和ans。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct mooncake&#123; double store;//库存 double price;//单价 double total_revenue;//总售价&#125;cake[1010];bool cmp(mooncake a,mooncake b)&#123; return a.price&gt;b.price;&#125;int main()&#123; int kind;//种类 double total_demand;//总需求 scanf(\"%d%lf\",&amp;kind,&amp;total_demand); for(int i=0;i&lt;kind;i++)&#123; scanf(\"%lf\",&amp;cake[i].store); &#125; for(int i=0;i&lt;kind;i++)&#123; scanf(\"%lf\",&amp;cake[i].total_revenue); &#125; for(int i=0;i&lt;kind;i++)&#123; cake[i].price=cake[i].total_revenue/cake[i].store; &#125; sort(cake,cake+kind,cmp);//以单价从高到低排序 double ans=0;//收益 for(int i=0;i&lt;kind;i++)&#123;//这里的逻辑要思考一下，注意 if(cake[i].store&lt;=total_demand)&#123; total_demand-=cake[i].store; ans+=cake[i].total_revenue; &#125;else&#123; ans+=cake[i].price*total_demand; break; &#125; &#125; printf(\"%.2f\\n\",ans); return 0;&#125; 1023 组个最小数 (20 分)题目链接思路：先从1-9中找出最小的数，输出在最前面，因为就算0存在，是最小，也不能输出在开头。这也是为什么从1开始遍历的原因。输出最小的那个数之后，循环遍历输出剩余的数字，当这个数字的个数不为0时（也就是说这个数存在）就输出这个数字，且这个数字有多少个就输出多少个（这个数字对应的个数就是geshu[i]）。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int geshu[10]; for(int i=0;i&lt;10;i++)&#123; scanf(\"%d\",&amp;geshu[i]); &#125; int min=0; //最小数 for(int i=1;i&lt;10;i++)&#123;//在1-9中找出最小数 if(geshu[i]!=0)&#123; geshu[i]--; min=i; break;//找到最小的数了就要break &#125; &#125; printf(\"%d\",min); for(int i=0;i&lt;10;i++)&#123; while(geshu[i]!=0)&#123; printf(\"%d\",i); geshu[i]--; &#125; &#125; return 0;&#125; 1030 完美数列 (25 分)题目链接思路：首先要知道能选出的数的个数最大的方案，一定是在该递增序列中选择连续的若干个数的方案。先通过sort函数，将这输入的N个数递增排序。那么每截取一段数列，这个数列的最大值一定是在最右边，最小值一定是在最左边。综上，这个问题就变为了：在输入的n个数中，截取出最长的数列，使得这个数列的最右边的数据小于等于最左边的数据乘以输入的数字p的乘积。输出这个数列的长度。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100010;int p,n,a[maxn];int binarysearch(int i,long long x)&#123;//在i+1到n-1的范围内查找第一个大于x的数的位置 if(a[n-1]&lt;=x) return n; int l=i+1,r=n-1,mid; while(l&lt;r)&#123; mid=(l+r)/2; if(a[mid]&lt;=x) l=mid+1; else r=mid; &#125; return l;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;p); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a,a+n); int ans=1;//最大长度，初始值为1 for(int i=0;i&lt;n;i++)&#123; int j=binarysearch(i,(long long)a[i]*p); ans=max(ans,j-i); &#125; printf(\"%d\\n\",ans); return 0;&#125; 1035 插入与归并 (25 分)题目链接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N=111;int origin[N],tempOri[N],changed[N];int n;//元素个数bool isSame(int A[],int B[])&#123; for(int i=0;i&lt;n;i++)&#123; if(A[i]!=B[i]) return false; &#125; return true;&#125;bool showarray(int A[])&#123;//输出数组 for(int i=0;i&lt;n;i++)&#123; printf(\"%d\",A[i]); if(i&lt;n-1) printf(\" \"); &#125; printf(\"\\n\");&#125;bool insertsort()&#123; //插入排序 bool flag=false; for(int i=1;i&lt;n;i++)&#123; if(i!=1&amp;&amp;isSame(tempOri,changed))&#123; flag=true; &#125; int temp=tempOri[i],j=i; while(j&gt;0&amp;&amp;tempOri[j-1]&gt;temp)&#123; tempOri[j]=tempOri[j-1]; j--; &#125; tempOri[j]=temp; if(flag==true)&#123; return true; &#125; &#125; return false;&#125;void mergeSort()&#123; bool flag=false; for(int step=2;step/2&lt;=n;step*=2)&#123; if(step!=2&amp;&amp;isSame(tempOri,changed))&#123; flag=true; &#125; for(int i=0;i&lt;n;i+=step)&#123; sort(tempOri+i,tempOri+min(i+step,n)); &#125; if(flag==true)&#123; showarray(tempOri); return; &#125; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;origin[i]); tempOri[i]=origin[i]; &#125; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;changed[i]); &#125; if(insertsort())&#123; printf(\"Insertion Sort\\n\"); showarray(tempOri); &#125;else&#123; printf(\"Merge Sort\\n\"); for(int i=0;i&lt;n;i++)&#123; tempOri[i]=origin[i]; &#125; mergeSort(); &#125; return 0;&#125; 1040 有几个PAT (25 分)题目链接思路：对于输出PAT的个数，暴力会超时。可以确定一个处于中间位置的A（所谓的中间位置是指，左边和右边都有字母），去计算出这个A的左边的P的个数，以及A的右边的T的个数，那么PAT字符串的个数，就是左边P的个数与右边T的个数的乘积。所以，对于一个已经确定位置的中间的A而言，一共有这么多种PAT，同理，处于中间位置的其他A的对应的PAT的个数也可以这样得出，然后都加在一起，即为最后的答案。上述过程只是方法论，下面的代码实际的操作不同于上面的思路。具体代码的操作是for循环从左到右的扫描字符串，以leftNump数组去统计这一位及这一位之前的字符串中有P的个数，记录在对应的tempNump[i]中，接着再从右至左的扫描这个字符串，统计右边的T的个数，在扫描的过程中，如果是T就让rightNumt加1，如果是A，就计算对应于这个A的ans，（用对应这个A的leftNump[i]*rightNumt去计算ans），累加各个对应的ans，即为最后的ans.leftNump数组的使用要总结。if else-if语句那是更简洁的处理方法，遇到A就计算ans，因为遇到A了，就说明对于这个A的右边的T的个数已经全都数完了。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int maxn=100010;const int Mod=1000000007;int main()&#123; int leftNump[maxn]=&#123;0&#125;; char shuru[maxn]; int a; gets(shuru); int len=strlen(shuru); for(int i=0;i&lt;len;i++)&#123; if(i&gt;0)&#123;//不是非0号位 leftNump[i]=leftNump[i-1]; &#125; if(shuru[i]=='P')&#123;//如果当前位是p， leftNump[i]++;//那么就令leftNump[i]加1 &#125; &#125; int ans=0,rightNumt=0;//ans为结果，rightNumt记录右边的T的个数 for(int i=len-1;i&gt;=0;i--)&#123; if(shuru[i]=='T')&#123;//如果当前位是T, rightNumt++;//那么右边T的个数加1 &#125;else if(shuru[i]=='A')&#123;//如果当前位是A ans=(ans+leftNump[i]*rightNumt)%Mod;//累计乘积 &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; 1045 快速排序 (25 分)题目链接`c++","link":"/2019/04/21/pat-b-solution/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"web-scraping","slug":"web-scraping","link":"/tags/web-scraping/"},{"name":"OJ","slug":"OJ","link":"/tags/OJ/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"data-structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"C/C++","slug":"C-C","link":"/tags/C-C/"},{"name":"NOI/NOIP","slug":"NOI-NOIP","link":"/tags/NOI-NOIP/"},{"name":"crawler","slug":"crawler","link":"/tags/crawler/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"tcp/ip","slug":"tcp-ip","link":"/tags/tcp-ip/"},{"name":"PAT","slug":"PAT","link":"/tags/PAT/"},{"name":"windump","slug":"windump","link":"/tags/windump/"}],"categories":[]}