<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>data structure——树与二叉树 | turlee&#39;s blog</title>

  
  <meta name="author" content="turlee">
  

  
  <meta name="description" content="看一下知识点：

树的存储结构
二叉树的存储结构
二叉树的性质
树与二叉树的转换
森林与二叉树的转换
二叉树的遍历算法
非递归的二叉树的遍历算法
树的遍历算法
森林的遍历算法
线索二叉树，结构，遍历算法
赫夫曼树和编码
二叉树的确定
二叉树的估计
二叉树表达式


树的存储结构

顺序存储结构即定义一个数组来存储，如：int tree[maxsize];。用数组下标来表示树中的结点，数组元素中的内容表示该结点的双亲结点。所以又称为双亲存储结构。

链式存储结构主要有孩子存储结构和孩子兄弟存储结构两种。


二叉树的定义满足条件：1，每个结点最多只有两棵子树2,子树有左右顺序之分。
二叉树的存储结构

顺序存储结构（适用于完全二叉树）图中右边的规则只是适合完全二叉树，（如果用来储存一般的二叉树会浪费大量的存储空间）且是从0开始编号的。">
  

  
  
  <meta name="keywords" content="data-structure">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="data structure——树与二叉树">

  <meta property="og:site_name" content="turlee&#39;s blog">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="turlee&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">turlee&#39;s blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>data structure——树与二叉树</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/14/data-structure-6/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-14T07:59:35.000Z">
          2018-10-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<p>看一下知识点：</p>
<ul>
<li>树的存储结构</li>
<li>二叉树的存储结构</li>
<li>二叉树的性质</li>
<li>树与二叉树的转换</li>
<li>森林与二叉树的转换</li>
<li>二叉树的遍历算法</li>
<li>非递归的二叉树的遍历算法</li>
<li>树的遍历算法</li>
<li>森林的遍历算法</li>
<li>线索二叉树，结构，遍历算法</li>
<li>赫夫曼树和编码</li>
<li>二叉树的确定</li>
<li>二叉树的估计</li>
<li>二叉树表达式</li>
</ul>
<hr>
<p><strong>树的存储结构</strong></p>
<ul>
<li><p>顺序存储结构<br>即定义一个数组来存储，如：<code>int tree[maxsize];</code>。用<strong>数组下标</strong>来表示树中的结点，数组元素中的内容表示该结点的双亲结点。所以又称为<strong>双亲存储结构</strong>。</p>
</li>
<li><p>链式存储结构<br>主要有孩子存储结构和孩子兄弟存储结构两种。</p>
</li>
</ul>
<p><strong>二叉树的定义</strong><br>满足条件：<br>1，每个结点最多只有两棵子树<br>2,子树有左右顺序之分。</p>
<p><strong>二叉树的存储结构</strong></p>
<ul>
<li>顺序存储结构（适用于完全二叉树）<br><img src="https://github.com/fanandli/picblog/blob/master/erchashu-xingzhi.png?raw=true" width="600" height="350" alt="完全二叉树的顺序存储结构" align="center"><br>图中右边的规则只是适合完全二叉树，（如果用来储存一般的二叉树会浪费大量的存储空间）且是从0开始编号的。<a id="more"></a>
</li>
</ul>
<ul>
<li>链式存储结构（又名二叉链表存储结构）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如下图：<br><img src="https://github.com/fanandli/picblog/blob/master/lianshichuncujiegou.png?raw=true" width="600" height="350" alt="二叉链表1" align="center"></p>
<ul>
<li>树的孩子兄弟存储结构<br>可以用于树等结构，可以将树变为二叉树，然后再用链式存储，其实也是链式存储，和上面那个是一样的意思。<br><img src="https://github.com/fanandli/picblog/blob/master/erchalianbiao.png?raw=true" width="600" height="350" alt="树的孩子兄弟储存结构" align="center"></li>
</ul>
<p><strong>满二叉树</strong><br>在一棵二叉树中，所有所有的分支结点都有左右孩子，并且所有的叶子结点都集中在二叉树的最后一层。</p>
<p><strong>完全二叉树</strong><br>求完全二叉树的高度(h)（完全二叉树与结点个数有关系）<br>看规律：<br>高为1            共有 2^1-1 个结点<br>高为2            共有 2^2-1 个结点<br>高为3            共有 2^3-1 个结点<br>…                …</p>
<p>高为h            共有 2^h-1 个结点                </p>
<p>所以也可以知道高度为h的完全二叉树的结点的个数n在这个范围内<br>2^(h-1)-1&lt; n &lt;=2^h-1<br>2^(h-1)&lt;= n &lt;2^h    处理方法2：2^(h-1)+1&lt;= n+1 &lt;2^h+1<br>h-1&lt;=log<sb>2</sb>n &lt;h (比h-1只大了一个不大于1的小数，所以可以取整)<br>h-1=下取整log2n &lt;h<br>所以<br>h=下取整log2n+1</p>
<p>如果使用处理方法2：那么，可以接着化简：<br>h-1 &lt; log2(n+1) &lt;= h  (比h小了一个不大于1的小数)<br>上取整：h=上取整log2(n+1)</p>
<p><strong>二叉树的性质</strong><br>1，总分支数=总结点数-1（所有树结构都满足这个性质）                         <em>1</em></p>
<p>2，叶子结点数n0,单分支结点数n1，双分支结点数n2。<br>则总结点数=n0+n1+n2                                                   <em>2</em><br>总分支数=n1+2n2 （因为叶子结点无分支，单分支结点1个分支，双分支结点2个分支） <em>3</em></p>
<p>3，由<em>1</em>和<em>2</em>和<em>3</em>联立方程组，解得：n0=n2+1即得：<strong>叶子节点数=双分支结点数+1</strong>。</p>
<p>4，空分支数=总结点数+1</p>
<p><strong>树与二叉树的相互转化</strong><br>把每一个结点的兄弟结点相互连接起来，然后删除父结点与孩子结点的连线，只保留一条，默认的是保留最左边（视觉上的最左的那个）的一个连线。<br>二叉树转换为树的话，过程相反即可。</p>
<p><img src="https://github.com/fanandli/picblog/blob/master/shuyuerchashu-zhuanhuan2.png?raw=true" width="600" height="350" alt="树与二叉树的转换" align="center"></p>
<p><strong>森林与二叉树的相互转换</strong></p>
<p>首先按照将树转换成二叉树的方法，将森林中的每棵树转换为二叉树，然后，将每一个二叉树的根结点的右边的分支连接起来即可。</p>
<p><img src="https://github.com/fanandli/picblog/blob/master/senlinyuerchashu-zhuanhuan.png?raw=true" width="600" height="350" alt="森林与二叉树的转换" align="center"><br><img src="https://github.com/fanandli/picblog/blob/master/shuyuerchashu-zhuanhuan.png?raw=true" width="600" height="350" alt="森林与二叉树的转换" align="center"></p>
<p><strong>二叉树的遍历算法</strong><br>二叉树的深度优先遍历的算法用到<strong>递归</strong>这个概念，所以先看一下递归函数，递归有直接递归和间接递归，这里只讲直接递归<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	r();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单一点讲，递归就是这个函数自己调用自己。在自己中调用自己的时候系统会做一个<strong>保护现场</strong>的操作，在调用玩自己后，系统又会做一个<strong>恢复现场</strong>的操作，这样就可以实现原路返回了，且，第一个调用自己的时候，在返回时是最后一个恢复现场的，这里明显有一个先进后出的感觉，这就是使用了“<strong>系统栈</strong>”，非递归就是使用自己定义的一个<strong>栈</strong>来进行遍历。</p>
<p><strong><em>1.深度优先遍历</em></strong></p>
<ul>
<li><p>先序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Visit(p);</span><br><span class="line">		preorder(p-&gt;lchild);</span><br><span class="line">		preorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		inorder(p-&gt;lchid);</span><br><span class="line">		Visit(p);</span><br><span class="line">		inorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(!p=<span class="literal">NULL</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		postorder(p-&gt;lchid);</span><br><span class="line"> 		postorder(p-&gt;rchild);</span><br><span class="line"> 		Visit(p);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例题：写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LD,RD;</span><br><span class="line">	<span class="keyword">if</span>(p=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LD=getDepth(p-&gt;lchid);</span><br><span class="line">		RD=getDepth(p-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> (LD&gt;RD?LD:RD)+<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用后序遍历方式，先算出左子树的深度<code>LD</code>再算出右子树的深度<code>RD</code>,最后<code>max{LD,RD}+1</code>，加一是因为还有一个根节点。<br>其中<code>LD&gt;RD?LD:RD</code>是一个三目运算符，<code>LD</code>如果大于RD就返回<code>LD</code>,如果不大于就返回<code>RD</code>。</p>
<p>例题：在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点是否存在（找到任何一个满足要求的结点即可），如果存在，则将q指向该结点，否则q赋值为NULL，假设data为int型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(BTNode *p,BTNode *&amp;q,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==key)</span><br><span class="line">			q=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			search(p-&gt;lchild,q,key);</span><br><span class="line">			search(p-&gt;rchild,q,key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此算法可以进行修改，因为只需要找到一个满足条件的结点就好，所以当在左子树中找到这个结点了之后就可以直接退出了，如果没有找到，才需要再在右子树中去寻找，这就是所谓的“<strong>剪枝操作</strong>”，所以代码修改如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(BTNode *p,BTNode *&amp;q,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==key)</span><br><span class="line">			q=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			search(p-&gt;lchild,q,key);</span><br><span class="line">			<span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">				search(p-&gt;rchild,q,key);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例题：假设二叉树采用二叉链表存储结构存储，编写一个程序，输出先序遍历序列中第k个结点的值，假设k不大于总的结点数（结点data域类型为char型）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trave</span><span class="params">(BTNode *p,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++n;</span><br><span class="line">		<span class="keyword">if</span>(k==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		trave(p-&gt;lchild,k);</span><br><span class="line">		trave(p-&gt;rchild,k);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若是中序或者后序遍历的话，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(BTNode *p,<span class="keyword">int</span> k)  <span class="comment">//中序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		trave(p-&gt;lchild,k);</span><br><span class="line">		++n;</span><br><span class="line">		<span class="keyword">if</span>(k==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		trave(p-&gt;rchild,k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trave</span><span class="params">(BTNode *p,<span class="keyword">int</span> k)</span>  <span class="comment">//后序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		trave(p-&gt;lchild,k);</span><br><span class="line">		trave(p-&gt;rchild,k);</span><br><span class="line">		++n;</span><br><span class="line">		<span class="keyword">if</span>(k==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>2.广度优先遍历</em></strong></p>
<ul>
<li>层次遍历<br>层次遍历的主要过程是：从根节点开始，根结点先入队，然后根结点出队，访问他，看他是否存在左右孩子，如果存在就入队，先入左孩子，再入右孩子。然后就是重复以上过程：出队结点，访问，看是否存在左右孩子，存在就入队，直到队空为止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	BTNode *que[maxsize]；  <span class="comment">//定义一个循环列表，来记录要访问的一个层次上的结点</span></span><br><span class="line">	front=rear=<span class="number">0</span>;</span><br><span class="line">	BTNode *q;  <span class="comment">//遍历指针</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rear=(rear+<span class="number">1</span>)%maxsize； <span class="comment">//入队</span></span><br><span class="line">		que[rear]=p;  <span class="comment">//根节点入队</span></span><br><span class="line">		<span class="keyword">while</span>(front!=rear)  <span class="comment">//队列不空的时候循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			front=(front+<span class="number">1</span>)%maxsize;  <span class="comment">//出队</span></span><br><span class="line">			q=que[front];  <span class="comment">//队头结点出队</span></span><br><span class="line">			Visit(q);  <span class="comment">//访问队头结点</span></span><br><span class="line">			<span class="keyword">if</span>(q-&gt;lchild!=<span class="literal">NULL</span>)  <span class="comment">//如果左子树不空,</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear=(rear+<span class="number">1</span>)%maxsize;</span><br><span class="line">				que[rear]=q-&gt;lchild;  <span class="comment">//则左子树的根结点就入队</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(q-&gt;rchild!=<span class="literal">NULL</span>)  <span class="comment">//右子树如果不空，</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear=(rear+<span class="number">1</span>)%maxsize;</span><br><span class="line">				que[rear]=q-&gt;rchild;  <span class="comment">//则右子树的根结点就入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：假设二叉树采用二叉链表储存结构储存，设计一个算法，求出该二叉树的宽度（具有结点数最多的那一层上的结点个数）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	BTNode *p;  <span class="comment">//结点指针</span></span><br><span class="line">	<span class="keyword">int</span> lno;  <span class="comment">//结点的层次号</span></span><br><span class="line">&#125;St;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNode</span><span class="params">(BTNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	St que[maxsize];</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	<span class="keyword">int</span> Lno,i,j,n,max;</span><br><span class="line">	front=rear=<span class="number">0</span>;</span><br><span class="line">	BTNode *q;</span><br><span class="line">	<span class="keyword">if</span>(b!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++rear;</span><br><span class="line">		que[rear].p=b;</span><br><span class="line">		que[rear].lno=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(front!=rear)</span><br><span class="line">		&#123;</span><br><span class="line">			++front;</span><br><span class="line">			q=que[front].p;</span><br><span class="line">			Lno=que[front].lno;</span><br><span class="line">			<span class="keyword">if</span>(q-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				que[rear].p=q-&gt;lchild;</span><br><span class="line">				que[rear].lno=Lno+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(q-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++rear;</span><br><span class="line">				que[rear].p=q-&gt;rchild;</span><br><span class="line">				que[rear].lno=Lno+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		max=<span class="number">0</span>;  <span class="comment">//循环比较Lno，找出最大值，即为最大层数</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lno;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			n=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=rear;++j)</span><br><span class="line">				<span class="keyword">if</span>(que[j].lno==i)</span><br><span class="line">					++n;</span><br><span class="line">				<span class="keyword">if</span>(max&lt;n)</span><br><span class="line">					max=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>树的遍历算法：</strong><br>树只有先序遍历和后序遍历算法，没有中序遍历算法。<br>如果将一棵树转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对树进行先序遍历；对这个二叉树树进行中序遍历就相当于对这个树进行后序遍历。</p>
<ul>
<li><p>树的先序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TNode* p,TNode tree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">		Branch* q;</span><br><span class="line">		q=p-&gt;first;</span><br><span class="line">		<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			preOrder(&amp;tree[q-&gt;cIdx],tree);</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TNode* p,TNode tree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		Branch* q;</span><br><span class="line">		q=p-&gt;first;</span><br><span class="line">		<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			preOrder(&amp;tree[q-&gt;cIdx],tree);</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的层次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(TNode *tn,TNode tree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	TNode *que[maxSize];</span><br><span class="line">	front=rear=<span class="number">0</span>;</span><br><span class="line">	TNode *p;</span><br><span class="line">	<span class="keyword">if</span>(tn!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">		que[rear]=tn;</span><br><span class="line">		<span class="keyword">while</span>(front!=rear)</span><br><span class="line">		&#123;</span><br><span class="line">			front=(front+<span class="number">1</span>)%maxSize;</span><br><span class="line">			p=que[front];</span><br><span class="line">			visit(p);</span><br><span class="line">			Branch* q=p-&gt;first;</span><br><span class="line">			<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">				que[rear]=&amp;tree[q-&gt;cIdx];</span><br><span class="line">				q=q-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>森林的遍历算法：</strong><br>森林也只有先序遍历和后序遍历。<br>如果将一森林转换成二叉树后，那么对应对这个二叉树进行先序遍历就想当于对森林进行先序遍历；对这个二叉树进行中序遍历就相当于对这个森林进行后序遍历。</p>
<p><strong>二叉树的遍历算法的改进：</strong></p>
<ul>
<li><p>先序遍历的非递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderNonrecursion</span><span class="params">(BTNode *bt)</span> <span class="comment">//传入一个二叉树结点类型的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BTNode *Stack[maxsize];  <span class="comment">//建立了一个辅助栈</span></span><br><span class="line">		<span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">		BTNode *p;  <span class="comment">//遍历指针</span></span><br><span class="line">		Stack[++top]=bt;</span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p=Stack[top--];  <span class="comment">//先出栈</span></span><br><span class="line">			Visit(p);</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)  <span class="comment">//如果右孩子存在就入栈</span></span><br><span class="line">				Stack[++p]=p-&gt;rchild;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)  <span class="comment">//如果左孩子存在就入栈</span></span><br><span class="line">				Stack[++top]=p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历的非递归算法</p>
</li>
</ul>
<p>中序遍历的规则是：根结点入栈，栈顶结点的左孩子存在就入栈， 一直向左走，一直走到不能向左走了，即栈顶结点的左孩子不存在，则出栈并输出栈顶结点。然后<strong>向右走一步</strong>，如果栈顶结点的右孩子存在就入栈，再从这个右孩子向左一直走，走到不能向左走为止。不能走了就出栈，看其右孩子是否有，有的话就向右走一步，。。。就这样一直重复。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderNoncursion</span><span class="params">(BTNode *bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BTNode *Stack[maxsize];</span><br><span class="line">		<span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">		BTNode *p=<span class="literal">NULL</span>;		</span><br><span class="line">		p=bt; <span class="comment">//p指向根结点</span></span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">-1</span>||p!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Stack[++top]=p;</span><br><span class="line">				p=p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(top!=<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p=Stack[top--];</span><br><span class="line">				Visit(p);</span><br><span class="line">				p=p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>后序遍历的非递归算法<br>后序遍历可以使用先序遍历得到：先对先序遍历序列进行左右子树的遍历顺序交换，得到逆后序遍历序列；再使用一个栈，将逆后序遍历序列的顺序逆过来输出得到后序遍历序列。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderNoncursion</span><span class="params">(BTNode *bt)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(bt!=<span class="literal">NULL</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		BTNode *Stack1[maxsize];  <span class="comment">//定义一个辅助遍历的栈</span></span><br><span class="line"> 		<span class="keyword">int</span> top1=<span class="number">-1</span>;</span><br><span class="line"> 		BTNode *Stack2[maxsize];  <span class="comment">//定义一个用来逆序的栈</span></span><br><span class="line"> 		<span class="keyword">int</span> top2=<span class="number">-1</span>;</span><br><span class="line"> 		BTNode *p=<span class="literal">NULL</span>;  <span class="comment">//遍历指针</span></span><br><span class="line"> 		Stack1[++top1]=bt;  <span class="comment">//根结点入栈Stack1</span></span><br><span class="line"> 		<span class="keyword">while</span>(top1!=<span class="number">-1</span>)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			p=Stack1[top1--];  <span class="comment">//出栈S1</span></span><br><span class="line"> 			Stack2[++top2]=p;  <span class="comment">//上一步出栈出来的元素入栈到S2</span></span><br><span class="line"> 			<span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line"> 				Stack1[++top1]=p-&gt;lchild;  <span class="comment">//左孩子先入栈</span></span><br><span class="line"> 			<span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line"> 				Stack1[++top1]=p-&gt;rchild;  <span class="comment">//右孩子入栈</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">while</span>(top2!=<span class="number">-1</span>)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			p=Stack2[top2--]; <span class="comment">//出栈,</span></span><br><span class="line"> 			Visit(p); <span class="comment">//后打印</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>二叉树的估计</strong></p>
<p><strong>二叉树的表达式</strong></p>
<p><br></p>
<blockquote>
<p>本文章主要整理于《数据结构高分笔记》和《率辉数据结构辅导专栏》微信号:辉解读。</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/data-structure/">data-structure</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 turlee
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>