<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>data structure——线性表 | turlee&#39;s blog</title>

  
  <meta name="author" content="turlee">
  

  
  <meta name="description" content="顺序表定义：
123456#define maxsize 100typedef struct&amp;#123;	int data[maxsize];	int length;&amp;#125;sqList;
或者可以这样：12int A[maxsize];int n;
单链表结点定义：12345typedef struct LNode&amp;#123;	int data;	struct LNode *next;&amp;#125;LNode;
双链表结点定义：
123456typedef struct DLNode&amp;#123;	int data;	struct DLNode *prior;	struct DLNode *next;	&amp;#125;DLNode;">
  

  
  
  <meta name="keywords" content="data-structure">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="data structure——线性表">

  <meta property="og:site_name" content="turlee&#39;s blog">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="turlee&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">turlee&#39;s blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>data structure——线性表</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/06/data-structure-2/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-06T15:08:04.000Z">
          2018-04-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>顺序表定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxsize];</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;sqList;</span><br></pre></td></tr></table></figure>
<p>或者可以这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[maxsize];</span><br><span class="line"><span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure></p>
<p>单链表结点定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure></p>
<p>双链表结点定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">next</span>;</span>	</span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>下面说几个例题，以说明顺序表的操作：</p>
<p>1.已知一个顺序表<code>L</code>其中元素为递增有序排列，先插入一个元素<code>x</code>使其仍为递增有序排列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">int</span> L[maxsize];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findElem</span><span class="params">(sqList L,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;L.length;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;L.data[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElem</span><span class="params">(sqList &amp;L,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p,i;</span><br><span class="line">	p=findElem(L,x);</span><br><span class="line">	<span class="keyword">for</span>(i=L.length<span class="number">-1</span>;i&gt;=p;--i)</span><br><span class="line">		L.data[i+<span class="number">1</span>]=L.data[i];</span><br><span class="line">	L.data[p]=x;</span><br><span class="line">	++(L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>findElem</code>函数是返回这个递增顺序表中第一个比他大的元素的地址，最后一句<code>return i</code>是在顺序表所有的元素都比他小的情况下，此时<code>for</code>循环不满足条件退了出来，而此时对应的元素的地址刚好是最后一个元素的位置。<br><code>insertElem</code>函数是将找到的位置后面的元素，将元素往右移动，这里<code>L</code>因为本身是要改变，所以用了引用型。函数里面的<code>for</code>循环是从最右边往左一个一个的右移。</p>
<p>2.删除顺序表<code>L</code>中下标为<code>p</code>的元素，成功返回<code>1</code>，不成功返回<code>0</code>并将被删除元素的值赋给<code>e</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteElem</span><span class="params">(sqlist &amp;L,<span class="keyword">int</span> p,<span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;L.length<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[p];</span><br><span class="line">	<span class="keyword">for</span> (i=p;i&lt;L.length;++i)</span><br><span class="line">		L.data[i]=L.data[i+<span class="number">1</span>];</span><br><span class="line">	--(L.length);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是删除一个下标为<code>p</code>的元素，只要直接将<code>p</code>下标之后的元素，从左往右一个一个的覆盖即可。</p>
<p>实例1和实例2，主要就讲了顺序表中最基本的操作：查找，插入，删除。</p>
<p>还有初始化顺序表和求指定位置元素的算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initList</span><span class="params">(sqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.length=o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElem</span><span class="params">(sqlist L,<span class="keyword">int</span> p,<span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;L.length<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[p];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过一个实例来说明一下单链表的操作：</p>
<p>例：A和B是两个带头结点的单链表，其中元素递增有序，设计一个算法，将A和B归并成一个按元素值非递减有序的链表C。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=A-&gt;next;</span><br><span class="line">	LNode *q=B-&gt;next;</span><br><span class="line">	LNode *r;</span><br><span class="line">	C=A;</span><br><span class="line">	C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(B);</span><br><span class="line">	r=C;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			r-&gt;next=p;p=p-&gt;next;</span><br><span class="line">			r=r-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			r-&gt;next=q;q=q-&gt;next;</span><br><span class="line">			r=r-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">	<span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">		r-&gt;next=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实例的主要方法是，首先先创建一个新的单链表<code>C</code>，<code>C</code>的头结点使用<code>A</code>链表的头结点，再用新的指针<code>C</code>指向他。<code>B</code>链表的指针的头结点就没什么用了就<code>free B</code>，接着使用一个<code>if</code>判断，将<code>A</code>，<code>B</code>中的元素的大小进行比较，将小的那个插入到<code>C</code>链表中（<code>A</code>,<code>B</code>单链表是递增有序的）。最后再用一个<code>if</code>判断，将如果一方有剩余的元素的单链表全部插入到<code>C</code>链表中，注意，剩余的插入<code>C</code>链表中，只需要将前面的一个指针链接到<code>C</code>链表后面即可，因为剩余的那个链表后面已经链接好了，不需要再用<code>for</code>循环一个一个的将其断开再链接上去。</p>
<p>这个实例中用了尾插法创建了一个链表，下面对创建链表的方法做一个总结：<br>尾插法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createlistR</span><span class="params">(LNode *&amp;C,<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *s,*r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	C=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	r=C;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=a[i];</span><br><span class="line">		r-next=s;</span><br><span class="line">		r=r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>头插法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createlistF</span><span class="params">(LNode *&amp;C,<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *s;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	C=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	c-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=a[i];</span><br><span class="line">		s-&gt;next=C-&gt;next;</span><br><span class="line">		C-&gt;next=s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上面的实例中如果需要输出的是一个递减的链表<code>C</code>，那么我们就可以使用头插法来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(LNode *A,LNode *B,LNode *&amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=A-&gt;next;</span><br><span class="line">	LNode *q=B-&gt;next;</span><br><span class="line">	LNode *s;</span><br><span class="line">	C=A;</span><br><span class="line">	C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(B);</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			s=p;</span><br><span class="line">			p=p-next;</span><br><span class="line">			s-&gt;next=C-&gt;next;</span><br><span class="line">			C-&gt;next=s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=q;</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">			s-&gt;next=C-&gt;next;</span><br><span class="line">			c-&gt;next=s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		s-&gt;next=C-&gt;next;</span><br><span class="line">		C-&gt;next=s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=q;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">		s-&gt;next=C-&gt;next;</span><br><span class="line">		C-&gt;next=s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头插法的原理图可见：<br>图片来源：<a href="https://www.jianshu.com/p/8613ea20dd19" target="_blank" rel="noopener">https://www.jianshu.com/p/8613ea20dd19</a><br><img src="https://upload-images.jianshu.io/upload_images/1880214-3a289446d88d25be.png" alt></p>
<p>请再看一下个实例：<br>查找链表C中是否存在一个值为x的结点，如果存在则删除该结点并返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAndDelete</span><span class="params">(LNode *C,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p ,*q;</span><br><span class="line">	p=C;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;data==x)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里的<code>p</code>指针，我们是要他停在要删除结点的前驱结点处，而不是直接指向要删除的结点。</p>
<p>双链表：<br>使用尾插法建立:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDlistR</span><span class="params">(DLNode *&amp;L,<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DLNode *s,*r;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	L=(DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">	L-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	r=L;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">		s-&gt;data=a[i];</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		s-&gt;prior=r;</span><br><span class="line">		r=s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>查找结点：<br>查找值为<code>x</code>的结点，找到就返回结点指针，否则返回<code>NULL</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLNode* <span class="title">findNode</span><span class="params">(DLNode *C,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DLNode *p=C-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==x)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入一个结点的操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next-&gt;prior=s;</span><br><span class="line">p-&gt;next=s;</span><br></pre></td></tr></table></figure></p>
<p>删除<code>p</code>结点的后继结点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>下面是例题：<br>1.设顺序表用数组A[]表示，表中元素存储在数组下标<code>0~m+n-1</code>的范围内，前<code>m</code>个元素递增有序，后<code>n</code>个元素也递增有序，设计一个算法，使得整个顺序表都递增有序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertElem</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=m;i&lt;m+n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=A[i];</span><br><span class="line">		<span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;A[j];--j)</span><br><span class="line">		&#123;</span><br><span class="line">			A[j+<span class="number">1</span>]=A[j];  </span><br><span class="line">		&#125;</span><br><span class="line">		A[j+<span class="number">1</span>]=temp;  <span class="comment">//因为for循环多移了一位，所以要j+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.已知递增有序的单链表<code>A</code>,<code>B</code>（个数分别为<code>m</code>,<code>n</code>，且都有头结点）分别存储了一个集合，请设计一份个算法将两个集合的差集(即在<code>A</code>中出现而不在<code>B</code>中)保存在<code>A</code>中，并保持元素递增有序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diffence</span><span class="params">(LNode *A LNode *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=A-&gt;next;</span><br><span class="line">	LNode *pre=A;</span><br><span class="line">	LNode *q=B-&gt;next;</span><br><span class="line">	LNode *r;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			pre=p;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data&gt;q-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;enxt=p-&gt;next;</span><br><span class="line">			r=p;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(r);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.设计一个算法，将顺序表中的元素逆置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">viod <span class="title">reverse</span><span class="params">(sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,j=L.length<span class="number">-1</span>;i&lt;j;++i,j--) <span class="comment">//i&lt;j,不能大于也不能等于</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=L.data[i];</span><br><span class="line">		L.data[i]=L.data[j];</span><br><span class="line">		L.data[j]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.从一个给定顺序表L中删除下标<code>i~j</code>的所有元素。（假定<code>i</code>和<code>j</code>都合法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(sqlist *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k,delta;</span><br><span class="line">	delta=j-i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(k=j+<span class="number">1</span>;k&lt;L.length<span class="number">-1</span>,++k)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[delta]=L.data[k];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length=L.length-delta;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题主要是用第<code>j+1</code>即往后的元素覆盖到<code>i~j</code>之间的元素，这里，如果<code>j+1</code>往后的元素没有<code>I~j</code>之间的元素个数多也不要紧，不要认为就没有”删除”完<code>i~j</code>之间的元素，因为<code>L.length=L.length-delta</code>就已经限定了表长，后面就算有元素也不是表内元素了。</p>
<p>5.一个顺序表<code>L</code>，元素为整型，设计一个算法将比<code>L</code>的表头元素小的元素放在其左边，将比他大的元素放在右边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=L.length<span class="number">-1</span>;</span><br><span class="line">	temp=L.data[i]</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;L.data[j]&gt;temp) --j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">		&#123;</span><br><span class="line">			L.data[i]=L.data[j];</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;L.data[i]&lt;temp) ++i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">		&#123;</span><br><span class="line">			L.data[j]=L.data[j];</span><br><span class="line">			--j;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	L.data[i]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题需要好好的理解一下，主要是要知道，<code>i</code>和<code>j</code>是<strong>轮流移动</strong>的，不是同时移动的，这样就能够保证，在交换的时候不会造成元素丢失，因为他们是轮流着来移动，所以在交换元素之前，这个元素肯定已经存入到了其他的位置了。</p>
<p>6.将一个递增非空单链表中的相同值域的元素删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletesil</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	LNode *q=L-&gt;next-&gt;next;</span><br><span class="line">	*r;</span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(q!=<span class="literal">NULL</span>&amp;&amp;q-&gt;data=p-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			p-&gt;data=q-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)  <span class="comment">//这里有点不理解。。。。</span></span><br><span class="line">		&#123;</span><br><span class="line">			r=q;</span><br><span class="line">			q=q-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(r);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.删除一个单链表<code>L</code>中的最小值结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletesmall</span><span class="params">(LNode &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	LNode *ppre=L;</span><br><span class="line">	LNode *qpre=L;</span><br><span class="line">	LNode *q=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q-&gt;data&lt;p-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			p=q;</span><br><span class="line">			ppre=qpre;</span><br><span class="line">		&#125;</span><br><span class="line">		qpre=q;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	ppre-&gt;next=p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此代码中，之所以要对<code>p</code>再使用一个前驱指针<code>ppre</code>，以及对<code>q</code>也使用了一个前驱指针<code>qpre</code>的原因是通过这前驱指针分别“记住”原来<code>p</code>和<code>q</code>指针的位置在哪。<code>p</code>指针用来指定最小值的位置，<code>q</code>指针则用来向前进，使元素一个一个的与目前<code>p</code>指针所指定的最小值作比较。</p>
<p>8.有一个线性表，采用带头结点的单链表<code>L</code>来存储。设计一个算法将其逆置。要求不能建立新结点，只能通过表中已有的结点的重新组合来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reversel</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	LNode *q;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.设计一个算法，将一个带头结点为<code>A</code>的单链表分解为两个单链表<code>A</code>和<code>B</code>，<code>A</code>链表中含有原来链表中<code>data</code>域中为奇数的结点，<code>B</code>链表中含有原来链表中<code>data</code>域中为偶数的结点。且保持相对位置不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seletejiandou</span><span class="params">(LNode *A,LNode *&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p,*q,*r;</span><br><span class="line">	B=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	B-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	r=B;</span><br><span class="line">	p=A;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;data%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q=p-&gt;next;</span><br><span class="line">			p-&gt;next=q-&gt;next;</span><br><span class="line">			q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			r-&gt;next=q;</span><br><span class="line">			r=q;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10.写出一个函数，逆序打印单链表中的数据，假设指针<code>L</code>指针指向了单链表的开始结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprint</span><span class="params">(LNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		reprint(L-&gt;next);  <span class="comment">//递归逆序打印开始结点的后面的数据</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>11.编写一个函数，以不多于<code>3n/2</code>的平均比较次数，找出在一个<code>n</code>个整数的顺序表<code>A</code>中的最大值和最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchmaxandmin</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n,<span class="keyword">int</span> &amp;max,&amp;min)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	max=min=A[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,i&lt;=n,++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&gt;max)</span><br><span class="line">			max=A[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i]&lt;min)</span><br><span class="line">			min=A[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.假设一个链表只有一个头指针<code>head</code>，设计一个算法，查找链表中倒数第<code>k</code>个位置上的结点，查找成功就返回<code>data</code>值，且返回<code>1</code>，若不成功就返回<code>0</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findElem</span><span class="params">(LNode *head,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p1=head-&gt;next;</span><br><span class="line">	p=head;</span><br><span class="line">	i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p1!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p1=p1-&gt;next;</span><br><span class="line">		++i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;k)</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p==head)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		count&lt;&lt;p-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13.设将<code>n</code>个整数存放在一维数组<code>R</code>中，设计一个尽可能高效的算法将<code>R</code>中保存的序列循环左移<code>P</code>个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (i=l,j=r,i&lt;j,++i,--j)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=R[i];</span><br><span class="line">		R[i]=R[j];</span><br><span class="line">		R[j]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCR</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;n)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		reverse(R,<span class="number">0</span>,p<span class="number">-1</span>);  <span class="comment">//先将前p个逆置</span></span><br><span class="line">		reverse(R,p,n<span class="number">-1</span>);  <span class="comment">//接着将剩下的逆置</span></span><br><span class="line">		reverse(R,<span class="number">0</span>,n<span class="number">-1</span>);  <span class="comment">//最后将所有的一起再逆置一下</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.已知一个整数序列<code>A(a0,a1,a2,..ai..,an-1)</code>其中<code>0&lt;=ai&lt;n(0&lt;=i&lt;n)</code>.如果其中有超过一半的元素的值相同，那么这个相同的值就称之为”主元素”。假设<code>A</code>中的<code>n</code>个元素保存在一个一维数组中，设计一个算法，找出<code>A</code>中的主元素，如果有则输出他，如果没有就输出为<code>-1</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ,c, count=<span class="number">1</span>;</span><br><span class="line">	c=A[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>,i&lt;n,i++)</span><br><span class="line">		<span class="keyword">if</span>(A[i]==c)</span><br><span class="line">			count++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">				count--;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				c=A[i];</span><br><span class="line">				count=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=count=<span class="number">0</span>,i&lt;n,i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i]==c)</span><br><span class="line">				count++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&gt;n/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> c;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/data-structure/">data-structure</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 turlee
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>